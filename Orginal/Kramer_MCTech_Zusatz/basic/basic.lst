 AS V1.42 Beta [Bld 139] - source file basic.asm - page 1 - 8/15/2019 11:33:6


       1/       0 :                     ; This is the commented BASIC listing of the 
       2/       0 :                     ; TDL 12K Extended "Zapple" BASIC, 
       3/       0 :                     ; by Roger Amidon and Neil Colvin, May 1977
       4/       0 :                     ;
       5/       0 :                     ; This was produced by IDA disassembler
       6/       0 :                     ; and further modified for readability (macros and long symbols)
       7/       0 :                     ; note this is, although it looks like, not correct Z80 assembler
       8/       0 :                     ; to be directly fed into an assembler program - mainly because
       9/       0 :                     ; many symbols are too long for Z80 assemblers
      10/       0 :                     ; use this as reference only, rather use the HEX dump
      11/       0 :                     ; to produce a binary.
      12/       0 :                     ;
      13/       0 :                     ; The HEX dump has been compared with this commented file;
      14/       0 :                     ; while commenting, several OCR errors were corrected.
      15/       0 :                     ;
      16/       0 :                     ; The hex dump was produced from the book
      17/       0 :                     ; Rolf-Dieter Klein, Basic-Interpreter, Franzis Verlag München, 1982;
      18/       0 :                     ; in German language, ISBN 3-7723-6941-3
      19/       0 :                     ; The book author himself mentions in the book that he published
      20/       0 :                     ; the hex dump because "Der Interpreter wurde urspruenglich von
      21/       0 :                     ; TDL (Technical Design Labs) entwickelt und ist sehr leistungsfaehig.
      22/       0 :                     ; Da die Firma nicht mehr existiert, soll durch den Abdruck des Listings
      23/       0 :                     ; dem Leser die Moeglichkeit gegeben werden, Zugang zu diesem Basic zu
      24/       0 :                     ; erhalten." (Seite 103) (Translation: the interpreter was developed
      25/       0 :                     ; originally by TDL (Technical Design Labs) and is very powerful.
      26/       0 :                     ; Because the company is no longer in existance, the reader is given
      27/       0 :                     ; the chance, by printing this listing to get access to this Basic).
      28/       0 :                     ;
      29/       0 :                     ; The work of reverse engineering and commenting was done by Holger Veit,
      30/       0 :                     ; 2012 - this whole work is published unter Creative Commons License
      31/       0 :                     ; CC-BY-SA http://creativecommons.org/licenses/by-sa/3.0/
      32/       0 :                     
      33/       0 :                     ; V.Pohlers 05.08.2019 Anpassung an AS-Assembler, Fehlerkorrektur
      34/       0 :                     ; Listing kontrolliert anhand der Pruefsummen aus mc 05/1982, S.71
      35/       0 :                     ; 33 Fehler behoben
      36/       0 :                     ; fehlerfrei assemblierbar mit Arnold-Assembler
      37/       0 :                     ; (http://john.ccac.rwth-aachen.de:8000/as/)
      38/       0 :                     
      39/       0 :                     ;15.08.2019 Modifikation ala KRAMERMC-Basic
      40/       0 :                     
      41/       0 :                     ;--------------------------------------------------------------------
      42/       0 :                     
      43/       0 :                     	cpu	z80undoc
      44/       0 :                     
      45/       0 :                     ;****************************************************************
      46/       0 :                     ; some macro definitions for readability
      47/       0 :                     CPHL_DE         macro
      48/       0 :                                     ld    a, h
      49/       0 :                                     sub   d
      50/       0 :                                     jr    nz, m1
      51/       0 :                                     ld    a, l
      52/       0 :                                     sub   e
      53/       0 :                     m1:
      54/       0 :                                     endm
      55/       0 :                     
      56/       0 :                     LDBC_M          macro
      57/       0 :                                     ld    c, (hl)
      58/       0 :                                     inc   hl
      59/       0 :                                     ld    b, (hl)
      60/       0 :                                     endm
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 2 - 8/15/2019 11:33:6


      61/       0 :                     
      62/       0 :                     LDDE_M          macro
      63/       0 :                                     ld    e, (hl)
      64/       0 :                                     inc   hl
      65/       0 :                                     ld    d, (hl)
      66/       0 :                                     endm
      67/       0 :                     
      68/       0 :                     LDHL_M          macro tmp
      69/       0 :                                     ld    tmp, (hl)
      70/       0 :                                     inc   hl
      71/       0 :                                     ld    h, (hl)
      72/       0 :                                     ld    l, tmp
      73/       0 :                                     endm
      74/       0 :                     				
      75/       0 :                     LDM_BC          macro
      76/       0 :                                     ld    (hl), c
      77/       0 :                                     inc   hl
      78/       0 :                                     ld    (hl), b
      79/       0 :                                     endm
      80/       0 :                     
      81/       0 :                     LDM_DE          macro
      82/       0 :                                     ld    (hl), e
      83/       0 :                                     inc   hl
      84/       0 :                                     ld    (hl), d
      85/       0 :                                     endm
      86/       0 :                     
      87/       0 :                     LDHL_BC         macro
      88/       0 :                                     ld    h, b
      89/       0 :                                     ld    l, c
      90/       0 :                                     endm
      91/       0 :                     
      92/       0 :                     LDHL_DE         macro
      93/       0 :                                     ld    h, d
      94/       0 :                                     ld    l, e
      95/       0 :                                     endm
      96/       0 :                     
      97/       0 :                     LDBC_HL         macro
      98/       0 :                                     ld    b, h
      99/       0 :                                     ld    c, l
     100/       0 :                                     endm
     101/       0 :                     
     102/       0 :                     LDDE_HL         macro
     103/       0 :                                     ld    d, h
     104/       0 :                                     ld    e, l
     105/       0 :                                     endm
     106/       0 :                     
     107/       0 :                     POP_FPREG       macro
     108/       0 :                                     pop   bc
     109/       0 :                                     pop   ix
     110/       0 :                                     pop   de
     111/       0 :                                     endm
     112/       0 :                     
     113/       0 :                     PUSH_FPREG      macro
     114/       0 :                                     push  de
     115/       0 :                                     push  ix
     116/       0 :                                     push  bc
     117/       0 :                                     endm
     118/       0 :                     
     119/       0 :                     PUSH_FPREG1     macro
     120/       0 :                                     push  bc
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 3 - 8/15/2019 11:33:6


     121/       0 :                                     push  ix
     122/       0 :                                     push  de
     123/       0 :                                     endm
     124/       0 :                     				
     125/       0 :                     FPREG_CONST     macro p1, p2, p3
     126/       0 :                                     ld    bc, p1
     127/       0 :                                     ld    ix, p2
     128/       0 :                                     ld    de, p3
     129/       0 :                                     endm
     130/       0 :                     
     131/       0 :                     EXPECT          macro token
     132/       0 :                                     ld    a, token
     133/       0 :                                     call  expect_char
     134/       0 :                     		endm
     135/       0 :                     
     136/       0 :                     TEST_FFFF       macro
     137/       0 :                                     ld    a, h
     138/       0 :                                     and   l
     139/       0 :                                     inc   a                ; is valid (!= ffff)
     140/       0 :                     				endm
     141/       0 :                     
     142/       0 :                     TEST_0          macro
     143/       0 :                                     ld    a, h
     144/       0 :                                     or    l
     145/       0 :                                     endm
     146/       0 :                     				
     147/       0 :                                     
     148/       0 :                     ; **************************************************************
     149/       0 : =3H                 CHAR_CTRLC     equ   3
     150/       0 : =9H                 CHAR_TAB       equ   9
     151/       0 : =AH                 CHAR_LF        equ   0Ah
     152/       0 : =DH                 CHAR_CR        equ   0Dh
     153/       0 : =FH                 CHAR_CTRLO     equ   0Fh
     154/       0 : =11H                CHAR_CTRLQ     equ   11h
     155/       0 : =12H                CHAR_CTRLR     equ   12h
     156/       0 : =13H                CHAR_CTRLS     equ   13h
     157/       0 : =14H                CHAR_CTRLT     equ   14h
     158/       0 : =15H                CHAR_CTRLU     equ   15h
     159/       0 : =18H                CHAR_CTRLX     equ   18h
     160/       0 : =1AH                CHAR_CTRLZ     equ   1Ah
     161/       0 : =1BH                CHAR_ESC       equ   1Bh
     162/       0 : =7FH                CHAR_RUBOUT    equ   7Fh
     163/       0 : =21H                CHAR_EXCL      equ   '!'
     164/       0 : =5CH                CHAR_BSLASH    equ   '\\'
     165/       0 : =20H                CHAR_SPACE     equ   ' '
     166/       0 : =2CH                CHAR_COMMA     equ   ','
     167/       0 : =28H                CHAR_LPAREN    equ   '('
     168/       0 : =29H                CHAR_RPAREN    equ   ')'
     169/       0 : =22H                CHAR_QUOTE     equ   22h
     170/       0 : =27H                CHAR_TIC       equ   27h
     171/       0 : =3BH                CHAR_SEMI      equ   ';'
     172/       0 : =3AH                CHAR_COLON     equ   ':'
     173/       0 : =30H                CHAR_ZERO      equ   '0'
     174/       0 : =39H                CHAR_NINE      equ   '9'
     175/       0 : =25H                CHAR_PERCENT   equ   '%'
     176/       0 : =26H                CHAR_AMP       equ   '&'
     177/       0 : =2EH                CHAR_PERIOD    equ   '.'
     178/       0 : =41H                CHAR_A         equ   'A'
     179/       0 : =45H                CHAR_E         equ   'E'
     180/       0 : =5AH                CHAR_Z         equ   'Z'
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 4 - 8/15/2019 11:33:6


     181/       0 : =2BH                CHAR_PLUS      equ   '+'
     182/       0 : =2DH                CHAR_MINUS     equ   '-'
     183/       0 : =23H                CHAR_HASH      equ   '#'
     184/       0 : =24H                CHAR_DOLLAR    equ   '$'
     185/       0 : =2AH                CHAR_STAR      equ   '*'
     186/       0 : =5EH                CHAR_POWER     equ   '^'
     187/       0 : =3FH                CHAR_QUEST     equ   '?'
     188/       0 :                     
     189/       0 : =80H                TOKEN_END       equ   80h
     190/       0 : =81H                TOKEN_FOR       equ   81h
     191/       0 : =83H                TOKEN_DATA      equ   83h
     192/       0 : =84H                TOKEN_INPUT     equ   84h
     193/       0 : =88H                TOKEN_GOTO      equ   88h
     194/       0 : =89H                TOKEN_FNEND     equ   89h
     195/       0 : =8AH                TOKEN_IF        equ   8Ah
     196/       0 : =8BH                TOKEN_RESTORE   equ   8Bh
     197/       0 : =8CH                TOKEN_GOSUB     equ   8Ch
     198/       0 : =8EH                TOKEN_REM       equ   8Eh
     199/       0 : =97H                TOKEN_QUEST     equ   97h
     200/       0 : =9CH                TOKEN_EXCL      equ   9Ch
     201/       0 : =9DH                TOKEN_USING     equ   9Dh
     202/       0 : =9EH                TOKEN_TAB       equ   9Eh
     203/       0 : =9FH                TOKEN_TO        equ   9Fh
     204/       0 : =A0H                TOKEN_FN        equ   0A0h
     205/       0 : =A1H                TOKEN_SPC       equ   0A1h
     206/       0 : =A2H                TOKEN_THEN      equ   0A2h
     207/       0 : =A3H                TOKEN_NOT       equ   0A3h
     208/       0 : =A4H                TOKEN_STEP      equ   0A4h
     209/       0 : =A5H                TOKEN_PLUS      equ   0A5h
     210/       0 : =A6H                TOKEN_MINUS     equ   0A6h
     211/       0 : =ACH                TOKEN_GREATER   equ   0ACh
     212/       0 : =ADH                TOKEN_EQUAL     equ   0ADh
     213/       0 : =AEH                TOKEN_LESS      equ   0AEh
     214/       0 : =AFH                TOKEN_SGN       equ   0AFh
     215/       0 : =C3H                TOKEN_CHRS      equ   0C3h
     216/       0 : =C6H                TOKEN_MIDS      equ   0C6h
     217/       0 : =C7H                TOKEN_LPOS      equ   0C7h
     218/       0 : =C8H                TOKEN_INSTR     equ   0C8h
     219/       0 : =C9H                TOKEN_ELSE      equ   0C9h
     220/       0 : =D5H                TOKEN_TIC       equ   0D5h
     221/       0 :                     ;
     222/       0 : =EBH                TOKEN_CONT      equ   0EBh		; last used token
     223/       0 :                     
     224/       0 : =7FH                MASK_7BIT       equ   07Fh
     225/       0 : =0H                 NULL            equ   0                ; 0 as string terminator
     226/       0 :                     
     227/       0 :                     ; precedence of operations
     228/       0 : =46H                PREC_OR         equ   46h
     229/       0 : =50H                PREC_AND        equ   50h
     230/       0 : =5AH                PREC_NOT        equ   5ah
     231/       0 : =64H                PREC_STRCMP     equ   64h
     232/       0 : =78H                PREC_RELOP      equ   78h
     233/       0 : =79H                PREC_ADDSUB     equ   79h
     234/       0 : =7CH                PREC_MULDIV     equ   7Ch
     235/       0 : =7DH                PREC_MINUS      equ   7Dh
     236/       0 : =7FH                PREC_POWER      equ   7Fh
     237/       0 :                     
     238/       0 :                     
     239/       0 :                     ; **************************************************************
     240/       0 :                     
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 5 - 8/15/2019 11:33:6


     241/       0 :                     ; this structure is typically pointed to by IY
     242/       0 :                     ; IY is not used otherwise
     243/       0 :                     ioparams        struc
     244/       0 :                     curpos:         db ?                   ; current position
     245/       1 :                     linelength:     db ?                   ; length of output line
     246/       2 :                     last_field:     db ?
     247/       3 :                     padcount:       db ?                   ; # of padding characters
     248/       4 :                     padchar:        db ?                   ; char used for padding after CRLF
     249/       5 :                                                            ; (typically NUL)
     250/       0 : =5H                 ioparams        ends
     251/       0 :                     
     252/       0 :                     ; this is the structure of a string descriptor
     253/       0 :                     string_desc     struc
     254/       0 :                     length:            db ?
     255/       1 :                     unused:         db ?
     256/       2 :                     addr:           dw ?
     257/       0 : =4H                 string_desc     ends
     258/       0 :                     
     259/       0 :                     
     260/       0 :                     
     261/       0 :                     ; BASIC interpreter variables
     262/       0 :                                     org 0
     263/       0 :                     resetvector:    ds 1                   ; contains a C3h (JP)
     264/       1 :                     reset_addr:     ds 2                   ; point to BASIC warmstart
     265/       3 :                     
     266/     C00 :                                     org 0c00h
     267/     C00 :                     iosuppress:     ds 1                   ; flag to suppress I/O
     268/     C01 :                     dim_flag:       ds 1                   ; used in array declaration
     269/     C02 :                     expr_type:      ds 1                   ; type of current expression
     270/     C03 :                                                            ; =0 numeric
     271/     C03 :                                                            ; =1 string
     272/     C03 :                     byte_103:       ds 1                   ; used in tokenizing line
     273/     C04 :                     memory_top:     ds 2                   ; highest memory address
     274/     C06 :                     stringstkptr:   ds 2                   ; ptr to stringstk
     275/     C08 :                     stringstk:      ds 60                  ; stack for storing nested string expressions
     276/     C44 :                     
     277/     C44 :                     ; String accu, temporary scratchpad for string expression processing
     278/     C44 :                     ; must be directly after stringstk
     279/     C44 : (STRUCT)            straccu:        string_desc
     280/     C48 :                     ;		ds 1                   ; length of string
     281/     C48 :                     ;                ds 1                   ; unused
     282/     C48 :                     ;                ds 2                   ; address of string
     283/     C48 :                     string_top:     ds 2                   ; point to end of string area
     284/     C4A :                     arrayvalptr:    ds 2                   ; used in calaculating array values
     285/     C4C :                     currentlineno:  ds 2                   ; stores current lineno in BASIC execution
     286/     C4E :                     subscript_flag: ds 1                   ; subscript flag, used in variable decl. and eval.
     287/     C4F :                                                            ; = 1 (exec_kill)
     288/     C4F :                                                            ; = 0
     289/     C4F :                                                            ; = CHAR_RPAREN
     290/     C4F :                     input_read_flag: ds 1                  ; used in INPUT processing
     291/     C50 :                     curlineptr:     ds 2                   ; ptr to current line in BASIC execution
     292/     C52 :                     lineptrsave:    ds 2                   ; temporary
     293/     C54 :                     lineno:         ds 2                   ; temporary
     294/     C56 :                     contlineno:     ds 2                   ; lineno for CONT
     295/     C58 :                     contlineptr:    ds 2                   ; temporary
     296/     C5A :                     string_base:    ds 2                   ; stack grows below this space
     297/     C5C :                                                            ; string data extends from here to memory_top
     298/     C5C :                     start_memory:   ds 2                   ; start of BASIC program
     299/     C5E :                     prog_end:       ds 2                   ; end of BASIC program, scalar variables start here
     300/     C60 :                     end_of_vars:    ds 2                   ; end of scalar variable table, arrays start here
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 6 - 8/15/2019 11:33:6


     301/     C62 :                     end_arrays:     ds 2                   ; end of array table, start of free space
     302/     C64 :                     
     303/     C64 :                     ; memory layout
     304/     C64 :                     ; start_memory -> BASIC lines
     305/     C64 :                     ; prog_end     -> start of variable table
     306/     C64 :                     ; end_of_vars  -> start of array table
     307/     C64 :                     ; end_arrays   -> end of array table
     308/     C64 :                     ; ----- free space, will grow downward
     309/     C64 :                     ;
     310/     C64 :                     ; temporary expression stack
     311/     C64 :                     ; string_base  -> start of string space
     312/     C64 :                     ; string_top   -> end of string space, growing downwards
     313/     C64 :                     ; memory_top   -> highest memory
     314/     C64 :                     ;
     315/     C64 :                     ; format of BASIC line
     316/     C64 :                     ; xxxx -> link to next line (0000 if end of program)
     317/     C64 :                     ; nnnn -> lineno (1...65520)
     318/     C64 :                     ; tokenized basic line
     319/     C64 :                     ; 00 -> end of line
     320/     C64 :                     ; link points to here
     321/     C64 :                     
     322/     C64 :                     data_ptr:       ds 2                   ; ptr to next DATA item to be READ
     323/     C66 :                     
     324/     C66 :                     ; FP ACCU #1, stores value in packed format
     325/     C66 :                     ; i.e. mant6-2 (1 only exists in register calculations)
     326/     C66 :                     ; contain mantissa with    sign bit in mant6, normalized
     327/     C66 :                     ; with supression of leading 1
     328/     C66 :                     ; exp =    0 -> accu is 0
     329/     C66 :                     ; exp =    0x81 ->    number is 0..1
     330/     C66 :                     fpaccu_mant32:  ds 2
     331/     C68 :                     fpaccu_mant54:  ds 2
     332/     C6A :                     fpaccu_mant6:   ds 1
     333/     C6B :                     fpaccu_exp:     ds 1
     334/     C6C :                     fpaccu_mantsign: ds 1                  ; FPaccu sign
     335/     C6D :                     
     336/     C6D :                     ; buf for conversion and formatting of numbers into decimal representation
     337/     C6D :                     numberbuf0:     ds 1                   ; unused, but HL is usually initialized when
     338/     C6E :                                                            ; pointing to number buf
     339/     C6E :                     numberbuf:      ds 19
     340/     C81 :                                     ds 6                   ; used as token buf
     341/     C87 :                     
     342/     C87 :                     rnd_mant23:     ds 2                   ; random init value
     343/     C89 :                     rnd_mant45:     ds 2
     344/     C8B :                     rndmant6_exp:   ds 2
     345/     C8D :                     
     346/     C8D :                     outputvector:   ds 1                   ; output vector, points to console or printer
     347/     C8E :                                                            ; filled with JP instruction
     348/     C8E :                     output_addr:    ds 2                   ; address of current output routine
     349/     C90 :                     
     350/     C90 :                     ; parameter table for CONSOLE (pointed to by IY)
     351/     C90 : (STRUCT)            conparam:       ioparams
     352/     C95 :                     ;		ds 1                   ; curpos
     353/     C95 :                     ;                ds 1                   ; linelength
     354/     C95 :                     ;                ds 1                   ; last_field
     355/     C95 :                     ;                ds 1                   ; padcount
     356/     C95 :                     ;                ds 1                   ; padchar
     357/     C95 :                     
     358/     C95 :                     ; parameter table for PRINTER output (pointed to by IY)
     359/     C95 : (STRUCT)            prtparam:       ioparams
     360/     C9A :                     ;		ds 1                   ; curpos
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 7 - 8/15/2019 11:33:6


     361/     C9A :                     ;                ds 1                   ; linelength
     362/     C9A :                     ;                ds 1                   ; last_field
     363/     C9A :                     ;                ds 1                   ; padcount
     364/     C9A :                     ;                ds 1                   ; padchar
     365/     C9A :                     curlineno:      ds 2                   ; temporary
     366/     C9C :                     auto_increment: ds 2                   ; lineno for autoincrement
     367/     C9E :                     
     368/     C9E :                     renum_size:     ds 1                   ; RENUMBER parameters
     369/     C9F :                     renum_incr:     ds 2
     370/     CA1 :                     renum_new:      ds 2
     371/     CA3 :                     
     372/     CA3 :                     trace_mode:     ds 1                   ; bit 7=1: LTRACE ON
     373/     CA4 :                                                            ; bit 6=1: TRACE ON
     374/     CA4 :                                                 
     375/     CA4 :                     coldvector:     ds 1                   ; filled with JP instruction
     376/     CA5 :                     cold_addr:      ds 2                   ; address of coldstart
     377/     CA7 :                     
     378/     CA7 :                     inputbuf_cnt:   ds 1                   ; cntr for line inputbuf
     379/     CA8 :                     
     380/     CA8 :                     pos_period:     ds 2                   ; used in number conversion
     381/     CAA :                     
     382/     CAA :                     fmt_flags:      ds 1                   ; flag for formatting number output
     383/     CAB :                                                            ; bit0 = add for digits for exponent (E+XX)
     384/     CAB :                                                            ; bit1 = unused?
     385/     CAB :                                                            ; bit2 = print SPACE for positive sign
     386/     CAB :                                                            ; bit3 = add leading '+' sign
     387/     CAB :                                                            ; bit4 = add leading '$'
     388/     CAB :                                                            ; bit5 = replace empty positions with '*'
     389/     CAB :                                                            ; bit6 = add commas each 3 digits
     390/     CAB :                                                            ; bit7 = percent format
     391/     CAB :                     prompt_flag:    ds 1                   ; =0 : direct mode
     392/     CAC :                                                            ; =1 : prompt auto lineno
     393/     CAC :                     renum_start:    ds 2                   ; used in RENUMBER
     394/     CAE :                     div_ovf:        ds 1                   ; flag division overflow
     395/     CAF :                     precision:      ds 1                   ; number PRECISION
     396/     CB0 :                     byte_1B0:       ds 1                   ; filled with comma
     397/     CB1 :                     inputbuf:       ds 14Fh                ; inputbuf for enter, edit, and convert input
     398/     E00 : =DFFH               memend		equ	$-1
     399/     E00 :                     
     400/     E00 :                     ; ------------------------------------------------------------------------------
     401/     E00 :                     
     402/     E00 :                     ; program code starts here
     403/     E00 :                     ;
     404/     E00 :                     ; Jump table, modify these to point to own routines
     405/     E00 :                     
     406/    8000 :                                     org 8000h
     407/    8000 : C3 B7 AC            COLDSTART0:     jp    coldstart
     408/    8003 : C3 73 81            WARMSTART0:     jp    recovered_msg
     409/    8006 : C3 F9 0F            math_usr:       jp    0ff9h
     410/    8009 :                     
     411/    8009 :                     ; wait for console character available, return in A
     412/    8009 : C3 E0 00            CONSOLEIN:      jp    0E0h
     413/    800C :                     
     414/    800C :                     ; read a character from paper tape reader, return in A, return C=1 if EOF
     415/    800C : C3 E3 00            READERIN:       jp    0E3h
     416/    800F :                     
     417/    800F :                     ; write a character in C to CONSOLE, no wait
     418/    800F : C3 E6 00            CONSOLEOUT:     jp    0E6h
     419/    8012 :                     
     420/    8012 :                     ; write a character in C to paper tape punch, no wait
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 8 - 8/15/2019 11:33:6


     421/    8012 : C3 E9 00            PUNCHOUT:       jp    0E9h
     422/    8015 :                     
     423/    8015 :                     ; write a character in C to printer, no wait
     424/    8015 : C3 EC 00            LISTOUT:        jp    0ECh
     425/    8018 :                     
     426/    8018 :                     ; check if a character is present from CONSOLE, A=0: no, A=FF: yes
     427/    8018 :                     ; char can be obtained with CONSOLEIN then
     428/    8018 : C3 EF 00            CONSOLESTAT:    jp    0EFh
     429/    801B :                     
     430/    801B :                     ; get IObyte of (Zapple) monitor in A
     431/    801B : C3 F2 00            IOCHECK:        jp    0F2h
     432/    801E :                     
     433/    801E :                     ; set IObyte of (Zapple) monitor in C
     434/    801E : C3 F5 00            IOSET:          jp    0F5h
     435/    8021 :                     
     436/    8021 :                     ; get memory size in BA (B=high, A=low)
     437/    8021 : C3 00 AE            MEMSIZE:        jp    sub_AE00
     438/    8024 :                     
     439/    8024 :                     ; return to monitor
     440/    8024 : C3 38 00            TRAP:           jp    38h
     441/    8027 :                     
     442/    8027 :                     ; helper functions for USR() programmer
     443/    8027 : C3 2D 87                            jp    fpaccu_to_16
     444/    802A : C3 1E 8F                            jp    AB_to_fpaccu
     445/    802D :                     
     446/    802D :                     ; BASIC function dispatch table
     447/    802D : A3 9F               func_tbl:       dw    math_sgn
     448/    802F : AD A0                               dw    math_int
     449/    8031 : CE 9F                               dw    math_abs
     450/    8033 : 06 80                               dw    math_usr         ; call USR vector
     451/    8035 : F6 8E                               dw    math_fre
     452/    8037 : D4 93                               dw    math_inp
     453/    8039 : 2F 8F                               dw    math_pos
     454/    803B : 0E A7                               dw    math_sqr
     455/    803D : 0E A8                               dw    math_rnd
     456/    803F : EB 9D                               dw    math_log
     457/    8041 : 64 A7                               dw    math_exp
     458/    8043 : 4A A8                               dw    math_cos
     459/    8045 : 50 A8                               dw    math_sin
     460/    8047 : D3 A8                               dw    math_tan
     461/    8049 : EA A8                               dw    math_atn
     462/    804B : 6A 9C                               dw    math_peek
     463/    804D : 99 92                               dw    math_len
     464/    804F : BA 90                               dw    math_strs
     465/    8051 : 2B 94                               dw    math_val
     466/    8053 : A8 92                               dw    math_asc
     467/    8055 : B6 92                               dw    math_chrs
     468/    8057 : C6 92                               dw    math_lefts
     469/    8059 : F6 92                               dw    math_rights
     470/    805B : FF 92                               dw    math_mids
     471/    805D : 2A 8F                               dw    math_lpos
     472/    805F : 2E 93                               dw    math_instr
     473/    8061 :                                     
     474/    8061 :                     ; operand dispatch table (first byte of each entry is precedence)
     475/    8061 : 79                  oper_tbl:       db    PREC_ADDSUB 
     476/    8062 : A7 A1                               dw    pop_fpreg_and_add
     477/    8064 : 79                                  db    PREC_ADDSUB
     478/    8065 : 8D 9C                               dw    pop_fpreg_and_sub
     479/    8067 : 7C                                  db    PREC_MULDIV
     480/    8068 : 3B 9E                               dw    pop_fpreg_and_mult
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 9 - 8/15/2019 11:33:6


     481/    806A : 7C                                  db    PREC_MULDIV
     482/    806B : BF 9E                               dw    pop_fpreg_and_div
     483/    806D : 7F                                  db    PREC_POWER
     484/    806E : 17 A7                               dw    pop_fpreg_and_power
     485/    8070 : 50                                  db    PREC_AND
     486/    8071 : BD 8C                               dw    pop_fpreg_and_booland
     487/    8073 : 46                                  db    PREC_OR
     488/    8074 : BC 8C                               dw    pop_fpreg_and_boolor
     489/    8076 :                     
     490/    8076 :                     ; basic cmd dispatch table                
     491/    8076 :                     token2_dispatch:
     492/    8076 : C3 86                               dw    exec_end
     493/    8078 : 6A 85                               dw    exec_for
     494/    807A : 3B 8B                               dw    exec_next
     495/    807C : 0B 88                               dw    exec_data
     496/    807E : 55 8A                               dw    exec_input
     497/    8080 : 65 8D                               dw    exec_dim
     498/    8082 : A6 8A                               dw    exec_read
     499/    8084 : 27 88                               dw    exec_let
     500/    8086 : C5 87                               dw    exec_goto
     501/    8088 : 1D 90                               dw    exec_fnend
     502/    808A : 23 89                               dw    exec_if
     503/    808C : 6A 86                               dw    exec_restore
     504/    808E : A8 87                               dw    exec_gosub
     505/    8090 : E6 87                               dw    exec_return
     506/    8092 : 0D 88                               dw    advance_to_eoln  ; REM statement
     507/    8094 : C1 86                               dw    exec_stop
     508/    8096 : DD 93                               dw    exec_out
     509/    8098 : 06 89                               dw    exec_on
     510/    809A : FC 86                               dw    exec_null
     511/    809C : E3 93                               dw    exec_wait
     512/    809E : 36 8F                               dw    exec_def
     513/    80A0 : 71 9C                               dw    exec_poke
     514/    80A2 : 5C 89                               dw    exec_print
     515/    80A4 : 5C 89                               dw    exec_print
     516/    80A6 : 55 8A                               dw    exec_input
     517/    80A8 : 72 87                               dw    exec_clear
     518/    80AA : 1D 90                               dw    exec_fnend       ; fnreturn
     519/    80AC : C5 94                               dw    exec_save
     520/    80AE : 0D 88                               dw    advance_to_eoln  ; ! statement
     521/    80B0 :                     
     522/    80B0 :                     ; special BASIC token dispatch table
     523/    80B0 :                     token1_dispatch:
     524/    80B0 : 0D 88                               dw    advance_to_eoln ; ELSE
     525/    80B2 : 59 89                               dw    exec_lprint
     526/    80B4 : DB 97                               dw    exec_trace
     527/    80B6 : D8 97                               dw    exec_ltrace
     528/    80B8 : 84 99                               dw    exec_randomize
     529/    80BA : 46 94                               dw exec_switch
     530/    80BC : 62 94                               dw exec_lwidth
     531/    80BE : F9 86                               dw exec_lnull
     532/    80C0 : 65 94                               dw exec_width
     533/    80C2 : 9E 99                               dw exec_lvar
     534/    80C4 : 9B 99                               dw exec_llvar
     535/    80C6 : 5C 89                               dw exec_print
     536/    80C8 : 6D 81                               dw syntax_error        ; tic alternative REM, not processed here
     537/    80CA : 59 9C                               dw exec_precision
     538/    80CC : 26 9C                               dw exec_call
     539/    80CE : F9 9B                               dw exec_kill
     540/    80D0 : B6 9B                               dw exec_exchange
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 10 - 8/15/2019 11:33:6


     541/    80D2 : 4F 8A                               dw exec_lineinput
     542/    80D4 : B0 9A                               dw exec_loadgo
     543/    80D6 : 9D 87                               dw exec_run
     544/    80D8 : FE 94                               dw exec_load
     545/    80DA : B3 82                               dw exec_new
     546/    80DC : 24 8A                               dw exec_auto
     547/    80DE : F2 9A                               dw exec_copy
     548/    80E0 : 6B 9A                               dw exec_aloadc
     549/    80E2 : 6E 9A                               dw exec_amergec
     550/    80E4 : F2 99                               dw exec_aload
     551/    80E6 : F5 99                               dw exec_amerge
     552/    80E8 : 41 95                               dw exec_asave
     553/    80EA : EF 84                               dw exec_list
     554/    80EC : EC 84                               dw exec_llist
     555/    80EE : B3 95                               dw exec_renumber
     556/    80F0 : A3 97                               dw exec_delete
     557/    80F2 : FE 97                               dw exec_edit
     558/    80F4 : E7 86                               dw exec_cont
     559/    80F6 :                                     
     560/    80F6 :                     ; discard the last pending FOR loops
     561/    80F6 :                     ; DE = FFxx -> discard all open levels,
     562/    80F6 :                     ;         point to first non-FOR loop level
     563/    80F6 :                     ; DE = 00 -> point to last open level
     564/    80F6 :                     ; DE = var ptr -> discard all open levels
     565/    80F6 :                     ;         and point to correct level
     566/    80F6 :                     ;
     567/    80F6 :                     ; Note: the stack is used for storing various structures,
     568/    80F6 :                     ; such as FOR loop, GOSUB, and expressions
     569/    80F6 :                     ; each structure has a marker at the end which
     570/    80F6 :                     ; is usually the originating token.
     571/    80F6 :                     ; the marker is two levels above (stack mark and process
     572/    80F6 :                     ; routine of BASIC command)
     573/    80F6 :                     discard_open_forloops:
     574/    80F6 : 21 04 00                            ld    hl, 4            ; skip over 2 levels of calls
     575/    80F9 : 39                                  add   hl, sp
     576/    80FA : 01 11 00                            ld    bc, 11h
     577/    80FD : 7E                  loop3FD:        ld    a, (hl)          ;<+ get stack marker
     578/    80FE : 23                                  inc   hl               ; | advance
     579/    80FF : FE 81                               cp    TOKEN_FOR        ; | is it FOR token?
     580/    8101 : C0                                  ret   nz               ; | no, return
     581/    8102 :                                                            ; |
     582/    8102 :                     ; discard pending for loops              |
     583/    8102 : 7E                                  ld    a, (hl)          ; | get next byte of FOR structure
     584/    8103 : 23                                  inc   hl               ; | advance
     585/    8104 : E5                                  push  hl               ; | save it
     586/    8105 : 66                                  ld    h, (hl)          ; | get next byte of FOR structure
     587/    8106 : 6F                                  ld    l, a             ; | pack pair into HL
     588/    8107 : 7A                                  ld    a, d             ; | get variable to match
     589/    8108 : B3                                  or    e                ; |
     590/    8109 : EB                                  ex    de, hl           ; | save variable name
     591/    810A : 28 07                               jr    z, loc_413       ; | variable zero? NEXT without variable name
     592/    810C :                                                            ; | matches unconditionally
     593/    810C : EB                                  ex    de, hl           ; | restore variable
     594/    810D : (MACRO)                             CPHL_DE                ; | compare with FOR variable name
     594/    810D : 7C                                  ld    a, h
     594/    810E : 92                                  sub   d
     594/    810F : 20 02                               jr    nz, m1
     594/    8111 : 7D                                  ld    a, l
     594/    8112 : 93                                  sub   e
     594/    8113 :                     m1:
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 11 - 8/15/2019 11:33:6


     595/    8113 : E1                  loc_413:        pop   hl               ; | reload ptr into FOR structure
     596/    8114 : 23                                  inc   hl               ; | point to payload after variable name
     597/    8115 : C8                                  ret   z                ; | return if correct level found
     598/    8116 : 09                                  add   hl, bc           ; | skip over payload
     599/    8117 : 18 E4                               jr    loop3FD          ;-+ loop
     600/    8119 :                     
     601/    8119 :                     ; HL = new end address
     602/    8119 :                     ; BC = old end address
     603/    8119 :                     ; DE = start address
     604/    8119 : CD 3E 81            make_space:     call  check_memfree    ; validate enough space available
     605/    811C : C5                                  push  bc
     606/    811D : E3                                  ex    (sp), hl         ; swap oldend and newend
     607/    811E : C1                                  pop   bc               ; BC is newend
     608/    811F : B7                  loc_41F:        or    a                ; clear CY
     609/    8120 : E5                                  push  hl               ; save oldend
     610/    8121 : ED 52                               sbc   hl, de           ; calculate bytes to move
     611/    8123 : C5                                  push  bc
     612/    8124 : E3                                  ex    (sp), hl         ; swap newend and bytes to move
     613/    8125 : C1                                  pop   bc               ; BC is move count, HL is newend
     614/    8126 : EB                                  ex    de, hl           ; DE is newend, HL is start
     615/    8127 : E3                                  ex    (sp), hl         ; stack is start, HL is oldend
     616/    8128 : 03                                  inc   bc               ; one more byte to move
     617/    8129 : ED B8                               lddr                   ; move data
     618/    812B : 23                                  inc   hl               ; HL points to end of freed space
     619/    812C : 13                                  inc   de               ; DE points to start of space
     620/    812D : 42                                  ld    b, d             ; move DE -> BC
     621/    812E : 4B                                  ld    c, e
     622/    812F : D1                                  pop   de               ; DE is start of free space
     623/    8130 : C9                                  ret
     624/    8131 :                     
     625/    8131 :                     ; verify that 2*C bytes are still free in memory
     626/    8131 : E5                  verify_space:   push  hl               ; save HL
     627/    8132 : 2A 62 0C                            ld    hl, (end_arrays) ; get start of free space
     628/    8135 : 06 00                               ld    b, 0             ; make C 16bit
     629/    8137 : 09                                  add   hl, bc           ; add to free space
     630/    8138 : 09                                  add   hl, bc           ; add to free space
     631/    8139 : CD 3E 81                            call  check_memfree    ; check if not overlapping with string space
     632/    813C : E1                                  pop   hl
     633/    813D : C9                                  ret
     634/    813E :                     
     635/    813E : D5                  check_memfree:  push  de               ; save DE
     636/    813F : EB                                  ex    de, hl           ; save HL
     637/    8140 : 21 D8 FF                            ld    hl, -40          ; subtract 40 from stack
     638/    8143 : 39                                  add   hl, sp
     639/    8144 : (MACRO)                             CPHL_DE                ; subtract memory base
     639/    8144 : 7C                                  ld    a, h
     639/    8145 : 92                                  sub   d
     639/    8146 : 20 02                               jr    nz, m1
     639/    8148 : 7D                                  ld    a, l
     639/    8149 : 93                                  sub   e
     639/    814A :                     m1:
     640/    814A : EB                                  ex    de, hl
     641/    814B : D1                                  pop   de
     642/    814C : D0                                  ret   nc               ; enough space free
     643/    814D :                     out_of_memory_error:
     644/    814D : 1E 07                               ld    e, 7
     645/    814F : 18 2D                               jr    print_error
     646/    8151 :                     
     647/    8151 :                     ; expect the char in A in the inputbuf, otherwise error
     648/    8151 : BE                  expect_char:    cp    (hl)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 12 - 8/15/2019 11:33:6


     649/    8152 : CA 47 86                            jp    z, nextchar
     650/    8155 : 18 16                               jr    syntax_error
     651/    8157 :                     
     652/    8157 : 3A 4F 0C            invalid_input:  ld    a, (input_read_flag) ; get input/read flag
     653/    815A : B7                                  or    a
     654/    815B : 20 0A                               jr    nz, loc_467      ; in READ?
     655/    815D : C1                                  pop   bc               ; no, drop curlineptr
     656/    815E : 21 84 AC                            ld    hl, a_invalid_input ; message "*invalid input"
     657/    8161 : CD BD 84                            call  print_string     ; error
     658/    8164 : C3 F4 82                            jp    loc_5F4          ; restore curlineptr and exit
     659/    8167 : 2A 4C 0C            loc_467:        ld    hl, (currentlineno) ; copy lineno into error lineno
     660/    816A : 22 54 0C                            ld    (lineno), hl     ; otherwise (in READ), 
     661/    816D :                                                            ; notify a syntax error in data line
     662/    816D :                     
     663/    816D :                     ; error print routines
     664/    816D :                     syntax_error:
     665/    816D : 1E 02                               ld    e, 2
     666/    816F : 01                                  db    1                ; LD BC, xxxx to skip over next code
     667/    8170 :                     div_by_zero_error:
     668/    8170 : 1E 0B                               ld    e, 11
     669/    8172 : 01                                  db    1                ; LD BC, xxxx to skip over next code
     670/    8173 : 1E 16               recovered_msg:  ld    e, 22
     671/    8175 : 01                                  db    1                ; LD BC, xxxx to skip over next code
     672/    8176 :                     redim_array_error:
     673/    8176 : 1E 0A                               ld    e, 10
     674/    8178 : 01                                  db    1                ; LD BC, xxxx to skip over next code
     675/    8179 : 1E 12               usercall_error: ld    e, 18
     676/    817B : 01                                  db    1                ; LD BC, xxxx to skip over next code
     677/    817C :                     next_wo_for_error:
     678/    817C : 1E 01                               ld    e, 1
     679/    817E :                     
     680/    817E :                     ; print an error message in E
     681/    817E : CD DB 82            print_error:    call  reset_stack_warm ; correct stack ptr
     682/    8181 : CD F8 82                            call  enable_output    ; enable output again, if it was suppressed
     683/    8184 : CD EE 89                            call  print_crlf       ; do a CRLF
     684/    8187 : 21 12 AB                            ld    hl, e_next_wo_for ; load start of error table
     685/    818A : 1D                  loop48A:        dec   e                ;<--+ decrement error number
     686/    818B : 28 07                               jr    z, loc_494       ;   | if zero, found
     687/    818D : CB 7E               loop48D:        bit   7, (hl)          ;<+ | test high bit
     688/    818F : 23                                  inc   hl               ; | | advance ptr
     689/    8190 : 28 FB                               jr    z, loop48D       ;-+ | loop to end of string
     690/    8192 : 18 F6                               jr    loop48A          ;---+ loop until error string found
     691/    8194 : CD BD 84            loc_494:        call  print_string     ; emit the message string
     692/    8197 : 2A 54 0C                            ld    hl, (lineno)     ; get lineno
     693/    819A : (MACRO)                             TEST_FFFF              ;  check if != ffff
     693/    819A : 7C                                  ld    a, h
     693/    819B : A5                                  and   l
     693/    819C : 3C                                  inc   a                ; is valid (!= ffff)
     694/    819D : C4 C1 A1                            call  nz, print_at_lineno ; is valid, print " @ line "
     695/    81A0 :                                                            ; if line is printed: A    != 0
     696/    81A0 :                     
     697/    81A0 :                     ; enters here to print ready prompt
     698/    81A0 :                     ; according to flag in A (print if A=0)
     699/    81A0 :                     print_prompt:
     700/    81A0 : CD F8 82                            call  enable_output    ; enable output if it was suppressed
     701/    81A3 : 32 AB 0C                            ld    (prompt_flag), a ; A is 0, clear prompt flag
     702/    81A6 : CD DB 89                            call  print_ready_prompt ; print "READY"
     703/    81A9 : 21 FF FF            loop4A9:        ld    hl, 0FFFFh       ;<+ reset lineno
     704/    81AC : 22 54 0C                            ld    (lineno), hl     ; | 
     705/    81AF : 3A AB 0C                            ld    a, (prompt_flag) ; | prompting?
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 13 - 8/15/2019 11:33:6


     706/    81B2 : B7                                  or    a                ; | 
     707/    81B3 : 28 25                               jr    z, loc_4DA       ; | no, go to direct mode
     708/    81B5 : 2A 9A 0C                            ld    hl, (curlineno)  ; | get current lineno
     709/    81B8 : FA D5 9A                            jp    m, sub_1DD5      ; | prompt flag=FF?, yes coming from aload/amerge
     710/    81BB : ED 5B 9C 0C                         ld    de, (auto_increment) ; in auto mode, get increment
     711/    81BF : 19                                  add   hl, de           ; | make new lineno
     712/    81C0 : DA 6B 8E                            jp    c, subscript_range_error ; too large, error
     713/    81C3 :                                                            ; |
     714/    81C3 :                     ; do auto mode                           | 
     715/    81C3 : 22 9A 0C            auto:           ld    (curlineno), hl  ; | store as new lineno
     716/    81C6 : E5                                  push  hl               ; | save it
     717/    81C7 : CD C9 A1                            call  print_HL         ; | print lineno
     718/    81CA : CD 64 84                            call  print_space      ; | print a space
     719/    81CD : CD 07 84                            call  get_inputline    ; | process a whole input line
     720/    81D0 : CD 47 86                            call  nextchar         ; | get next char
     721/    81D3 : D1                                  pop   de               ; | restore auto lineno
     722/    81D4 : B7                                  or    a                ; | line was empty?
     723/    81D5 : 28 C9                               jr    z, print_prompt  ; | yes, continue with next line
     724/    81D7 : 37                                  scf                    ; | set flag C=1: digit seen
     725/    81D8 : 18 0A                               jr    loc_4E4          ; | process line, assuming a lineno
     726/    81DA :                                                            ; | has been already found
     727/    81DA : CD 07 84            loc_4DA:        call  get_inputline    ; | get a line
     728/    81DD : CD 47 86                            call  nextchar         ; | read char
     729/    81E0 : 3C                                  inc   a                ; | set flags
     730/    81E1 : 3D                                  dec   a                ; |
     731/    81E2 : 28 C5                               jr    z, loop4A9       ;-+ empty line, loop
     732/    81E4 : F5                  loc_4E4:        push  af               ; save char and C flag (C=1: digit seen)
     733/    81E5 : FE 03                               cp    CHAR_CTRLC       ; is it CTRL-C?
     734/    81E7 : CA 90 86                            jp    z, has_break     ; yes, skip
     735/    81EA : D9                                  exx                    ; save all regs
     736/    81EB : 21 AB 0C                            ld    hl, prompt_flag  ; check prompt flag
     737/    81EE : 34                                  inc   (hl)
     738/    81EF : 35                                  dec   (hl)
     739/    81F0 : D9                                  exx                    ; restore all regs
     740/    81F1 :                     loc_4F1:                               ; is in direct mode? try finding a lineno
     741/    81F1 : CC 49 87                            call  z, parse_lineno  ; DE contains lineno or 0
     742/    81F4 :                                                            ; otherwise: DE contains the AUTO lineno
     743/    81F4 : FE 20                               cp    CHAR_SPACE       ; is char space?
     744/    81F6 : 20 01                               jr    nz, loc_4F9      ; no, regular char
     745/    81F8 : 23                                  inc   hl               ; advance to next (a space after a lineno)
     746/    81F9 : D5                  loc_4F9:        push  de               ; save potential lineno
     747/    81FA : CD 09 83                            call  tokenize_line    ; compress line by tokenizing it
     748/    81FD : 47                                  ld    b, a             ; B = 0 (A returned with 0)
     749/    81FE : D1                                  pop   de               ; restore lineno
     750/    81FF : F1                                  pop   af               ; restore char read
     751/    8200 : D2 14 86                            jp    nc, execute_command ; was not a number?
     752/    8203 :                     
     753/    8203 :                     ; a line starting with a statement number was entered
     754/    8203 : D5                                  push  de               ; save potential lineno
     755/    8204 : C5                                  push  bc               ; length of line in C, B is 0
     756/    8205 : 23                  loop505:        inc   hl               ;<+ get first char of line
     757/    8206 : 7E                                  ld    a, (hl)          ; | 
     758/    8207 : B7                                  or    a                ; | is zero?
     759/    8208 : 28 0C                               jr    z, loc_516       ; | flush buf to memory
     760/    820A : FE 20                               cp    CHAR_SPACE       ; | is space?
     761/    820C : 28 F7                               jr    z, loop505       ;>+ yes ignore and loop
     762/    820E : FE 09                               cp    CHAR_TAB         ; | is tab?
     763/    8210 : 28 F3                               jr    z, loop505       ;>+ yes ignore and loop
     764/    8212 : FE 0A                               cp    CHAR_LF          ; | is LF?
     765/    8214 : 28 EF                               jr    z, loop505       ;-+ yes ignore and loop
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 14 - 8/15/2019 11:33:6


     766/    8216 : F5                  loc_516:        push  af               ; save char seen for future
     767/    8217 : CD 92 82                            call  find_line        ; find the line in program memory
     768/    821A : C5                                  push  bc               ; save previous link
     769/    821B : 30 14                               jr    nc, loc_531      ; must be inserted before
     770/    821D :                     ; must replace line
     771/    821D : EB                                  ex    de, hl           ; save nextlink in DE
     772/    821E : 2A 5E 0C                            ld    hl, (prog_end)   ; get end of program
     773/    8221 : 1A                  loop521:        ld    a, (de)          ;<+ get data from nextlink
     774/    8222 : 02                                  ld    (bc), a          ; | copy into previous
     775/    8223 : 03                                  inc   bc               ; | advance
     776/    8224 : 13                                  inc   de               ; | 
     777/    8225 : (MACRO)                             CPHL_DE                ; | end of program reached?
     777/    8225 : 7C                                  ld    a, h
     777/    8226 : 92                                  sub   d
     777/    8227 : 20 02                               jr    nz, m1
     777/    8229 : 7D                                  ld    a, l
     777/    822A : 93                                  sub   e
     777/    822B :                     m1:
     778/    822B : 20 F4                               jr    nz, loop521      ;-+ no loop (delete the matching line)
     779/    822D : ED 43 5E 0C                         ld    (prog_end), bc   ; save new end of program
     780/    8231 : D1                  loc_531:        pop   de               ; restore previous link in DE
     781/    8232 : F1                                  pop   af               ; restore char
     782/    8233 : 28 21                               jr    z, rebuild_nextchain ; was zero? yes, we just had to 
     783/    8235 :                     				                       ; delete the line
     784/    8235 : ED 4B 5E 0C                         ld    bc, (prog_end)   ; get end of program
     785/    8239 : E1                                  pop   hl               ; get line length to insert
     786/    823A : 09                                  add   hl, bc           ; add to end of program
     787/    823B : E5                                  push  hl               ; save new end
     788/    823C : CD 19 81                            call  make_space       ; shift program up to make a space for line
     789/    823F : E1                                  pop   hl               ; save new end of program
     790/    8240 : 22 5E 0C                            ld    (prog_end), hl
     791/    8243 : EB                                  ex    de, hl           ; get link to new line in HL
     792/    8244 : 74                                  ld    (hl), h          ; ensure that line link is not zero
     793/    8245 : 23                                  inc   hl               ; advance to lineno position
     794/    8246 : 23                                  inc   hl
     795/    8247 : D1                                  pop   de               ; restore lineno
     796/    8248 : (MACRO)                             LDM_DE                 ; save it into new line
     796/    8248 : 73                                  ld    (hl), e
     796/    8249 : 23                                  inc   hl
     796/    824A : 72                                  ld    (hl), d
     797/    824B : 23                                  inc   hl
     798/    824C : 11 B1 0C                            ld    de, inputbuf     ; get inputbuf
     799/    824F : 1A                  loop54F:        ld    a, (de)          ;<+ move line into program space
     800/    8250 : 77                                  ld    (hl), a          ; | 
     801/    8251 : 23                                  inc   hl               ; | 
     802/    8252 : 13                                  inc   de               ; | 
     803/    8253 : B7                                  or    a                ; | until line terminator seen
     804/    8254 : 20 F9                               jr    nz, loop54F      ;-+
     805/    8256 :                     rebuild_nextchain:                     
     806/    8256 : CD C2 82                            call  init_from_start  ; clear variables
     807/    8259 : 23                                  inc   hl               ; HL points to start of program now
     808/    825A : EB                                  ex    de, hl           ; into DE
     809/    825B : 21 A9 81                            ld    hl, loop4A9      ; set new return address
     810/    825E : E5                                  push  hl
     811/    825F :                     rebuild_nextchain1:                    ;<--+
     812/    825F : (MACRO)                             LDHL_DE                ;   | DE is ptr to nextlink, copy into HL
     812/    825F : 62                                  ld    h, d
     812/    8260 : 6B                                  ld    l, e
     813/    8261 : 7E                                  ld    a, (hl)          ;   | get current nextlink
     814/    8262 : 23                                  inc   hl               ;   | 
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 15 - 8/15/2019 11:33:6


     815/    8263 : B6                                  or    (hl)             ;   | 
     816/    8264 : C8                                  ret   z                ;   | return if zero -> finished with
     817/    8265 :                     				                       ;   | adjustment of program
     818/    8265 : 23                                  inc   hl               ;   | advance beyond lineno
     819/    8266 : 23                                  inc   hl               ;   | 
     820/    8267 : 23                                  inc   hl               ;   | 
     821/    8268 : AF                                  xor   a                ;   | clear A
     822/    8269 : BE                  loop569:        cp    (hl)             ;<+ | find the line terminator
     823/    826A : 23                                  inc   hl               ; | | advance
     824/    826B : 20 FC                               jr    nz, loop569      ;-+ | loop until found
     825/    826D : EB                                  ex    de, hl           ;   | HL = previous nextlink, DE = start of next line
     826/    826E : (MACRO)                             LDM_DE                 ;   | save line position into previous nextlink
     826/    826E : 73                                  ld    (hl), e
     826/    826F : 23                                  inc   hl
     826/    8270 : 72                                  ld    (hl), d
     827/    8271 : 18 EC                               jr    rebuild_nextchain1 ;-+ loop until end of program
     828/    8273 :                     
     829/    8273 :                     ; get a range of linenos
     830/    8273 :                     ; find the first line, set HL, BC as in find_line
     831/    8273 :                     ; end of range is on stack when returning
     832/    8273 :                     get_lineno_range:
     833/    8273 : 11 00 00                            ld    de, 0            ; preload starting lineno
     834/    8276 : D5                                  push  de
     835/    8277 : 28 0C                               jr    z, loc_585       ; no more arguments, set 0-65535
     836/    8279 : D1                                  pop   de               ; discard start value
     837/    827A : CD 85 86                            call  read_lineno      ; read a lineno in DE
     838/    827D : D5                                  push  de               ; save it for later
     839/    827E : 28 0E                               jr    z, loc_58E       ; end of command, only delete a single line
     840/    8280 : (MACRO)                             EXPECT TOKEN_MINUS     ; otherweise expect token '-'
     840/    8280 : 3E A6                               ld    a, TOKEN_MINUS
     840/    8282 : CD 51 81                            call  expect_char
     841/    8285 : 11 FF FF            loc_585:        ld    de, 0FFFFh       ; preload 65535 as end of range
     842/    8288 : C4 85 86                            call  nz, read_lineno  ; if not end of line yet, get the end of range
     843/    828B : C2 6D 81                            jp    nz, syntax_error ; error, if more characters follow
     844/    828E : EB                  loc_58E:        ex    de, hl           ; HL is end of range
     845/    828F : D1                                  pop   de               ; DE is start lineno range
     846/    8290 : E3                                  ex    (sp), hl         ; insert it on stack
     847/    8291 : E5                                  push  hl               ; push old return address
     848/    8292 :                     
     849/    8292 :                     ; DE is lineno to search
     850/    8292 :                     ; return address of nextlink of HL
     851/    8292 :                     ; return nextlink of previous line in BC
     852/    8292 :                     ; Z=1 if line matched or nextlink=0
     853/    8292 :                     ; C=0 if line has to be    inserted here
     854/    8292 : 2A 5C 0C            find_line:      ld    hl, (start_memory) ; load start of program
     855/    8295 :                     find_line_from_current: 
     856/    8295 : (MACRO)                             LDBC_HL                ; ptr to nextlink: copy into BC
     856/    8295 : 44                                  ld    b, h
     856/    8296 : 4D                                  ld    c, l
     857/    8297 : 7E                                  ld    a, (hl)          ; check link
     858/    8298 : 23                                  inc   hl
     859/    8299 : B6                                  or    (hl)             ; was it 0000?
     860/    829A : 2B                                  dec   hl               ; HL points to nextlink 0000 (end of program)
     861/    829B : C8                                  ret   z                ; yes, exit
     862/    829C : 23                                  inc   hl               ; skip over nextlink
     863/    829D : 23                                  inc   hl
     864/    829E : (MACRO)                             LDHL_M A               ; read lineno into HL
     864/    829E : 7E                                  ld    A, (hl)
     864/    829F : 23                                  inc   hl
     864/    82A0 : 66                                  ld    h, (hl)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 16 - 8/15/2019 11:33:6


     864/    82A1 : 6F                                  ld    l, A
     865/    82A2 : ED 52                               sbc   hl, de           ; compare with lineno to be entered in DE
     866/    82A4 : (MACRO)                             LDHL_BC                ; restore nextlink
     866/    82A4 : 60                                  ld    h, b
     866/    82A5 : 69                                  ld    l, c
     867/    82A6 : (MACRO)                             LDHL_M A               ; read nextlink into HL
     867/    82A6 : 7E                                  ld    A, (hl)
     867/    82A7 : 23                                  inc   hl
     867/    82A8 : 66                                  ld    h, (hl)
     867/    82A9 : 6F                                  ld    l, A
     868/    82AA : 3F                                  ccf
     869/    82AB : C8                                  ret   z                ; matched line exactly
     870/    82AC :                                                            ; return nextlink of this line
     871/    82AC : 3F                                  ccf
     872/    82AD : D0                                  ret   nc               ; must insert before this line
     873/    82AE : D9                                  exx                    ; fragment of exec_copy:
     874/    82AF :                                                            ; increment cntr of lines to copy
     875/    82AF : 19                                  add   hl, de
     876/    82B0 : D9                                  exx
     877/    82B1 : 18 E2                               jr    find_line_from_current ; loop through program
     878/    82B3 :                     ; process NEW command
     879/    82B3 : C0                  exec_new:       ret   nz               ; return if arguments follow
     880/    82B4 :                     
     881/    82B4 : 2A 5C 0C            new_memory:     ld    hl, (start_memory) ; get lowest memory
     882/    82B7 : AF                                  xor   a                ; clear A
     883/    82B8 : 32 A3 0C                            ld    (trace_mode), a  ; clear flag
     884/    82BB : 77                                  ld    (hl), a          ; clear first memory cells
     885/    82BC : 23                                  inc   hl
     886/    82BD : 77                                  ld    (hl), a
     887/    82BE : 23                                  inc   hl
     888/    82BF : 22 5E 0C                            ld    (prog_end), hl   ; save endofbasic
     889/    82C2 :                     
     890/    82C2 :                     ; initialize program ptrs, clear variables
     891/    82C2 :                     init_from_start:
     892/    82C2 : 2A 5C 0C                            ld    hl, (start_memory)
     893/    82C5 : 2B                                  dec   hl               ; point to start of memory - 1
     894/    82C6 :                     
     895/    82C6 :                     ; initialize from current position
     896/    82C6 :                     init_from_current:
     897/    82C6 : 22 50 0C                            ld    (curlineptr), hl ; save it
     898/    82C9 : 2A 04 0C                            ld    hl, (memory_top) ; copy top ptr
     899/    82CC : 22 48 0C                            ld    (string_top), hl
     900/    82CF : CD 7B 86                            call  reset_dataptr    ; set program ptr
     901/    82D2 : 2A 5E 0C                            ld    hl, (prog_end)   ; end of program text
     902/    82D5 : 22 60 0C                            ld    (end_of_vars), hl ; start of vars
     903/    82D8 : 22 62 0C                            ld    (end_arrays), hl ; end of variables
     904/    82DB :                     
     905/    82DB :                     reset_stack_warm:
     906/    82DB : C1                                  pop   bc               ; get return address
     907/    82DC : ED 7B 5A 0C                         ld    sp, (string_base) ; reset stack
     908/    82E0 : 21 08 0C                            ld    hl, stringstk    ; HL is  ptr to exprstack
     909/    82E3 : 22 06 0C                            ld    (stringstkptr), hl ; save ptr
     910/    82E6 : AF                                  xor   a                ; clear A
     911/    82E7 : 67                                  ld    h, a
     912/    82E8 : 6F                                  ld    l, a
     913/    82E9 : 22 58 0C                            ld    (contlineptr), hl ; clear CONT ptr
     914/    82EC : 32 4E 0C                            ld    (subscript_flag), a ; clear subscript flag
     915/    82EF : 32 A7 0C                            ld    (inputbuf_cnt), a ; clear cntr of input chars
     916/    82F2 : E5                                  push  hl               ; push zero into stacktop
     917/    82F3 :                                                            ;  = fallback to reset vector = WARMSTART
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 17 - 8/15/2019 11:33:6


     918/    82F3 : C5                                  push  bc               ; push return address
     919/    82F4 : 2A 50 0C            loc_5F4:        ld    hl, (curlineptr) ; load ptr to current line
     920/    82F7 : C9                                  ret
     921/    82F8 :                     
     922/    82F8 :                     ; clear IOSUPPRESS flag, enabling output again
     923/    82F8 :                     enable_output:
     924/    82F8 : AF                                  xor   a
     925/    82F9 : 32 00 0C                            ld    (iosuppress), a  ; clear IOSUPPRESS flag
     926/    82FC :                     
     927/    82FC :                     ; select console for output
     928/    82FC :                     select_console:
     929/    82FC : FD 21 0F 80                         ld    iy, CONSOLEOUT   ; get address of CONSOLEOUT routine
     930/    8300 : FD 22 8E 0C                         ld    (output_addr), iy ; put into output vector
     931/    8304 : FD 21 90 0C                         ld    iy, conparam     ; load console parameter set
     932/    8308 : C9                                  ret
     933/    8309 :                     
     934/    8309 : AF                  tokenize_line:  xor   a                ; clear A
     935/    830A : 32 03 0C                            ld    (byte_103), a
     936/    830D : 0E 05                               ld    c, 5             ; load cntr
     937/    830F : 11 B1 0C                            ld    de, inputbuf     ; inputbuf, used to compact the inputbuf
     938/    8312 :                                                            ; by replacing keywords with tokens
     939/    8312 : 7E                  loop612:        ld    a, (hl)          ; get char
     940/    8313 : 47                                  ld    b, a             ; into B (remember start of string)
     941/    8314 : B7                                  or    a                ; end of buf?
     942/    8315 : CA AD 83                            jp    z, loc_6AD       ; yes exit
     943/    8318 : FE 21                               cp    CHAR_EXCL
     944/    831A : 38 4F                               jr    c, loc_66B       ; less than "!" ?, skip
     945/    831C : FE 22                               cp    CHAR_QUOTE       ; is it " ?
     946/    831E : 28 7B                               jr    z, loc_69B       ; yes, skip
     947/    8320 : 3A 03 0C                            ld    a, (byte_103)    ; get flag
     948/    8323 : B7                                  or    a                ; is set?
     949/    8324 : 47                                  ld    b, a             ; save in B
     950/    8325 : 7E                                  ld    a, (hl)          ; get char
     951/    8326 : 20 43                               jr    nz, loc_66B      ; flag is set, accumulate mode
     952/    8328 : FE 30                               cp    CHAR_ZERO        ; is char >= '0'?
     953/    832A : 38 04                               jr    c, loc_630       ; no, continue
     954/    832C : FE 3A                               cp    CHAR_NINE+1      ; is it <= '9'?
     955/    832E : 38 3B                               jr    c, loc_66B       ; yes, accumulate
     956/    8330 : D5                  loc_630:        push  de               ; save DE
     957/    8331 : 11 63 A9                            ld    de, token_tbl    ; start of token table
     958/    8334 : E5                                  push  hl               ; ptr to potential keyword
     959/    8335 : 18 02                               jr    loop639          ; process token table
     960/    8337 : 23                  loop637:        inc   hl               ;<--+ next char in keyword
     961/    8338 : 13                                  inc   de               ;   | next char in token tbl
     962/    8339 : 1A                  loop639:        ld    a, (de)          ;<----+ get char from token table
     963/    833A : B7                                  or    a                ;   | | end of table?
     964/    833B : 28 25                               jr    z, loc_662       ;   | | yes, exit
     965/    833D : FE 20                               cp    CHAR_SPACE       ;   | | is it a space?
     966/    833F : 20 09                               jr    nz, loc_64A      ;   | | no, skip
     967/    8341 : 13                                  inc   de               ;   | | skip space
     968/    8342 : 7E                  loop642:        ld    a, (hl)          ;<+ | | char from input line
     969/    8343 : FE 20                               cp    CHAR_SPACE       ; | | | is it a space?
     970/    8345 : 20 03                               jr    nz, loc_64A      ; | | | no skip
     971/    8347 : 23                                  inc   hl               ; | | | ignore space
     972/    8348 : 18 F8                               jr    loop642          ;-+ | | and get next char
     973/    834A : EB                  loc_64A:        ex    de, hl           ;   | | token table in HL, buf in DE
     974/    834B : 1A                                  ld    a, (de)          ;   | | get buf char
     975/    834C : FE 60                               cp    60h              ;   | | alphabetic?
     976/    834E : 38 02                               jr    c, loc_652       ;   | | no, skip
     977/    8350 : E6 5F                               and   5Fh              ;   | | make upper case
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 18 - 8/15/2019 11:33:6


     978/    8352 : AE                  loc_652:        xor   (hl)             ;   | | compare with token table
     979/    8353 : E6 7F                               and   MASK_7BIT        ;   | | mask 7 bits only
     980/    8355 : EB                                  ex    de, hl           ;   | | buf in HL, token table in DE
     981/    8356 : 20 49                               jr    nz, loc_6A1      ;   | | did not match
     982/    8358 : 1A                                  ld    a, (de)          ;   | | get char from token table
     983/    8359 : 17                                  rla                    ;   | |  
     984/    835A : 30 DB                               jr    nc, loop637      ;---+ | not yet end of token? loop
     985/    835C : F1                                  pop   af               ;     | we have a match, discard HL
     986/    835D : 78                                  ld    a, b             ;     | get token count
     987/    835E : F6 80                               or    80h              ;     | mark as token
     988/    8360 : 18 08                               jr    loc_66A          ;     | token  value in A
     989/    8362 : E1                  loc_662:        pop   hl               ;     | end of table reached, restore ptr to keyword
     990/    8363 : 7E                                  ld    a, (hl)          ;     | get char
     991/    8364 : FE 60                               cp    60h              ;     | > 0x60
     992/    8366 : 38 02                               jr    c, loc_66A       ;     | no skip
     993/    8368 : E6 5F                               and   5Fh              ;     | make upper case
     994/    836A : D1                  loc_66A:        pop   de               ;     | restore bufptr
     995/    836B : EB                  loc_66B:        ex    de, hl           ;     | get target buf
     996/    836C : FE C9                               cp    TOKEN_ELSE       ;     | is it token ELSE?
     997/    836E : 36 3A                               ld    (hl), CHAR_COLON ;     | put colon in buf
     998/    8370 : 20 02                               jr    nz, loc_674      ;     | no, skip
     999/    8372 : 0C                                  inc   c                ;     | yes, advance
    1000/    8373 : 23                                  inc   hl               ;     | 
    1001/    8374 : EB                  loc_674:        ex    de, hl           ;     | restore target buf in DE
    1002/    8375 : 23                                  inc   hl               ;     | advance to next char
    1003/    8376 : 12                                  ld    (de), a          ;     | accumulate char in buf
    1004/    8377 : 13                                  inc   de               ;     | to next position
    1005/    8378 : 0C                                  inc   c                ;     | 
    1006/    8379 : D6 3A                               sub   CHAR_COLON       ;     | is char ':'?
    1007/    837B : 28 0A                               jr    z, loc_687       ;     | yes, delimiter
    1008/    837D : FE 9B                               cp    TOKEN_TIC-CHAR_COLON ;  | is it "tic"? (D5)
    1009/    837F : 06 3A                               ld    b, CHAR_COLON    ;     | put colon in buf
    1010/    8381 : 28 11                               jr    z, loc_694       ;     | yes, was D5
    1011/    8383 : FE 49                               cp    TOKEN_DATA-CHAR_COLON ; | is token 83 (DATA)?
    1012/    8385 : 20 03                               jr    nz, loc_68A      ;     | no skip
    1013/    8387 : 32 03 0C            loc_687:        ld    (byte_103), a    ;     | save flag
    1014/    838A : D6 54               loc_68A:        sub   TOKEN_REM-CHAR_COLON ; | is token 8E (REM)?
    1015/    838C : 28 05                               jr    z, loc_693       ;     | yes skip
    1016/    838E : D6 0E                               sub   TOKEN_EXCL-TOKEN_REM ; | is token ! (REM)?
    1017/    8390 : C2 12 83                            jp    nz, loop612      ;     | no, loop
    1018/    8393 :                     loc_693:                               ;     | store zero in B
    1019/    8393 : 47                                  ld    b, a             ;     | disable tokenizer until end of line
    1020/    8394 : 7E                  loc_694:        ld    a, (hl)          ;     | get char
    1021/    8395 : B7                                  or    a                ;     | is 0?
    1022/    8396 : 28 15                               jr    z, loc_6AD       ;     | yes, done
    1023/    8398 : B8                                  cp    b                ;     | same as start char?
    1024/    8399 : 28 D0                               jr    z, loc_66B       ;     | yes, done
    1025/    839B : 23                  loc_69B:        inc   hl               ;     | advance to next char
    1026/    839C : 12                                  ld    (de), a          ;     | put char in buf
    1027/    839D : 0C                                  inc   c                ;     | increment cntr
    1028/    839E : 13                                  inc   de               ;     | increment targetbufptr
    1029/    839F : 18 F3                               jr    loc_694          ;     | disable tokenizer until next " is seen, or 0
    1030/    83A1 : E1                  loc_6A1:        pop   hl               ;     | restore ptr to potential keyword
    1031/    83A2 : E5                                  push  hl               ;     | save it again
    1032/    83A3 : 04                                  inc   b                ;     | increment token cntr
    1033/    83A4 : EB                                  ex    de, hl           ;     | keyword in DE, tokentable in HL
    1034/    83A5 : CB 7E               loop6A5:        bit   7, (hl)          ;<+   | test bit of token tbl entry
    1035/    83A7 : 23                                  inc   hl               ; |   | advance
    1036/    83A8 : 28 FB                               jr    z, loop6A5       ;-+   | loop as long as end of token not reached
    1037/    83AA : EB                                  ex    de, hl           ;     | keyword in HL, tokentbl in DE
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 19 - 8/15/2019 11:33:6


    1038/    83AB : 18 8C                               jr    loop639          ;-----+ loop
    1039/    83AD : 21 B0 0C            loc_6AD:        ld    hl, inputbuf-1   ; point to start of inputbuf -1
    1040/    83B0 : 12                                  ld    (de), a          ; save three 0 bytes at the end of buf
    1041/    83B1 : 13                                  inc   de               ; 1st byte = end of line
    1042/    83B2 :                                                            ; 2nd,3rd = link to next line
    1043/    83B2 :                                                            ; is 0000 because this is a single
    1044/    83B2 :                                                            ; line in inputbuf
    1045/    83B2 : 12                                  ld    (de), a
    1046/    83B3 : 13                                  inc   de
    1047/    83B4 : 12                                  ld    (de), a
    1048/    83B5 : C9                                  ret
    1049/    83B6 :                     
    1050/    83B6 : 78                  ctrl_7f:        ld    a, b             ; get current char count of input line
    1051/    83B7 : 3D                                  dec   a                ; decrement
    1052/    83B8 : FD B6 00                            or    (iy+ioparams_curpos) ; get current position
    1053/    83BB : 28 4A                               jr    z, get_inputline ; at beginning of line? yes, restart get_inputline
    1054/    83BD : CD 70 84                            call  print_backslash  ; no, print a backslash
    1055/    83C0 : 10 08               loop6C0:        djnz  loc_6CA          ;<+ skip if count not zero
    1056/    83C2 : CD 70 84                            call  print_backslash  ; | two backslahes
    1057/    83C5 : CD 70 84                            call  print_backslash  ; |
    1058/    83C8 : 18 3A                               jr    loc_704          ; | restart get_inputline in new line
    1059/    83CA : 2B                  loc_6CA:        dec   hl               ; | decrement line ptr
    1060/    83CB : 7E                                  ld    a, (hl)          ; | get last char
    1061/    83CC : CD 66 84                            call  print_char       ; | print it
    1062/    83CF : CD C9 84                            call  read_conchar     ; | get a character
    1063/    83D2 : FE 7F                               cp    CHAR_RUBOUT      ; | is RUBOUT?
    1064/    83D4 : 28 EA                               jr    z, loop6C0       ;-+ yes, loop
    1065/    83D6 : F5                                  push  af               ; save char entered
    1066/    83D7 : CD 70 84                            call  print_backslash  ; final backslash
    1067/    83DA : F1                                  pop   af               ; restore
    1068/    83DB : 18 36                               jr    loc_713          ; back with entering data in buf
    1069/    83DD :                     
    1070/    83DD :                     ; print ?? to get more input
    1071/    83DD :                     ; read a new inputbuf, return start of buf in HL
    1072/    83DD :                     get_moreinput:
    1073/    83DD : 3E 3F                               ld    a, CHAR_QUEST
    1074/    83DF : CD 72 84                            call  write_char
    1075/    83E2 :                     ; prompt ?, get an inputbuf, Z=1 if CTRL-C entered,
    1076/    83E2 :                     ; HL points to inputbuf-1
    1077/    83E2 : 3E 3F               get_input:      ld    a, CHAR_QUEST    ; print a question mark
    1078/    83E4 : CD 72 84                            call  write_char
    1079/    83E7 : CD 64 84                            call  print_space      ; print a space
    1080/    83EA : CD 07 84                            call  get_inputline    ; get a buf
    1081/    83ED : 23                                  inc   hl               ; point to inputbuf
    1082/    83EE : 7E                                  ld    a, (hl)          ; get char in buf
    1083/    83EF : 2B                                  dec   hl               ; point to inputbuf-1
    1084/    83F0 : FE 03                               cp    3                ; check for CTRL-C
    1085/    83F2 : C9                                  ret                    ; exit
    1086/    83F3 :                     
    1087/    83F3 :                     con_emit_ctrl_char:
    1088/    83F3 : CD FC 82                            call  select_console   ; select console for I/O
    1089/    83F6 :                     emit_ctrl_char:
    1090/    83F6 : F5                                  push  af               ; save char for output
    1091/    83F7 : 3E 5E                               ld    a, '^'           ; prefix ^ for CTRL char
    1092/    83F9 : CD 72 84                            call  write_char       ; output it
    1093/    83FC : F1                                  pop   af               ; restore char
    1094/    83FD : F6 40                               or    40h              ; convert to A-Z
    1095/    83FF : 18 71                               jr    write_char       ; emit it
    1096/    8401 :                     
    1097/    8401 : CD F6 83            ctrlu:          call  emit_ctrl_char   ; emit CTRL-U
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 20 - 8/15/2019 11:33:6


    1098/    8404 : CD 0E 8A            loc_704:        call  prompt_edit_lineno ; emit the lineno,if any
    1099/    8407 :                     
    1100/    8407 :                     ; read input line in inputbuf
    1101/    8407 :                     ; return inputbuf-1, B = # characters entered,
    1102/    8407 :                     ; buf terminated with 0
    1103/    8407 :                     get_inputline:
    1104/    8407 : 21 B1 0C                            ld    hl, inputbuf     ; get bufptr
    1105/    840A : 06 01                               ld    b, 1             ; initialize count
    1106/    840C : 78                                  ld    a, b
    1107/    840D : 32 A7 0C                            ld    (inputbuf_cnt), a
    1108/    8410 : CD C9 84            loop710:        call  read_conchar     ;<+ read a character
    1109/    8413 : FE 07               loc_713:        cp    7                ; | is it BEL?
    1110/    8415 : 28 3C                               jr    z, loc_753       ; | yes, skip
    1111/    8417 : FE 0D                               cp    CHAR_CR          ; | is it CR?
    1112/    8419 : CA E9 89                            jp    z, loc_CE9       ; | yes, do CRLF and exit
    1113/    841C : FE 03                               cp    3                ; | is it CTRL-C?
    1114/    841E : CA E1 89                            jp    z, loc_CE1       ; | yes, store CTRL-C and exit
    1115/    8421 : FE 15                               cp    CHAR_CTRLU       ; | is CTRL-U?
    1116/    8423 : 28 DC                               jr    z, ctrlu         ; | yes, discard line
    1117/    8425 : FE 08                               cp    08h      ; | is it RUBOUT?
    1118/    8427 : 28 8D                               jr    z, ctrl_7f       ; | yes, skip
    1119/    8429 : FE 12                               cp    CHAR_CTRLR       ; | is CTRL-R?
    1120/    842B : 20 14                               jr    nz, loc_741      ; | no, skip
    1121/    842D : CD F6 83                            call  emit_ctrl_char   ; | emit CTRL-R
    1122/    8430 : CD 0E 8A                            call  prompt_edit_lineno ; do CRLF and edit prompt, if any
    1123/    8433 : 21 B1 0C                            ld    hl, inputbuf     ; | get current inputbuf
    1124/    8436 : 48                                  ld    c, b             ; | copy current line count in C
    1125/    8437 : 0D                  loop737:        dec   c                ;<--+ pre decrement char cntr
    1126/    8438 : 28 D6                               jr    z, loop710       ;-+ | no more chars? continue with input
    1127/    843A : 7E                                  ld    a, (hl)          ;   | get char from buf
    1128/    843B : 23                                  inc   hl               ;   | advance ptr
    1129/    843C : CD 66 84                            call  print_char       ;   | print it
    1130/    843F : 18 F6                               jr    loop737          ;---+ loop
    1131/    8441 : FE 09               loc_741:        cp    CHAR_TAB         ; is TAB?
    1132/    8443 : 28 0E                               jr    z, loc_753       ; yes, accept as normal char
    1133/    8445 : FE 0A                               cp    CHAR_LF          ; is LF?
    1134/    8447 : 20 06                               jr    nz, loc_74F      ; no, skip
    1135/    8449 : 05                                  dec   b                ; decrement cntr
    1136/    844A : 28 BB                               jr    z, get_inputline ; if at beginning, restart get_inputline
    1137/    844C : 04                                  inc   b                ; restore buf cnt
    1138/    844D : 18 04                               jr    loc_753          ; accept as normal character
    1139/    844F : FE 20               loc_74F:        cp    CHAR_SPACE       ; is another control character?
    1140/    8451 : 38 BD                               jr    c, loop710       ; yes, ignore
    1141/    8453 : 4F                  loc_753:        ld    c, a             ; save entered char
    1142/    8454 : 78                                  ld    a, b             ; get current buf count
    1143/    8455 : FE FD                               cp    253              ; still space in buf?
    1144/    8457 : 3E 07                               ld    a, 7             ; preload BEL
    1145/    8459 : 30 04                               jr    nc, loc_75F      ; no space, ring bell
    1146/    845B : 79                                  ld    a, c             ; restore entered char
    1147/    845C : 77                                  ld    (hl), a          ; store it in buf
    1148/    845D : 23                                  inc   hl               ; advance bufptr
    1149/    845E : 04                                  inc   b                ; advance buf ocunt
    1150/    845F : CD 66 84            loc_75F:        call  print_char       ; emit character
    1151/    8462 : 18 AC                               jr    loop710          ; loop
    1152/    8464 :                     
    1153/    8464 :                     ;print a SPACE on current output device
    1154/    8464 :                     print_space:
    1155/    8464 : 3E 20                               ld    a, CHAR_SPACE
    1156/    8466 :                     
    1157/    8466 :                     ; print char in A on the current output device,
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 21 - 8/15/2019 11:33:6


    1158/    8466 :                     ; interpret LF (emit CR+LF+NUL...)
    1159/    8466 : FE 0A               print_char:     cp    CHAR_LF          ; is LF?
    1160/    8468 : 20 08                               jr    nz, write_char   ; no, emit char
    1161/    846A : CD EE 89                            call  print_crlf       ; do a CRLF
    1162/    846D : 3E 0A                               ld    a, CHAR_LF       ; reload char (LF)
    1163/    846F : C9                                  ret                    ; exit
    1164/    8470 :                     
    1165/    8470 :                     print_backslash:
    1166/    8470 : 3E 5C                               ld    a, CHAR_BSLASH   ; print a backslash (for DEL)
    1167/    8472 :                     
    1168/    8472 :                     ; print out a char in A at the current output device
    1169/    8472 : C5                  write_char:     push  bc               ; print_char
    1170/    8473 : 4F                                  ld    c, a             ; save char
    1171/    8474 : 3A 00 0C                            ld    a, (iosuppress)  ; get IO suppress flag
    1172/    8477 : B7                                  or    a
    1173/    8478 : 20 3F                               jr    nz, loc_7B9      ; is set, exit
    1174/    847A : 79                                  ld    a, c             ; get char
    1175/    847B : FE 09                               cp    CHAR_TAB         ; is a TAB?
    1176/    847D : 20 27                               jr    nz, loc_7A6      ; no, skip
    1177/    847F : FD 7E 01                            ld    a, (iy+ioparams_linelength) ; get line length
    1178/    8482 : E6 F8                               and   0F8h ; 'ø'       ; adjust to multiple of 8
    1179/    8484 : 3D                                  dec   a                ; -1
    1180/    8485 : FD BE 00                            cp    (iy)    ; ioparams compare to current pos
    1181/    8488 : 38 17                               jr    c, loc_7A1       ; would TAB skip to next line?, then do CRLF
    1182/    848A : FD 7E 00                            ld    a, (iy) ; ioparams no get current pos
    1183/    848D : E6 07               loc_78D:        and   7                ; get # of chars printed in current tab column
    1184/    848F : 2F                                  cpl                    ; calculate number of chars still to print
    1185/    8490 : C6 09                               add   a, 9
    1186/    8492 : 47                                  ld    b, a             ; into cntr
    1187/    8493 : 0E 20                               ld    c, CHAR_SPACE    ; load SPACE
    1188/    8495 : CD 8D 0C            loop795:        call  outputvector     ;<----+ emit it
    1189/    8498 : FD 34 00                            inc   (iy+ioparams_curpos) ; | advance next position
    1190/    849B : 10 F8                               djnz  loop795          ;-----+ loop
    1191/    849D : 0E 09               loc_79D:        ld    c, CHAR_TAB      ; restore char
    1192/    849F : 18 18                               jr    loc_7B9          ; exit
    1193/    84A1 : CD EE 89            loc_7A1:        call  print_crlf       ; advance to next line
    1194/    84A4 : 18 F7                               jr    loc_79D          
    1195/    84A6 : FE 20               loc_7A6:        cp    CHAR_SPACE       ; is it a CTRL?
    1196/    84A8 : 38 0C                               jr    c, loc_7B6       ; no, skip
    1197/    84AA : FD 7E 00                            ld    a, (iy+ioparams_curpos) ; get current pos
    1198/    84AD : FD BE 01                            cp    (iy+ioparams_linelength) ; compare with line length
    1199/    84B0 : CC EE 89                            call  z, print_crlf    ; if end of line reached, do CRLF
    1200/    84B3 : FD 34 00                            inc   (iy+ioparams_curpos) ; advance position
    1201/    84B6 : CD 8D 0C            loc_7B6:        call  outputvector ; emit it
    1202/    84B9 : 79                  loc_7B9:        ld    a, c             ; restore registers, return char in A
    1203/    84BA : C1                                  pop   bc
    1204/    84BB : B7                                  or    a
    1205/    84BC : C9                                  ret
    1206/    84BD :                     
    1207/    84BD :                     ; print a string pointed to by HL, delimited by character with high byte set
    1208/    84BD : 7E                  print_string:   ld    a, (hl)          ; get character
    1209/    84BE : CB BF                               res   7, a             ; reset bit 7
    1210/    84C0 : CD 66 84                            call  print_char       ; emit
    1211/    84C3 : CB 7E                               bit   7, (hl)          ; test bit 7
    1212/    84C5 : C0                                  ret   nz               ; exit if set
    1213/    84C6 : 23                                  inc   hl               ; advance to next char
    1214/    84C7 : 18 F4                               jr    print_string     ; loop
    1215/    84C9 :                     
    1216/    84C9 :                     ; read a char from console, return in A
    1217/    84C9 : CD 09 80            read_conchar:   call  CONSOLEIN        ; read a character
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 22 - 8/15/2019 11:33:6


    1218/    84CC : E6 7F                               and   MASK_7BIT        ; mask out parity bit
    1219/    84CE : FE 18                               cp    CHAR_CTRLX       ; is it CTRL-X?
    1220/    84D0 : 28 0F                               jr    z, loc_7E1       ; yes, skip
    1221/    84D2 : FE 0F                               cp    CHAR_CTRLO       ; is it CTRL-O?
    1222/    84D4 : C0                                  ret   nz               ; no, return with character read
    1223/    84D5 : CD F3 83                            call  con_emit_ctrl_char ; print char as ^O
    1224/    84D8 : 3A 00 0C                            ld    a, (iosuppress)  ; complement IOSUPPRESS flag
    1225/    84DB : 2F                                  cpl
    1226/    84DC : 32 00 0C                            ld    (iosuppress), a
    1227/    84DF : AF                                  xor   a                ; return A =0
    1228/    84E0 : C9                                  ret
    1229/    84E1 : CD F3 83            loc_7E1:        call  con_emit_ctrl_char
    1230/    84E4 : CD EE 89                            call  print_crlf       ; print a CRLF
    1231/    84E7 : CD 24 80                            call  TRAP             ; return to monitor
    1232/    84EA : AF                                  xor   a                ; hopefully return here back to BASIC
    1233/    84EB : C9                                  ret                    ; with A = 0
    1234/    84EC :                     
    1235/    84EC : CD A6 95            exec_llist:     call  select_printer   ; select printer for output
    1236/    84EF : C1                  exec_list:      pop   bc               ; drop return address
    1237/    84F0 : CD 73 82                            call  get_lineno_range ; get a lineno range
    1238/    84F3 :                                                            ; HL, BC point to first line
    1239/    84F3 :                                                            ; stack contains end of range
    1240/    84F3 : C5                                  push  bc               ; save nextlink of first line
    1241/    84F4 : CD EE 89            list1:          call  print_crlf       ; new line
    1242/    84F7 : E1                                  pop   hl               ; get nextlink of line in HL
    1243/    84F8 : D1                                  pop   de               ; DE is lastlineno to list
    1244/    84F9 : (MACRO)                             LDBC_M                 ; get nextlink into BC
    1244/    84F9 : 4E                                  ld    c, (hl)
    1244/    84FA : 23                                  inc   hl
    1244/    84FB : 46                                  ld    b, (hl)
    1245/    84FC : 23                                  inc   hl
    1246/    84FD : 78                                  ld    a, b             ; is it zero, ie end of program?
    1247/    84FE : B1                                  OR c
    1248/    84FF : 28 33                               jr    z, loc_834       ; yes, done, return to interpreter
    1249/    8501 : CD 93 86                            call  check_break      ; check for break, exit if CTRL-C
    1250/    8504 : C5                                  push  bc               ; save nextlink
    1251/    8505 : (MACRO)                             LDBC_M                 ; get current lineno in BC
    1251/    8505 : 4E                                  ld    c, (hl)
    1251/    8506 : 23                                  inc   hl
    1251/    8507 : 46                                  ld    b, (hl)
    1252/    8508 : 23                                  inc   hl
    1253/    8509 : C5                                  push  bc               ; save it
    1254/    850A : E3                                  ex    (sp), hl         ; stack is ptr to line
    1255/    850B :                                                            ; HL is current lineno
    1256/    850B : EB                                  ex    de, hl           ; swap with lastlineno
    1257/    850C : (MACRO)                             CPHL_DE                ; compare this lineno with lastlineno
    1257/    850C : 7C                                  ld    a, h
    1257/    850D : 92                                  sub   d
    1257/    850E : 20 02                               jr    nz, m1
    1257/    8510 : 7D                                  ld    a, l
    1257/    8511 : 93                                  sub   e
    1257/    8512 :                     m1:
    1258/    8512 : C1                                  pop   bc               ; restore ptr to line
    1259/    8513 : 38 1E                               jr    c, sub_833       ; end reached, clean up and return to interpreter
    1260/    8515 : E3                                  ex    (sp), hl         ; stack is lastlineneo
    1261/    8516 :                                                            ; HL is nextlink
    1262/    8516 : E5                                  push  hl               ; save
    1263/    8517 : C5                                  push  bc               ; save ptr to line
    1264/    8518 : EB                                  ex    de, hl           ; HL becomes current lineno
    1265/    8519 : CD C9 A1                            call  print_HL         ; print it
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 23 - 8/15/2019 11:33:6


    1266/    851C : E1                                  pop   hl               ; restore ptr to line
    1267/    851D : CD 64 84                            call  print_space      ; print a space
    1268/    8520 : CD 37 85                            call  detokenize       ; detokenize line
    1269/    8523 : 21 B1 0C                            ld    hl, inputbuf     ; load inputbuf
    1270/    8526 : 01 F4 84                            ld    bc, list1        ; recurse LIST/LLIST
    1271/    8529 : C5                                  push  bc               ; on return
    1272/    852A :                     
    1273/    852A : 2B                  sub_82A:        dec   hl               ; point to position before buf
    1274/    852B : 06 00                               ld    b, NULL          ; set terminator character
    1275/    852D : CD F0 90                            call  copy_0string     ; copy 0-terminated string to expression stack
    1276/    8530 : C3 34 91                            jp    straccu_print    ; print the string
    1277/    8533 :                     
    1278/    8533 : C1                  sub_833:        pop   bc
    1279/    8534 : C3 A0 81            loc_834:        jp    print_prompt
    1280/    8537 :                     
    1281/    8537 :                     ; HL points to program line
    1282/    8537 :                     ; expand tokens  to keywords and copy expanded line into inputbuf
    1283/    8537 : 01 B0 0C            detokenize:     ld    bc, inputbuf-1   ; ptr to inputbuf - 1
    1284/    853A : 3E                                  db    3Eh              ; LD A, xx to skip next instruction
    1285/    853B :                                                            ; masks POP HL. LD A is uncritical because
    1286/    853B :                                                            ; A will be overwritten
    1287/    853B : E1                  loop83B:        pop   hl               ; restore ptr to program line again
    1288/    853C : 7E                  loop83C:        ld    a, (hl)          ; get char from program line
    1289/    853D : 03                                  inc   bc               ; advance inputbuf
    1290/    853E : B7                                  or    a                ; set flags
    1291/    853F : 23                                  inc   hl               ; advance program line
    1292/    8540 : 02                                  ld    (bc), a          ; store char in inputbuf
    1293/    8541 : C8                                  ret   z                ; exit if terminating 0 byte
    1294/    8542 : F2 3C 85                            jp    p, loop83C       ; if character not a token, loop
    1295/    8545 : FE C9                               cp    TOKEN_ELSE       ; is it an ELSE?
    1296/    8547 : 20 01                               jr    nz, loc_84A      ; no skip
    1297/    8549 : 0B                                  dec   bc               ; decrement ptr
    1298/    854A :                                                            ; tokenizer has inserted a ':' before ELSE to
    1299/    854A :                                                            ; improve parsing -> discard this
    1300/    854A : D6 80               loc_84A:        sub   80h              ; convert to 0...N
    1301/    854C : E5                                  push  hl               ; save ptr to program line
    1302/    854D : 21 63 A9                            ld    hl, token_tbl    ; get token table
    1303/    8550 : 28 08                               jr    z, kwd_found     ; if zero, found correct keyword
    1304/    8552 : CB 7E               loop852:        bit   7, (hl)          ;<+ test high bit of keyword
    1305/    8554 : 23                                  inc   hl               ; | advance token ptr
    1306/    8555 : 28 FB                               jr    z, loop852       ;>+ not at end of keyword, loop
    1307/    8557 : 3D                                  dec   a                ; | decrement token to find
    1308/    8558 : 20 F8                               jr    nz, loop852      ;-+ correct keyword not yet reached
    1309/    855A : 7E                  kwd_found:      ld    a, (hl)          ; get char from keyword
    1310/    855B : FE 20                               cp    CHAR_SPACE       ; ignore space, as in GO SUB and GO TO
    1311/    855D : 28 08                               jr    z, loc_867
    1312/    855F : B7                                  or    a                ; set sign of character
    1313/    8560 : CB BF                               res   7, a             ; make positive
    1314/    8562 : 02                                  ld    (bc), a          ; put into inputbuf
    1315/    8563 : FA 3B 85                            jp    m, loop83B       ; was end of keyword? yes, continue
    1316/    8566 : 03                                  inc   bc               ; advance inputbufptr
    1317/    8567 : 23                  loc_867:        inc   hl               ; advance to next char, skip space
    1318/    8568 : 18 F0                               jr    kwd_found        ; loop
    1319/    856A :                     
    1320/    856A :                     ; process FOR/TO/STEP
    1321/    856A : 3E 29               exec_for:       ld    a, CHAR_RPAREN
    1322/    856C : 32 4E 0C                            ld    (subscript_flag), a ; this won't match a '(' in find_var,
    1323/    856F :                                                            ; so effectively prevents array variables
    1324/    856F :                                                            ; as FOR variables -> will result in a syntax
    1325/    856F :                                                            ; error when attempting so
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 24 - 8/15/2019 11:33:6


    1326/    856F : CD 27 88                            call  exec_let         ; initialize loop variable
    1327/    8572 :                                                            ; DE = target address
    1328/    8572 :                                                            ; note: this is ensured to be a scalar variable
    1329/    8572 : E3                                  ex    (sp), hl         ; HL = return address
    1330/    8573 :                                                            ; stack    = curlineptr
    1331/    8573 : CD F6 80                            call  discard_open_forloops
    1332/    8576 : D1                                  pop   de               ; DE = curlineptr after loop init
    1333/    8577 : 20 02                               jr    nz, loc_87B      ; some levels discarded?
    1334/    8579 : 09                                  add   hl, bc           ; BC = 17 (sizeof FOR structure)
    1335/    857A : F9                                  ld    sp, hl           ; store as new stack position
    1336/    857B : EB                  loc_87B:        ex    de, hl           ; HL = curlineptr after loop init
    1337/    857C : 0E 0A                               ld    c, 0Ah           ; verify we have enough space
    1338/    857E : CD 31 81                            call  verify_space
    1339/    8581 : E5                                  push  hl               ; save curlineptr
    1340/    8582 : CD 0B 88                            call  exec_data        ; advance to end of line or next statement
    1341/    8585 : E3                                  ex    (sp), hl         ; HL = curlineptr after loop init
    1342/    8586 :                                                            ; stack = curlineptr of loop body
    1343/    8586 : E5                                  push  hl               ; push it on stack
    1344/    8587 : 2A 54 0C                            ld    hl, (lineno)     ; FORSTRUCT: replace with current lineno
    1345/    858A : E3                                  ex    (sp), hl         ; curlineptr points to TO
    1346/    858B :                     
    1347/    858B : (MACRO)             loc_88B:        EXPECT TOKEN_TO        ; expect a TO
    1347/    858B : 3E 9F                               ld    a, TOKEN_TO
    1347/    858D : CD 51 81                            call  expect_char
    1348/    8590 : CD 88 8B                            call  assert_numeric   ; require loop variable numeric
    1349/    8593 : CD 85 8B                            call  expression       ; get TO expression
    1350/    8596 : E5                                  push  hl               ; save curlineptr
    1351/    8597 : CD 02 A0                            call  fpaccu_to_fpreg  ; convert end value into FPREG
    1352/    859A : E1                                  pop   hl               ; restore curlineptr
    1353/    859B : (MACRO)                             PUSH_FPREG1            ; FORSTRUCT: push 6 bytes end value
    1353/    859B : C5                                  push  bc
    1353/    859C : DD E5                               push  ix
    1353/    859E : D5                                  push  de
    1354/    859F : 01 00 81                            ld    bc, 8100h        ; load constant 1.0 into FPreg
    1355/    85A2 : DD 21 00 00                         ld    ix, 0
    1356/    85A6 : 51                                  ld    d, c
    1357/    85A7 : 59                                  ld    e, c
    1358/    85A8 : 7E                                  ld    a, (hl)          ; get next char
    1359/    85A9 : FE A4                               cp    TOKEN_STEP       ; is it STEP token?
    1360/    85AB : 3E 01                               ld    a, 1             ; sign flag: positive
    1361/    85AD : 20 0E                               jr    nz, loc_8BD      ; no, skip
    1362/    85AF : CD 47 86                            call  nextchar         ; get STEP expression
    1363/    85B2 : CD 85 8B                            call  expression
    1364/    85B5 : E5                                  push  hl               ; save curlineptr
    1365/    85B6 : CD 02 A0                            call  fpaccu_to_fpreg  ; put into FPreg
    1366/    85B9 : CD BF 9F                            call  fpaccu_sgn       ; get sign flag 1=positive, ff=negative
    1367/    85BC : E1                                  pop   hl               ; restore curlineptr
    1368/    85BD : (MACRO)             loc_8BD:        PUSH_FPREG1             ; FORSTRUCT: push 6 bytes of STEPsize
    1368/    85BD : C5                                  push  bc
    1368/    85BE : DD E5                               push  ix
    1368/    85C0 : D5                                  push  de
    1369/    85C1 : F5                                  push  af               ; FORSTRUCT: push upward or downward flag
    1370/    85C2 : 33                                  inc   sp               ; discard flag byte
    1371/    85C3 : E5                                  push  hl
    1372/    85C4 : 2A 50 0C                            ld    hl, (curlineptr) ; FORSTRUCT: push address of target variable
    1373/    85C7 : E3                                  ex    (sp), hl
    1374/    85C8 : 06 81               loc_8C8:        ld    b, TOKEN_FOR     ; push FOR marker
    1375/    85CA : C5                                  push  bc
    1376/    85CB : 33                                  inc   sp               ; single byte only
    1377/    85CC :                                                            ; no subroutines to discard, so
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 25 - 8/15/2019 11:33:6


    1378/    85CC :                                                            ; not returning with RET
    1379/    85CC :                     ; enters here after having processed a complete command, i.e. accept either
    1380/    85CC :                     ; EOLN or command separator ':' test for break here
    1381/    85CC : CD 18 80            command_done:   call  CONSOLESTAT      ; get console status
    1382/    85CF : 3C                                  inc   a                ; has a char?
    1383/    85D0 : CC 98 86                            call  z, con_get_char  ; yes, get the char
    1384/    85D3 :                                                            ; will accept CTRL-C, XON, XOFF,
    1385/    85D3 :                                                            ; other chars get lost
    1386/    85D3 : 22 50 0C                            ld    (curlineptr), hl ; save current line ptr
    1387/    85D6 : 7E                                  ld    a, (hl)          ; get current char in process
    1388/    85D7 : FE 3A                               cp    CHAR_COLON       ; is it a colon?
    1389/    85D9 : 28 39                               jr    z, execute_command ; yes, process it
    1390/    85DB : B7                                  or    a                ; is end of line?
    1391/    85DC : C2 6D 81                            jp    nz, syntax_error ; no, error
    1392/    85DF : 23                                  inc   hl               ; was end of line, advance
    1393/    85E0 : 7E                                  ld    a, (hl)          ; get link to next line H
    1394/    85E1 : 23                                  inc   hl               ; advance
    1395/    85E2 : B6                                  or    (hl)             ; get link to next line L
    1396/    85E3 : 23                                  inc   hl               ; advance
    1397/    85E4 : CA C8 86                            jp    z, end_program   ; lineno is zero?, end of program
    1398/    85E7 : (MACRO)                             LDDE_M                 ; get lineno in DE
    1398/    85E7 : 5E                                  ld    e, (hl)
    1398/    85E8 : 23                                  inc   hl
    1398/    85E9 : 56                                  ld    d, (hl)
    1399/    85EA : ED 53 54 0C                         ld    (lineno), de     ; store it a new current lineno
    1400/    85EE : 3A A3 0C                            ld    a, (trace_mode)  ; is trace mode on?
    1401/    85F1 : B7                                  or    a
    1402/    85F2 : 28 20                               jr    z, execute_command ; no, execute the command
    1403/    85F4 : F5                  loc_8F4:        push  af               ; save trace flag
    1404/    85F5 : FC A6 95                            call  m, select_printer ; if bit7=1, select printer for output
    1405/    85F8 : D5                                  push  de               ; save regs
    1406/    85F9 : E5                                  push  hl
    1407/    85FA : 3E 3C                               ld    a, '<'           ; print a '<'
    1408/    85FC : CD 72 84                            call  write_char
    1409/    85FF : EB                                  ex    de, hl           ; get lineno in HL
    1410/    8600 : CD C9 A1                            call  print_HL         ; print it out
    1411/    8603 : 3E 3E                               ld    a, '>'           ; print '>'
    1412/    8605 : CD 72 84                            call  write_char
    1413/    8608 : E1                                  pop   hl               ; restore regs
    1414/    8609 : D1                                  pop   de
    1415/    860A : F1                                  pop   af               ; restore trace flag
    1416/    860B : 87                                  add   a, a             ; shift left
    1417/    860C : 30 06                               jr    nc, execute_command ; was LTRACE? no, execute the command
    1418/    860E : CD FC 82                            call  select_console   ; select console output again
    1419/    8611 : 87                                  add   a, a             ; was ALSO bit 6 set?
    1420/    8612 : 38 E0                               jr    c, loc_8F4       ; yes also trace on console
    1421/    8614 :                     execute_command:            
    1422/    8614 : CD 47 86                            call  nextchar         ; get next char/token
    1423/    8617 : 11 CC 85                            ld    de, command_done ; push return address to call
    1424/    861A :                                                            ; when command is finished
    1425/    861A : D5                                  push  de
    1426/    861B : C8                  loc_91B:        ret   z                ; line was empty, then loop to command_done
    1427/    861C : D6 80               execute_token:  sub   80h              ; has a token or a single ASCII
    1428/    861E : DA 2B 88                            jp    c, do_assignment ; is not a token, skip
    1429/    8621 : FE 46                               cp    TOKEN_MIDS-80h   ; is token MID$?
    1430/    8623 : CA 8B 88                            jp    z, do_lh_mids    ; yes process left-hand-side MID$
    1431/    8626 : FE 1D                               cp    TOKEN_USING-80h  ; is token TAB( ?
    1432/    8628 : 38 0F                               jr    c, loc_939       ; less than this, skip
    1433/    862A : D6 49                               sub   TOKEN_ELSE-80h   ; token 9D to C6 are functions that 
    1434/    862C :                                                            ; can't be used in direct mode
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 26 - 8/15/2019 11:33:6


    1435/    862C : DA 6D 81                            jp    c, syntax_error  ; invalid instruction
    1436/    862F : FE 23                               cp    TOKEN_CONT+1-TOKEN_ELSE  ; token larger than E9 are syntax errors
    1437/    8631 : D2 6D 81                            jp    nc, syntax_error
    1438/    8634 : 11 B0 80                            ld    de, token1_dispatch ; obviously a valid token, load jump table
    1439/    8637 : 18 03                               jr    loc_93C
    1440/    8639 : 11 76 80            loc_939:        ld    de, token2_dispatch ; load jump table
    1441/    863C : 07                  loc_93C:        rlca                   ; token * 2 (word index)
    1442/    863D : 4F                                  ld    c, a             ; put as index into BC
    1443/    863E : 06 00                               ld    b, 0             ; make 16 bit
    1444/    8640 : EB                                  ex    de, hl           ; save curlineptr
    1445/    8641 :                                                            ; load token_dispatch table into HL
    1446/    8641 : 09                                  add   hl, bc           ; point to command entry
    1447/    8642 : (MACRO)                             LDBC_M                 ; get command address into BC
    1447/    8642 : 4E                                  ld    c, (hl)
    1447/    8643 : 23                                  inc   hl
    1447/    8644 : 46                                  ld    b, (hl)
    1448/    8645 : C5                                  push  bc               ; push it on stack, will be called on
    1449/    8646 :                                                            ; return of nextchar
    1450/    8646 : EB                                  ex    de, hl           ; restore curlineptr
    1451/    8647 :                     
    1452/    8647 :                     ; get next char    from inputbuf, set CY if digit seen
    1453/    8647 : 23                  nextchar:       inc   hl               ; point to next char in buf
    1454/    8648 : 7E                  skipspace:      ld    a, (hl)          ; get char from    buf
    1455/    8649 : FE D5                               cp    TOKEN_TIC        ; is it "tic" (token D5)?
    1456/    864B : 20 08                               jr    nz, loc_955      ; no, skip
    1457/    864D : 23                  loc_94D:        inc   hl               ; next char
    1458/    864E : 7E                                  ld    a, (hl)          ; get next char
    1459/    864F : FE 3A                               cp    CHAR_COLON       ; is it ':'?
    1460/    8651 : C8                                  ret   z                ; yes, exit
    1461/    8652 : B7                                  or    a
    1462/    8653 : 20 F8                               jr    nz, loc_94D
    1463/    8655 : FE 3A               loc_955:        cp    CHAR_NINE+1      ; is it > '9'? 
    1464/    8657 : D0                                  ret   nc               ; yes, exit
    1465/    8658 : FE 20                               cp    CHAR_SPACE       ; is it space?
    1466/    865A : 28 EB                               jr    z, nextchar      ; skip space
    1467/    865C : FE 09                               cp    CHAR_TAB         ; is it TAB?
    1468/    865E : 28 E7                               jr    z, nextchar      ; yes skip white space
    1469/    8660 : FE 0A                               cp    CHAR_LF          ; is it LF?
    1470/    8662 : 28 E3                               jr    z, nextchar      ; yes, skip whitespace
    1471/    8664 : FE 30                               cp    CHAR_ZERO        ; compare with '0'
    1472/    8666 : 3F                                  ccf                    ; complement CY
    1473/    8667 : 3C                                  inc   a                ; set flags
    1474/    8668 : 3D                                  dec   a
    1475/    8669 : C9                                  ret                    ; exit
    1476/    866A :                     
    1477/    866A :                     ; process RESTORE
    1478/    866A : 28 0F               exec_restore:   jr    z, reset_dataptr ; no arg, reset DATA ptr to start of program
    1479/    866C : CD 85 86                            call  read_lineno      ; get a lineno
    1480/    866F : E5                                  push  hl               ; save curlineptr
    1481/    8670 : CD 92 82                            call  find_line        ; find line
    1482/    8673 : D1                                  pop   de               ; restore curlineptr into DE
    1483/    8674 : D2 E1 87                            jp    nc, undef_stmt_error ; error if line does not exist
    1484/    8677 : (MACRO)                             LDHL_BC                ; copy ptr to LINE into HL
    1484/    8677 : 60                                  ld    h, b
    1484/    8678 : 69                                  ld    l, c
    1485/    8679 : 18 04                               jr    set_dataptr      ; set the data ptr
    1486/    867B :                                                            ; will restore the curlineptr again into HL
    1487/    867B :                     
    1488/    867B :                     ; set the ptr to next DATA
    1489/    867B : EB                  reset_dataptr:  ex    de, hl           ; save HL
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 27 - 8/15/2019 11:33:6


    1490/    867C : 2A 5C 0C                            ld    hl, (start_memory) ; get memory start
    1491/    867F : 2B                  set_dataptr:    dec   hl
    1492/    8680 : 22 64 0C            set_dataptr1:   ld    (data_ptr), hl   ; save next position to interpret
    1493/    8683 : EB                                  ex    de, hl           ; restore HL
    1494/    8684 : C9                                  ret
    1495/    8685 :                     
    1496/    8685 :                     ; read a lineno into DE (may be missing -> DE=0)
    1497/    8685 : 2B                  read_lineno:    dec   hl               ; point to begin of expression
    1498/    8686 :                     read_lineno_here:            
    1499/    8686 : CD 47 86                            call  nextchar         ; get next char
    1500/    8689 : CD 49 87                            call  parse_lineno     ; read a lineno into DE
    1501/    868C : 18 BA                               jr    skipspace        ; skip spaces
    1502/    868E :                     
    1503/    868E : C1                  input_ctrlc:    pop   bc               ; drop address of variable
    1504/    868F : C1                  input_ctrlc1:   pop   bc               ; drop curlineptr
    1505/    8690 : B7                  has_break:      or    a                ; enters here with ctrl-C seen
    1506/    8691 : 18 34                               jr    break_entry      ; jump into END for break processing
    1507/    8693 :                     
    1508/    8693 : CD 18 80            check_break:    call  CONSOLESTAT      ; get console status
    1509/    8696 : 3C                                  inc   a                ; if A=FF, character present
    1510/    8697 : C0                                  ret   nz               ; no char present: exit
    1511/    8698 :                     
    1512/    8698 : CD C9 84            con_get_char:   call  read_conchar     ; read a character
    1513/    869B : FE 14                               cp    CHAR_CTRLT       ; is it CTRL-T?
    1514/    869D : 20 0C                               jr    nz, loc_9AB      ; no, skip
    1515/    869F : E5                                  push  hl               ; save HL
    1516/    86A0 : 2A 54 0C                            ld    hl, (lineno)     ; get lineno
    1517/    86A3 : (MACRO)             				TEST_FFFF              ; is valid (!= ffff)
    1517/    86A3 : 7C                                  ld    a, h
    1517/    86A4 : A5                                  and   l
    1517/    86A5 : 3C                                  inc   a                ; is valid (!= ffff)
    1518/    86A6 : C4 9D 97                            call  nz, trace_lineno ; yes, emit it
    1519/    86A9 : E1                                  pop   hl               ; restore
    1520/    86AA : C9                                  ret
    1521/    86AB : FE 13               loc_9AB:        cp    CHAR_CTRLS       ; is it CTRL-S (XOFF)?
    1522/    86AD : 20 0B                               jr    nz, loc_9BA      ; no skip
    1523/    86AF : CD C9 84            loop9AF:        call  read_conchar     ;<+ read a char
    1524/    86B2 : FE 03                               cp    CHAR_CTRLC       ; | is it CTRL-C (break)?
    1525/    86B4 : 28 04                               jr    z, loc_9BA       ; | yes exit
    1526/    86B6 : FE 11                               cp    CHAR_CTRLQ       ; | is it CTRL-Q (XON)?
    1527/    86B8 : 20 F5                               jr    nz, loop9AF      ;-+ no loop, until XON or break
    1528/    86BA : FE 03               loc_9BA:        cp    CHAR_CTRLC       ; if not break, return
    1529/    86BC : C0                                  ret   nz
    1530/    86BD : CD F3 83                            call  con_emit_ctrl_char ; emit ^C
    1531/    86C0 :                                                            ; and skip to exec_end
    1532/    86C0 : 3E                                  db    3Eh              ; LD A, xxxx to skip next instructions
    1533/    86C1 : C0                  exec_stop:      ret   nz               ;* more instructions follow?, exit
    1534/    86C2 : F6                                  db    0F6h             ;* OR xxxx to skip next instruction
    1535/    86C3 :                                                            ; ensures that A is non zero
    1536/    86C3 :                     exec_end:                              ; ignore unless at end of line
    1537/    86C3 : C0                                  ret   nz               ; note: when entered through END, A=0
    1538/    86C4 :                                                            ; when entered through STOP, A = 0xC0
    1539/    86C4 : 22 50 0C                            ld    (curlineptr), hl ; save last position for CONT
    1540/    86C7 : C1                  break_entry:    pop   bc               ; discard return address
    1541/    86C8 :                                                            ; will leave interpreter loop on return
    1542/    86C8 : F5                  end_program:    push  af               ; save token (C0 if stop)
    1543/    86C9 : 2A 54 0C                            ld    hl, (lineno)     ; get lineno
    1544/    86CC : 7D                                  LD	a,l		; is FFFF?
    1545/    86CD : A4                                  and	h
    1546/    86CE : 3C                                  inc	a
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 28 - 8/15/2019 11:33:6


    1547/    86CF : 28 09                               jr    z, loc_9DA       ; yes, not in program mode
    1548/    86D1 : 22 56 0C                            ld    (contlineno), hl ; save last lineno for continue
    1549/    86D4 : 2A 50 0C                            ld    hl, (curlineptr)
    1550/    86D7 : 22 58 0C                            ld    (contlineptr), hl ; save lineptr for continue
    1551/    86DA : CD F8 82            loc_9DA:        call  enable_output    ; reenable console out if suppressed
    1552/    86DD : F1                                  pop   af               ; restore STOP/END flag
    1553/    86DE : 21 AF AC                            ld    hl, a_break      ; load break message
    1554/    86E1 : C2 94 81                            jp    nz, loc_494      ; was a break/STOP, do print BREAK @ LINE ...
    1555/    86E4 : C3 A0 81                            jp    print_prompt     ; display READY prompt and return to interpreter
    1556/    86E7 :                     
    1557/    86E7 :                     ; process CONT
    1558/    86E7 : 1E 11               exec_cont:      ld    e, 11h           ; preload error message "CAN'T CONTINUE"
    1559/    86E9 : 2A 58 0C                            ld    hl, (contlineptr) ; get ptr to continue line
    1560/    86EC : (MACRO)                             TEST_0
    1560/    86EC : 7C                                  ld    a, h
    1560/    86ED : B5                                  or    l
    1561/    86EE : 28 56                               jr    z, loc_A46       ; is zero: error
    1562/    86F0 : EB                                  ex    de, hl           ; save continue    line
    1563/    86F1 : 2A 56 0C                            ld    hl, (contlineno) ; set current lineno
    1564/    86F4 : 22 54 0C                            ld    (lineno), hl
    1565/    86F7 : EB                                  ex    de, hl           ; restore line ptr
    1566/    86F8 : C9                                  ret                    ; return to interpreter, will continue processing
    1567/    86F9 :                     
    1568/    86F9 :                     ; process LNULL, NULL commands
    1569/    86F9 : CD 9F 95            exec_lnull:     call  temporary_select_printer
    1570/    86FC : CD 1B 94            exec_null:      call  expression_u8_ae ; get 8 bit expression
    1571/    86FF : FE 32                               cp    50               ; more than 50?
    1572/    8701 : 30 41                               jr    nc, illfunc_error ; yes, error
    1573/    8703 : FD 77 03                            ld    (iy+ioparams_padcount), a ; store in pad count
    1574/    8706 : 3E 2C                               ld    a, CHAR_COMMA    ; get a comma
    1575/    8708 : BE                                  cp    (hl)             ; does a comma follow in buf?
    1576/    8709 : C0                                  ret   nz               ; no, return
    1577/    870A : CD 47 86                            call  nextchar         ; get next char
    1578/    870D : CD 1B 94                            call  expression_u8_ae ; and get the pad character
    1579/    8710 : FD 77 04                            ld    (iy+ioparams_padchar), a ; put into PAD field
    1580/    8713 : C9                                  ret
    1581/    8714 :                     
    1582/    8714 :                     ; return CY clear, if character is alphabetic
    1583/    8714 : 7E                  check_alpha:    ld    a, (hl)          ; get char
    1584/    8715 : FE 41                               cp    CHAR_A           ; is < 'A'?
    1585/    8717 : D8                                  ret   c                ; yes return CY set
    1586/    8718 : FE 5B                               cp    CHAR_Z+1         ; is less than '['?
    1587/    871A : 3F                                  ccf                    ; complement CY
    1588/    871B : C9                                  ret                    ; return CY clear, if alphabetic
    1589/    871C :                     
    1590/    871C : CD 88 8B            sub_A1C:        call  assert_numeric
    1591/    871F : 18 0C                               jr    fpaccu_to_16
    1592/    8721 :                     
    1593/    8721 :                     ; read next char andparse following expression
    1594/    8721 :                     getnext_expression_U16:
    1595/    8721 : CD 47 86                            call  nextchar
    1596/    8724 :                     
    1597/    8724 :                     ; has first char of expression in A, parse 16 bit expression
    1598/    8724 : CD 85 8B            expression_u16: call  expression
    1599/    8727 :                     
    1600/    8727 :                     ; convert fpaccu to a 16 bit number in DE
    1601/    8727 : CD BF 9F            fpaccu_to_u16:  call  fpaccu_sgn       ; get sign
    1602/    872A : FA 44 87                            jp    m, illfunc_error ; error, if negative
    1603/    872D :                     
    1604/    872D :                     ; convert fpaccu to u16
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 29 - 8/15/2019 11:33:6


    1605/    872D : 3A 6B 0C            fpaccu_to_16:   ld    a, (fpaccu_exp)  ; load exponent
    1606/    8730 : FE 91                               cp    91h              ; less than 65536?
    1607/    8732 : DA 75 A0                            jp    c, fpreg_fix     ; yes, convert
    1608/    8735 : (MACRO)                             FPREG_CONST 9180h, 0, 0 ; constant 65536
    1608/    8735 : 01 80 91                            ld    bc, 9180H
    1608/    8738 : DD 21 00 00                         ld    ix, 0
    1608/    873C : 11 00 00                            ld    de, 0
    1609/    873F : CD 36 A0                            call  fpaccu_compare   ; compare it
    1610/    8742 : 51                  loc_A42:        ld    d, c
    1611/    8743 : C8                                  ret   z                ; less than this?, okay return
    1612/    8744 : 1E 05               illfunc_error:  ld    e, 5             ; load illegal function error
    1613/    8746 : C3 7E 81            loc_A46:        jp    print_error
    1614/    8749 :                     
    1615/    8749 :                     ; parse a lineno and return it in DE
    1616/    8749 : 2B                  parse_lineno:   dec    hl              ; adjust bufptr to point 
    1617/    874A :                                                            ; to previous char
    1618/    874A : 11 00 00                            ld    de, 0            ; set cntr = 0
    1619/    874D : 23                  loopA4D:        inc   hl               ; point to next char
    1620/    874E : 7E                                  ld    a, (hl)          ; get char from buf
    1621/    874F : B7                                  or    a                ; empty line?
    1622/    8750 : C8                                  ret   z                ; yes exit
    1623/    8751 : FE 30                               cp    CHAR_ZERO        ; less than '0'?
    1624/    8753 : 3F                                  ccf
    1625/    8754 : D0                                  ret   nc               ; yes exit
    1626/    8755 : FE 3A                               cp    CHAR_NINE+1      ; greater than '9'?
    1627/    8757 : D0                                  ret   nc               ; yes exit
    1628/    8758 : E5                                  push  hl               ; save bufptr
    1629/    8759 : 21 98 19                            ld    hl, 6552         ; maximum lineno 65529 before
    1630/    875C :                                                            ; calculating * 10 + digit
    1631/    875C : B7                  		OR	A		; Cy =0
    1632/    875D : ED 52                               sbc   hl, de           ; subtract DE from constant
    1633/    875F : DA 6D 81                            jp    c, syntax_error  ; lineno too large
    1634/    8762 : (MACRO)                             LDHL_DE                ; DE -> HL
    1634/    8762 : 62                                  ld    h, d
    1634/    8763 : 6B                                  ld    l, e
    1635/    8764 : 19                                  add   hl, de           ; * 2
    1636/    8765 : 29                                  add   hl, hl           ; * 4
    1637/    8766 : 19                                  add   hl, de           ; * 5
    1638/    8767 : 29                                  add   hl, hl           ; * 10
    1639/    8768 : D6 30                               sub   CHAR_ZERO        ; convert ASCII to digit
    1640/    876A : 5F                                  ld    e, a             ; add digit
    1641/    876B : 16 00                               ld    d, 0
    1642/    876D : 19                                  add   hl, de
    1643/    876E : EB                                  ex    de, hl           ; into number
    1644/    876F : E1                                  pop   hl               ; restore buf
    1645/    8770 : 18 DB                               jr    loopA4D          ; loop
    1646/    8772 :                     
    1647/    8772 :                     ; process CLEAR
    1648/    8772 : 28 26               exec_clear:     jr    z, loc_A9A       ; no argument, go directly to clear
    1649/    8774 : CD 24 87                            call  expression_u16   ; get argument
    1650/    8777 : CD 48 86                            call  skipspace        ; advance beyond expression
    1651/    877A : C0                                  ret   nz               ; return if more arguments
    1652/    877B : E5                                  push  hl               ; save bufptr
    1653/    877C : 2A 04 0C                            ld    hl, (memory_top) ; get memory top
    1654/    877F : ED 52                               sbc   hl, de           ; subtract space for strings
    1655/    8781 : EB                                  ex    de, hl           ; DE is start of reserved space
    1656/    8782 : DA 6D 81                            jp    c, syntax_error  ; more space requested than available memory?
    1657/    8785 : 2A 5E 0C                            ld    hl, (prog_end)   ; get ptr to end of program
    1658/    8788 : 01 28 00                            ld    bc, 40           ; reserve space for stack
    1659/    878B : 09                                  add   hl, bc
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 30 - 8/15/2019 11:33:6


    1660/    878C : (MACRO)                             CPHL_DE                ; subtract string base?
    1660/    878C : 7C                                  ld    a, h
    1660/    878D : 92                                  sub   d
    1660/    878E : 20 02                               jr    nz, m1
    1660/    8790 : 7D                                  ld    a, l
    1660/    8791 : 93                                  sub   e
    1660/    8792 :                     m1:
    1661/    8792 :                                                            ; do program and string area overlap?
    1662/    8792 : D2 4D 81                            jp    nc, out_of_memory_error ; yes error
    1663/    8795 : EB                                  ex    de, hl           ; HL is start of reserved space
    1664/    8796 : 22 5A 0C                            ld    (string_base), hl ; store it
    1665/    8799 : E1                                  pop   hl
    1666/    879A : C3 C6 82            loc_A9A:        jp    init_from_current ; interpreter loop
    1667/    879D :                     
    1668/    879D : CA C2 82            exec_run:       jp    z, init_from_start ; initialize ptrs, clear variables
    1669/    87A0 : CD C6 82                            call  init_from_current ; init again
    1670/    87A3 :                                     ; will push WARMSTART return twice on stack
    1671/    87A3 :                                     ; this is possibly to mark stack that no GOSUB is pending
    1672/    87A3 : 01 CC 85                            ld    bc, command_done ; get command_done entry point
    1673/    87A6 : 18 1C                               jr    pre_goto         ; push entry anddo a GOTO
    1674/    87A8 :                     
    1675/    87A8 :                     ; process a GOSUB
    1676/    87A8 :                     ; this pushes the following structure on the stack
    1677/    87A8 :                     ; TOS -> 0x8C inputbufcnt
    1678/    87A8 :                     ;     current lineno
    1679/    87A8 :                     ;     current line ptr
    1680/    87A8 : 0E 03               exec_gosub:     ld    c, 3
    1681/    87AA : CD 31 81                            call  verify_space     ; assert 3 words are free
    1682/    87AD : C1                                  pop   bc               ; pop return address
    1683/    87AE : E5                                  push  hl               ; GOSUB push curlineptr
    1684/    87AF : ED 5B 54 0C                         ld    de, (lineno)
    1685/    87B3 : D5                                  push  de               ; GOSUB push current lineno
    1686/    87B4 : 7A                                  ld    a, d             ; is lineno ffff?
    1687/    87B5 : B3                                  or    e
    1688/    87B6 : 3C                                  inc   a
    1689/    87B7 : 3A A7 0C                            ld    a, (inputbuf_cnt) ; get inputbuf count
    1690/    87BA : 57                                  ld    d, a             ; save it
    1691/    87BB : 20 04                               jr    nz, loc_AC1      ; was not in direct mode, skip
    1692/    87BD : AF                                  xor    a               ; gosub called from direct mode
    1693/    87BE :                                                            ; clear inputbuf cntr
    1694/    87BE : 32 A7 0C                            ld    (inputbuf_cnt), a
    1695/    87C1 : 1E 8C               loc_AC1:        ld    e, TOKEN_GOSUB   ; gosub marker
    1696/    87C3 : D5                                  push  de               ; GOSUB push gosubmarker
    1697/    87C4 : C5                  pre_goto:       push  bc               ; push return address
    1698/    87C5 :                     
    1699/    87C5 : CD 49 87            exec_goto:      call  parse_lineno     ; get a lineno in DE
    1700/    87C8 : CD 0D 88                            call  advance_to_eoln  ; advance to end of line
    1701/    87CB : E5                                  push  hl               ; save ptr to next line
    1702/    87CC :                                                            ; (points to line terminator)
    1703/    87CC : 2A 54 0C                            ld    hl, (lineno)     ; get current lineno
    1704/    87CF : (MACRO)                             CPHL_DE                ; compare this lineno and target lineno
    1704/    87CF : 7C                                  ld    a, h
    1704/    87D0 : 92                                  sub   d
    1704/    87D1 : 20 02                               jr    nz, m1
    1704/    87D3 : 7D                                  ld    a, l
    1704/    87D4 : 93                                  sub   e
    1704/    87D5 :                     m1:
    1705/    87D5 : E1                                  pop   hl               ; restore line ptr
    1706/    87D6 : 23                                  inc   hl               ; advance to nextlink
    1707/    87D7 : DC 95 82                            call  c, find_line_from_current ; must move forward, jump into
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 31 - 8/15/2019 11:33:6


    1708/    87DA :                                                            ; find_line at current position
    1709/    87DA : D4 92 82            loc_ADA:        call  nc, find_line    ; anyway, find the line
    1710/    87DD : (MACRO)                             LDHL_BC                ; become new position
    1710/    87DD : 60                                  ld    h, b
    1710/    87DE : 69                                  ld    l, c
    1711/    87DF : 2B                                  dec   hl
    1712/    87E0 : D8                                  ret   c                ; if line was found, exit
    1713/    87E1 :                     undef_stmt_error:
    1714/    87E1 : 1E 08                               ld    e, 8
    1715/    87E3 : C3 7E 81            loc_AE3:        jp    print_error
    1716/    87E6 :                     
    1717/    87E6 : C0                  exec_return:    ret   nz               ; more cmds follow?, exit
    1718/    87E7 : 16 FF                               ld    d, 0FFh          ; do not match any variable
    1719/    87E9 : CD F6 80                            call  discard_open_forloops ; clean stack from pending open FOR loop
    1720/    87EC : 56                                  ld    d, (hl)          ; get inputbuf cntr
    1721/    87ED : 23                                  inc   hl               ; advance
    1722/    87EE : F9                                  ld    sp, hl           ; remove token word
    1723/    87EF : FE 8C                               cp    TOKEN_GOSUB      ; check whether it is a GOSUB token
    1724/    87F1 : 1E 03                               ld    e, 3             ; error "RETURN W/O GOSUB"
    1725/    87F3 : 20 EE                               jr    nz, loc_AE3      ; not a GOSUB token: error
    1726/    87F5 : E1                                  pop   hl               ; restore lineno
    1727/    87F6 : 22 54 0C                            ld    (lineno), hl     ; set Z=1 if lineno is FFFF
    1728/    87F9 : (MACRO)                             TEST_FFFF 
    1728/    87F9 : 7C                                  ld    a, h
    1728/    87FA : A5                                  and   l
    1728/    87FB : 3C                                  inc   a                ; is valid (!= ffff)
    1729/    87FC : 21 A7 0C                            ld    hl, inputbuf_cnt ; get current inputbuf cntr
    1730/    87FF : 7E                                  ld    a, (hl)          ; load it
    1731/    8800 : 72                                  ld    (hl), d          ; store the old cntr from GOSUB
    1732/    8801 : 20 04                               jr    nz, loc_B07      ; skip if called in program context
    1733/    8803 : B7                                  or    a                ; inputbuf was overwritten sinc e?
    1734/    8804 : C2 A5 90                            jp    nz, ill_direct_error ; yes, error
    1735/    8807 : 21 CC 85            loc_B07:        ld    hl, command_done
    1736/    880A : E3                                  ex    (sp), hl         ; return through command_done
    1737/    880B :                     
    1738/    880B :                     ; process DATA
    1739/    880B :                     ; which is effectively the same as a REM to the program
    1740/    880B :                     ; exception: will not advance to end of line but to next colon only
    1741/    880B :                     ; this routine is also called from elsewhere, e.g. IF to advance to the ELSE
    1742/    880B : 01                  exec_data:      db    1                ; LD BC, 0E3Ah to skip next instruction
    1743/    880C :                                                            ; skips the LD C,0 instruction,
    1744/    880C :                                                            ; with NOP remaining
    1745/    880C :                                                            ; loads C with 3A (colon), i.e. stop when
    1746/    880C :                                                            ; EOLN or next colon found
    1747/    880C : 3A                                  db    3Ah              ; ** LDA xxxx to skip next instruction
    1748/    880D :                     advance_to_eoln:            
    1749/    880D : 0E 00                               ld    c, NULL          ; ** skipped
    1750/    880F : 06 00                               ld    b, NULL
    1751/    8811 : 79                  loopB11:        ld    a, c             ;<--+ swap C and B
    1752/    8812 : 48                                  ld    c, b             ;   |
    1753/    8813 : 47                                  ld    b, a             ;   |
    1754/    8814 : 7E                  loopB14:        ld    a, (hl)          ;<+ | get next char
    1755/    8815 : B7                                  or    a                ; | | end of line?
    1756/    8816 : C8                                  ret   z                ; | | yes exit
    1757/    8817 : B8                                  cp    b                ; | | is it same as B?
    1758/    8818 : C8                                  ret   z                ; | | yes exit
    1759/    8819 : 23                                  inc   hl               ; | | advance
    1760/    881A : FE 22                               cp    CHAR_QUOTE       ; | | is it a begin of string
    1761/    881C : 28 F3                               jr    z, loopB11       ;---+ 1st time: B becomes ", C becomes 0
    1762/    881E :                                                            ; | 2nd time: B becomes 0, C becomes "
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 32 - 8/15/2019 11:33:6


    1763/    881E :                                                            ; | i.e. wait until end of string or EOLN
    1764/    881E : D6 8A                               sub   TOKEN_IF         ; | subtract 8A (token IF)
    1765/    8820 : 20 F2                               jr    nz, loopB14      ;-+ no loop
    1766/    8822 :                                     ; we found an IF here: this routine is also called
    1767/    8822 :                                     ; by exec_if to find the position of an ELSE, but we have
    1768/    8822 :                                     ; a nesting of IFs here
    1769/    8822 : B8                                  cp    b                ; C=1 if pending ", C=0 if not in string
    1770/    8823 : 8A                                  adc   a, d             ; increment level of nesting
    1771/    8824 : 57                                  ld    d, a             ; into D
    1772/    8825 : 18 ED                               jr    loopB14          ; loop
    1773/    8827 :                     
    1774/    8827 : FE C6               exec_let:       cp    TOKEN_MIDS       ; is MID$ token?
    1775/    8829 : 28 60                               jr    z, do_lh_mids    ; yes, LET MID$(xx,y,z) = expression
    1776/    882B :                     
    1777/    882B :                     ;entry here for assigment without LET
    1778/    882B : CD 6A 8D            do_assignment:  call  find_var         ; get address of variable value into DE
    1779/    882E : (MACRO)                             EXPECT TOKEN_EQUAL     ; expect a '=' token
    1779/    882E : 3E AD                               ld    a, TOKEN_EQUAL
    1779/    8830 : CD 51 81                            call  expect_char
    1780/    8833 : D5                  do_assignment1: push  de               ; HL = curlineptr
    1781/    8834 :                                                            ; DE save var address
    1782/    8834 : 3A 02 0C             		ld    a, (expr_type)   ; save required    expression type
    1783/    8837 : F5                   		push  af
    1784/    8838 : CD 9A 8B                            call  expression1      ; evaluate an expression inro fpaccu
    1785/    883B : F1                                  pop   af
    1786/    883C : E3                                  ex    (sp), hl         ; HL = address of variable
    1787/    883D :                                                            ; stack = curlineptr
    1788/    883D : 22 50 0C                            ld    (curlineptr), hl ; save address in curlineptr
    1789/    8840 : 1F                                  rra                    ; expressiontype expected into CY
    1790/    8841 : CD 8A 8B                            call  verify_exprtype
    1791/    8844 : 20 07                               jr    nz, store_string ; must store a string
    1792/    8846 : E5                                  push  hl               ; target address
    1793/    8847 : CD 16 A0                            call  fpaccu_to_mem    ; store result
    1794/    884A : D1                                  pop   de               ; DE = target address
    1795/    884B : E1                                  pop   hl               ; restore curlineptr
    1796/    884C : C9                                  ret
    1797/    884D :                     
    1798/    884D : E5                  store_string:   push  hl               ; save target address
    1799/    884E : 2A 66 0C                            ld    hl, (fpaccu_mant32) ; get address of string descriptor
    1800/    8851 : E5                                  push  hl               ; save it
    1801/    8852 : 23                                  inc   hl               ; advance to string length
    1802/    8853 : 23                                  inc   hl
    1803/    8854 : (MACRO)                             LDDE_M                 ; get string address into DE
    1803/    8854 : 5E                                  ld    e, (hl)
    1803/    8855 : 23                                  inc   hl
    1803/    8856 : 56                                  ld    d, (hl)
    1804/    8857 : 21 B0 0D                            ld    hl, inputbuf+255 ; load end of input line buf
    1805/    885A : (MACRO)                             CPHL_DE                ; check whether string in inputbuf
    1805/    885A : 7C                                  ld    a, h
    1805/    885B : 92                                  sub   d
    1805/    885C : 20 02                               jr    nz, m1
    1805/    885E : 7D                                  ld    a, l
    1805/    885F : 93                                  sub   e
    1805/    8860 :                     m1:
    1806/    8860 : 30 18                               jr    nc, loc_B7A      ; is below, skip
    1807/    8862 : 2A 5A 0C                            ld    hl, (string_base) ; get base of string
    1808/    8865 : (MACRO)                             CPHL_DE                ; is below string base?
    1808/    8865 : 7C                                  ld    a, h
    1808/    8866 : 92                                  sub   d
    1808/    8867 : 20 02                               jr    nz, m1
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 33 - 8/15/2019 11:33:6


    1808/    8869 : 7D                                  ld    a, l
    1808/    886A : 93                                  sub   e
    1808/    886B :                     m1:
    1809/    886B : D1                                  pop   de               ; restore string descriptor in DE
    1810/    886C : 30 14                               jr    nc, loc_B82      ; is below string base, skip
    1811/    886E : 2A 5E 0C                            ld    hl, (prog_end)   ; check for constant in program
    1812/    8871 : (MACRO)                             CPHL_DE
    1812/    8871 : 7C                                  ld    a, h
    1812/    8872 : 92                                  sub   d
    1812/    8873 : 20 02                               jr    nz, m1
    1812/    8875 : 7D                                  ld    a, l
    1812/    8876 : 93                                  sub   e
    1812/    8877 :                     m1:
    1813/    8877 : 30 09                               jr    nc, loc_B82      ; is in program, skip
    1814/    8879 : 3E                                  db 3Eh                 ; LD A, xx to skip next instruction
    1815/    887A :                     loc_B7A:
    1816/    887A : D1                                  pop   de               ; restore string descriptor
    1817/    887B : CD 83 92                            call  peekpop_str_stringstk ; get off string stack
    1818/    887E : EB                                  ex    de, hl
    1819/    887F : CD CA 90                            call  string_dup       ; make a copy 
    1820/    8882 :                     loc_B82:
    1821/    8882 : CD 83 92                            call  peekpop_str_stringstk ; get off string stack
    1822/    8885 : E1                                  pop   hl               ; restore target address
    1823/    8886 : CD 19 A0                            call  move_to_var      ; move to variable
    1824/    8889 : E1                                  pop   hl               ; restore curlineptr 
    1825/    888A : C9                                  ret
    1826/    888B :                     
    1827/    888B :                     ; lefthand-side MID$
    1828/    888B : CD 47 86            do_lh_mids:     call  nextchar         ; get next char
    1829/    888E : (MACRO)                             EXPECT CHAR_LPAREN     ; expect left paren
    1829/    888E : 3E 28                               ld    a, CHAR_LPAREN
    1829/    8890 : CD 51 81                            call  expect_char
    1830/    8893 : CD 6A 8D                            call  find_var         ; get variable into DE
    1831/    8896 : CD 89 8B                            call  assert_string    ; verify it is a string
    1832/    8899 : (MACRO)                             EXPECT CHAR_COMMA      ; expect a start value for string
    1832/    8899 : 3E 2C                               ld    a, CHAR_COMMA
    1832/    889B : CD 51 81                            call  expect_char
    1833/    889E : D5                                  push  de               ; save variable ptr
    1834/    889F : CD 1B 94                            call  expression_u8_ae ; get an 8 bit expression
    1835/    88A2 : B7                                  or    a                ; is zero?
    1836/    88A3 : CA 44 87                            jp    z, illfunc_error ; yes, error
    1837/    88A6 : F5                                  push  af               ; save start pos
    1838/    88A7 : 1E FF                               ld    e, 0FFh          ; preload maximum position
    1839/    88A9 : 7E                                  ld    a, (hl)          ; get char
    1840/    88AA : FE 29                               cp    CHAR_RPAREN      ; is it right paren?
    1841/    88AC : 28 08                               jr    z, loc_BB6       ; yes, skip
    1842/    88AE : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    1842/    88AE : 3E 2C                               ld    a, CHAR_COMMA
    1842/    88B0 : CD 51 81                            call  expect_char
    1843/    88B3 : CD 1B 94                            call  expression_u8_ae ; get length expression
    1844/    88B6 : (MACRO)             loc_BB6:        EXPECT CHAR_RPAREN     ; expect a right paren now
    1844/    88B6 : 3E 29                               ld    a, CHAR_RPAREN
    1844/    88B8 : CD 51 81                            call  expect_char
    1845/    88BB : (MACRO)                             EXPECT TOKEN_EQUAL     ; expect assignment now
    1845/    88BB : 3E AD                               ld    a, TOKEN_EQUAL
    1845/    88BD : CD 51 81                            call  expect_char
    1846/    88C0 : F1                                  pop   af               ; restore start position
    1847/    88C1 : E3                                  ex    (sp), hl         ; get variable ptr in HL
    1848/    88C2 : 3D                                  dec   a                ; adjust start position to 0-based
    1849/    88C3 : BE                                  cp    (hl)             ; compare with string length in var
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 34 - 8/15/2019 11:33:6


    1850/    88C4 : 06 00                               ld    b, 0
    1851/    88C6 : 30 08                               jr    nc, loc_BD0
    1852/    88C8 : 4F                                  ld    c, a             ; start position in C
    1853/    88C9 : 7E                                  ld    a, (hl)          ; get string length in A
    1854/    88CA : 91                                  sub   c
    1855/    88CB : BB                                  cp    e
    1856/    88CC : 47                                  ld    b, a
    1857/    88CD : 38 01                               jr    c, loc_BD0
    1858/    88CF : 43                                  ld    b, e
    1859/    88D0 : C5                  loc_BD0:        push  bc
    1860/    88D1 : 23                                  inc   hl
    1861/    88D2 : 23                                  inc   hl
    1862/    88D3 : (MACRO)                             LDHL_M B     
    1862/    88D3 : 46                                  ld    B, (hl)
    1862/    88D4 : 23                                  inc   hl
    1862/    88D5 : 66                                  ld    h, (hl)
    1862/    88D6 : 68                                  ld    l, B
    1863/    88D7 : 06 00                               ld    b, 0
    1864/    88D9 : 09                                  add   hl, bc
    1865/    88DA : C1                                  pop   bc
    1866/    88DB : E3                                  ex    (sp), hl
    1867/    88DC : C5                                  push  bc
    1868/    88DD : CD 95 8B                            call  string_expression1
    1869/    88E0 : C1                                  pop   bc
    1870/    88E1 : D1                                  pop   de
    1871/    88E2 : E5                                  push  hl
    1872/    88E3 : 2A 66 0C                            ld    hl, (fpaccu_mant32)
    1873/    88E6 : 78                                  ld    a, b
    1874/    88E7 : 96                                  sub   (hl)
    1875/    88E8 : F5                                  push  af
    1876/    88E9 : 78                                  ld    a, b
    1877/    88EA : 38 01                               jr    c, loc_BED
    1878/    88EC : 7E                                  ld    a, (hl)
    1879/    88ED : 23                  loc_BED:        inc   hl
    1880/    88EE : 23                                  inc   hl
    1881/    88EF : (MACRO)                             LDBC_M       
    1881/    88EF : 4E                                  ld    c, (hl)
    1881/    88F0 : 23                                  inc   hl
    1881/    88F1 : 46                                  ld    b, (hl)
    1882/    88F2 : CD 59 92                            call  copy_string
    1883/    88F5 : F1                                  pop   af
    1884/    88F6 : 38 09                               jr    c, loc_C01
    1885/    88F8 : 28 07                               jr    z, loc_C01
    1886/    88FA : EB                                  ex    de, hl
    1887/    88FB : 36 20               loopBFB:        ld    (hl), CHAR_SPACE ;<+
    1888/    88FD : 23                                  inc   hl               ; |
    1889/    88FE : 3D                                  dec   a                ; |
    1890/    88FF : 20 FA                               jr    nz, loopBFB      ;-+
    1891/    8901 : CD 63 92            loc_C01:        call  fpaccu_getstr
    1892/    8904 : E1                                  pop   hl
    1893/    8905 : C9                                  ret
    1894/    8906 :                     
    1895/    8906 :                     ; process ON GOTO/GOSUB
    1896/    8906 :                     exec_on:
    1897/    8906 : CD 1B 94                            call  expression_u8_ae ; get selector expression
    1898/    8909 : 7E                                  ld    a, (hl)          ; get next char
    1899/    890A : 47                                  ld    b, a             ; put into b
    1900/    890B : FE 8C                               cp    TOKEN_GOSUB      ; is it gosub?
    1901/    890D : 28 06                               jr    z, process_on    ; ok
    1902/    890F : (MACRO)                             EXPECT TOKEN_GOTO      ; must be goto
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 35 - 8/15/2019 11:33:6


    1902/    890F : 3E 88                               ld    a, TOKEN_GOTO
    1902/    8911 : CD 51 81                            call  expect_char
    1903/    8914 : 2B                                  dec   hl               ; point before goto/gosubtoken
    1904/    8915 : 4B                  process_on:     ld    c, e             ; get expression result into C
    1905/    8916 : 0D                  loopC16:        dec   c                ;<+ decrement
    1906/    8917 : 78                                  ld    a, b             ; | get current token
    1907/    8918 : CA 1C 86                            jp    z, execute_token ; | correct lineno found,
    1908/    891B :                                                            ; | continue instruction processing
    1909/    891B :                                                            ; | note: the token is either GOTO or GOSUB
    1910/    891B :                                                            ; | in A, ready to parsed, the curlineptr
    1911/    891B :                                                            ; | points directly to the position of
    1912/    891B :                                                            ; | the matching lineno
    1913/    891B : CD 86 86                            call  read_lineno_here ; | parse a line number
    1914/    891E : FE 2C                               cp    CHAR_COMMA       ; | does a comma follow?
    1915/    8920 : C0                                  ret   nz               ; | no, exit
    1916/    8921 : 18 F3                               jr    loopC16          ;-+ loop
    1917/    8923 :                     
    1918/    8923 :                     ; process IF/THEN/ELSE
    1919/    8923 : CD 9A 8B            exec_if:        call  expression1      ; get expression into fpaccu
    1920/    8926 : 7E                                  ld    a, (hl)          ; get token
    1921/    8927 : FE 2C                               cp    CHAR_COMMA       ; is it comma? ???
    1922/    8929 : CC 47 86                            call  z, nextchar      ; yes ignore
    1923/    892C : FE 88                               cp    TOKEN_GOTO       ; GOTO token?
    1924/    892E : 28 06                               jr    z, loc_C36       ; yes, IF x THEN nnn case
    1925/    8930 : (MACRO)                             EXPECT TOKEN_THEN      ; expect a THEN
    1925/    8930 : 3E A2                               ld    a, TOKEN_THEN
    1925/    8932 : CD 51 81                            call  expect_char
    1926/    8935 : 2B                                  dec   hl               ; point to token before
    1927/    8936 : E5                  loc_C36:        push  hl               ; save it
    1928/    8937 : CD BF 9F                            call  fpaccu_sgn       ; get sign of expression
    1929/    893A : E1                                  pop   hl               ; restore curlineptr
    1930/    893B : 28 09                               jr    z, loc_C46       ; was condition false?
    1931/    893D : CD 47 86            loopC3D:        call  nextchar         ;<+ get the current token again
    1932/    8940 : DA C5 87                            jp    c, exec_goto     ; | if number follows, do a GOTO
    1933/    8943 : C3 1B 86                            jp    loc_91B          ; | otherwise do the instructions after THEN
    1934/    8946 : 16 01               loc_C46:        ld    d, 1             ; | load flag for skipping next instructions
    1935/    8948 : CD 0B 88            loc_C48:        call  exec_data        ; | advance to next colon, using the
    1936/    894B :                                                            ; | DATA skip routine
    1937/    894B : B7                                  or    a                ; | is end of line?
    1938/    894C : C8                                  ret   z                ; | yes done
    1939/    894D : CD 47 86                            call  nextchar         ; | no get next char
    1940/    8950 : FE C9                               cp    TOKEN_ELSE       ; | is it ELSE?
    1941/    8952 : 20 F4                               jr    nz, loc_C48      ; | no, loop
    1942/    8954 : 15                                  dec   d                ; | decrement nesting level
    1943/    8955 : 20 F1                               jr    nz, loc_C48      ; | not zero, find matching ELSE
    1944/    8957 : 18 E4                               jr    loopC3D          ;-+ okay, found the right ELSE, 
    1945/    8959 :                                                            ; do GOTO or instruction
    1946/    8959 :                     
    1947/    8959 : CD 9F 95            exec_lprint:    call  temporary_select_printer
    1948/    895C : CA EE 89            exec_print:     jp    z, print_crlf    ; end of statement, i.e. empty PRINT?
    1949/    895F :                     				                       ; just do a CRLF and exit
    1950/    895F : FE 9D                               cp    TOKEN_USING      ; token USING?
    1951/    8961 : CA 21 A5                            jp    z, printusing
    1952/    8964 : FE 9E                               cp    TOKEN_TAB        ; token TAB( ?
    1953/    8966 : 28 4E                               jr    z, printtab      ; advance to given position
    1954/    8968 : FE A1                               cp    TOKEN_SPC        ; token SPC( ?
    1955/    896A : 28 49                               jr    z, printspc      ; sprint a given number of spaces
    1956/    896C : E5                                  push  hl               ; save curlinepos
    1957/    896D : FE 2C                               cp    CHAR_COMMA       ; check for COMMA
    1958/    896F : 28 32                               jr    z, printcomma    ; advance to next field
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 36 - 8/15/2019 11:33:6


    1959/    8971 : FE 3B                               cp    CHAR_SEMI        ; check for semicolon
    1960/    8973 : 28 5F                               jr    z, printsemi     ; advance to next argument
    1961/    8975 : C1                                  pop   bc               ; discard curlinepos from stack
    1962/    8976 : CD 9A 8B                            call  expression1      ; evaluate next field expression
    1963/    8979 : E5                                  push  hl               ; save curlinepos
    1964/    897A : 3A 02 0C                            ld    a, (expr_type)   ; get expression type
    1965/    897D : B7                                  or    a
    1966/    897E : 20 1A                               jr    nz, loc_C9A      ; not zero, is a string
    1967/    8980 : CD DD A1                            call  format_number    ; is a number, do raw formatting
    1968/    8983 : CD ED 90                            call  straccu_copy     ; copy string pointed to by HL into straccu
    1969/    8986 : 2A 66 0C                            ld    hl, (fpaccu_mant32) ; point to string length
    1970/    8989 : FD 7E 00                            ld    a, (iy+ioparams_curpos) ; get current cursor position
    1971/    898C : 86                                  add   a, (hl)          ; addstring length
    1972/    898D : FD BE 01                            cp    (iy+ioparams_linelength) ; is string longer than rest of line?
    1973/    8990 : D4 EE 89                            call  nc, print_crlf   ; yes, do a CRLF first
    1974/    8993 : CD 34 91                            call  straccu_print    ; print out string
    1975/    8996 : CD 64 84                            call  print_space      ; print a SPACE
    1976/    8999 : AF                                  xor    a               ; skip next instruction  (Z=1)
    1977/    899A : C4 34 91            loc_C9A:        call  nz, straccu_print ; print string
    1978/    899D : E1                                  pop   hl               ; restore curlinepos
    1979/    899E : CD 48 86                            call  skipspace        ; advance to next non-whitespace
    1980/    89A1 : 18 B9                               jr    exec_print       ; loop in PRINT until end of line
    1981/    89A3 : FD 7E 00            printcomma:     ld    a, (iy+ioparams_curpos) ; get current print position
    1982/    89A6 : FD BE 02                            cp    (iy+ioparams_last_field) ; is beyond last field position?
    1983/    89A9 : D4 EE 89                            call  nc, print_crlf   ; yes new line
    1984/    89AC : 30 26                               jr    nc, printsemi    ; continue printing argument
    1985/    89AE : D6 0E               loopCAE:        sub   14               ;<+ current pos modulo field width (14)
    1986/    89B0 : 30 FC                               jr    nc, loopCAE      ;-+ modulo by subtracting
    1987/    89B2 : 2F                                  cpl                    ; complement (became negative)
    1988/    89B3 :                                                            ; -> number of spaces to print to advance
    1989/    89B3 : 18 18                               jr    loc_CCD          ; print as much spaces to advance to next field
    1990/    89B5 : 37                  printspc:       scf                    ; set CY flag for SPC(
    1991/    89B6 :                                                            ; comparison for TAB cleared CY
    1992/    89B6 : F5                  printtab:       push  af               ; save flag
    1993/    89B7 : CD 18 94                            call  next_fpaccu_u8   ; get 8 bit expression
    1994/    89BA : (MACRO)                             EXPECT CHAR_RPAREN     ; expect a closing ')'
    1994/    89BA : 3E 29                               ld    a, CHAR_RPAREN
    1994/    89BC : CD 51 81                            call  expect_char
    1995/    89BF : 2B                                  dec   hl               ; curlineptr to point back to ')'
    1996/    89C0 : F1                                  pop   af               ; restore flag
    1997/    89C1 : E5                                  push  hl               ; save curlineptr
    1998/    89C2 : 3E FF                               ld    a, 0FFh          ; load maximum possible line position
    1999/    89C4 : 38 04                               jr    c, loc_CCA       ; was SPC( ? skip
    2000/    89C6 : FD 7E 00                            ld    a, (iy+ioparams_curpos) ; get current cursor position
    2001/    89C9 : 2F                                  cpl                    ; complement for subtraction
    2002/    89CA : 83                  loc_CCA:        add   a, e             ; add argument
    2003/    89CB : 30 07                               jr    nc, printsemi    ; position already reached? yes exit
    2004/    89CD : 3C                  loc_CCD:        inc   a                ; adjust
    2005/    89CE : 47                                  ld    b, a             ; store as cntr in B
    2006/    89CF : CD 64 84            loopCCF:        call  print_space      ;<+ print space to advance print position
    2007/    89D2 : 10 FB                               djnz    loopCCF        ;-+ loop until done
    2008/    89D4 : E1                  printsemi:      pop   hl               ; restore curlineptr
    2009/    89D5 : CD 47 86                            call  nextchar         ; get next char/token
    2010/    89D8 : C8                                  ret   z                ; end of statement? yes exit
    2011/    89D9 : 18 81                               jr    exec_print       ; otherwise loop in PRINT
    2012/    89DB :                     
    2013/    89DB :                     print_ready_prompt:
    2014/    89DB : 21 9B AC                            ld    hl, a_ready
    2015/    89DE : C3 A4 0C                            jp    coldvector
    2016/    89E1 :                     
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 37 - 8/15/2019 11:33:6


    2017/    89E1 : 21 B1 0C            loc_CE1:        ld    hl, inputbuf     ; get start of buf
    2018/    89E4 : 77                                  ld    (hl), a          ; store control char at beginning
    2019/    89E5 : 23                                  inc   hl               ; advance
    2020/    89E6 : CD F6 83                            call  emit_ctrl_char   ; emit control character
    2021/    89E9 : 36 00               loc_CE9:        ld    (hl), NULL       ; store NULL as end of buf
    2022/    89EB : 21 B0 0C                            ld    hl, inputbuf-1   ; load inputbuf - 1
    2023/    89EE :                     
    2024/    89EE :                     ; print a CRLF including delaying padding bytes
    2025/    89EE : 3E 0D               print_crlf:     ld    a, CHAR_CR       ; load CR
    2026/    89F0 : FD 77 00                            ld    (iy+ioparams_curpos), a  ; set char position to anything
    2027/    89F3 : CD 72 84                            call  write_char       ; emit byte
    2028/    89F6 : 3E 0A                               ld    a, CHAR_LF       ; load LF
    2029/    89F8 : CD 72 84                            call  write_char       ; emit
    2030/    89FB :                     
    2031/    89FB :                     print_nul_delay:
    2032/    89FB : FD 7E 03                            ld    a, (iy+ioparams_padcount) ; get NUL byte cntr
    2033/    89FE : 3C                                  inc   a                ; +1
    2034/    89FF : 3D                  loopCFF:        dec   a                ;<-------+ predecrement
    2035/    8A00 : FD 77 00                            ld    (iy+ioparams_curpos), a ; |  clear charpos (A is 0 on exit)
    2036/    8A03 : C8                                  ret   z                ;        | exit if finished
    2037/    8A04 : F5                                  push  af               ;        | save cntr
    2038/    8A05 : FD 7E 04                            ld    a, (iy+ioparams_padchar) ;| get NUL byte
    2039/    8A08 : CD 72 84                            call  write_char       ;        | emit
    2040/    8A0B : F1                                  pop   af               ;        | restore cntr
    2041/    8A0C : 18 F1                               jr    loopCFF          ;--------+ loop
    2042/    8A0E :                     
    2043/    8A0E :                     prompt_edit_lineno:
    2044/    8A0E : CD EE 89                            call  print_crlf       ; do a CRLF
    2045/    8A11 : 3A AB 0C                            ld    a, (prompt_flag) ; print PROMPT?
    2046/    8A14 : B7                                  or    a
    2047/    8A15 : C8                                  ret   z                ; no, exit
    2048/    8A16 : E5                                  push  hl               ; save registers
    2049/    8A17 : C5                                  push  bc
    2050/    8A18 : 2A 9A 0C                            ld    hl, (curlineno)  ; get the current EDIT lineno
    2051/    8A1B : CD C9 A1                            call  print_HL         ; emit it
    2052/    8A1E : CD 64 84                            call  print_space      ; emit a space
    2053/    8A21 : C1                                  pop   bc               ; exit
    2054/    8A22 : E1                                  pop   hl
    2055/    8A23 : C9                                  ret
    2056/    8A24 :                     
    2057/    8A24 :                     ; process AUTO
    2058/    8A24 : D1                  exec_auto:      pop   de               ; discard resturn address
    2059/    8A25 : 11 0A 00                            ld    de, 10           ; load default start value
    2060/    8A28 : D5                                  push  de               ; push it for later
    2061/    8A29 : DC 85 86                            call  c, read_lineno   ; get a lineno into DE
    2062/    8A2C : EB                                  ex    de, hl           ; save curlineptr into DE
    2063/    8A2D :                                                            ; number read into DL
    2064/    8A2D : E3                                  ex    (sp), hl         ; set new start value, HL=10
    2065/    8A2E : EB                                  ex    de, hl           ; HL = curlineptr
    2066/    8A2F :                                                            ; DE = 10 (increment unless second arg follows)
    2067/    8A2F : FE 2C                               cp    CHAR_COMMA       ; another arg follows?
    2068/    8A31 : 20 06                               jr    nz, loc_D39      ; no, skip, assume increment=10 (DE)
    2069/    8A33 : CD 47 86                            call  nextchar         ; advance
    2070/    8A36 : DC 85 86                            call  c, read_lineno   ; read stepping value into DE
    2071/    8A39 : B7                  loc_D39:        or    a                ; now EOLN?
    2072/    8A3A : C2 6D 81                            jp    nz, syntax_error ; no, error
    2073/    8A3D : ED 53 9C 0C                         ld    (auto_increment), de ; save as auto increment
    2074/    8A41 : 7A                                  ld    a, d             ; if zero, error
    2075/    8A42 : B3                                  or    e
    2076/    8A43 : CA 6D 81                            jp    z, syntax_error
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 38 - 8/15/2019 11:33:6


    2077/    8A46 : 3E 01                               ld    a, 1             ; set AUTO mode
    2078/    8A48 : 32 AB 0C                            ld    (prompt_flag), a
    2079/    8A4B : E1                                  pop   hl               ; restore step width
    2080/    8A4C : C3 C3 81                            jp    auto
    2081/    8A4F :                     
    2082/    8A4F : (MACRO)             exec_lineinput: EXPECT TOKEN_INPUT     ; expect following input token
    2082/    8A4F : 3E 84                               ld    a, TOKEN_INPUT
    2082/    8A51 : CD 51 81                            call  expect_char
    2083/    8A54 : F6                                  db    0F6h             ; OR xxxx to skip next instruction
    2084/    8A55 :                                                            ; also ensure A != 0 for string input
    2085/    8A55 :                     
    2086/    8A55 : AF                  exec_input:     xor    a               ;** set flag=numeric
    2087/    8A56 : F5                                  push  af
    2088/    8A57 : 7E                                  ld    a, (hl)          ; get current char
    2089/    8A58 : FE 22                               cp    CHAR_QUOTE       ; is it a string?, e.g. INPUT "Enter data";A,B
    2090/    8A5A : 3E 00                               ld    a, 0             ; enable I/O
    2091/    8A5C : 32 00 0C                            ld    (iosuppress), a
    2092/    8A5F : 20 0D                               jr    nz, loc_D6E      ; no, skip
    2093/    8A61 : CD EE 90                            call  copy_strconst    ; get the string to output
    2094/    8A64 : (MACRO)                             EXPECT CHAR_SEMI       ; expect a semicolon
    2094/    8A64 : 3E 3B                               ld    a, CHAR_SEMI
    2094/    8A66 : CD 51 81                            call  expect_char
    2095/    8A69 : E5                                  push  hl               ; save curlineptr
    2096/    8A6A : CD 34 91                            call  straccu_print    ; print the string message
    2097/    8A6D : E1                                  pop   hl               ; restore curlineptr
    2098/    8A6E : E3                  loc_D6E:        ex    (sp), hl         ; insert curlineptr on stack
    2099/    8A6F :                                                            ; top of stack is cntr
    2100/    8A6F : E5                                  push  hl
    2101/    8A70 : CD 9C 90                            call  assert_run_program ; trigger ILLEGAL DIRECT error, 
    2102/    8A73 :                                                            ; unless in program
    2103/    8A73 : CD E2 83                            call  get_input        ; print a ? and request an inputbuf
    2104/    8A76 : CA 8E 86                            jp    z, input_ctrlc   ; CTRL-C? yes exit
    2105/    8A79 : F1                                  pop   af               ; restore type flag
    2106/    8A7A : 28 2F                               jr    z, read_input    ; if coming from INPUT, use READ
    2107/    8A7C :                                                            ; routine to request input
    2108/    8A7C : E3                  loopD7C:        ex    (sp), hl         ;<+ no, this comes from LINEINPUT
    2109/    8A7D :                     				                       ; | HL is curlineptr
    2110/    8A7D : CD 6A 8D                            call  find_var         ; | get a variable
    2111/    8A80 : CD 89 8B                            call  assert_string    ; | verify it is a string variable
    2112/    8A83 : E3                                  ex    (sp), hl         ; | put curlineptr on stack again
    2113/    8A84 : D5                                  push  de               ; | save variable address
    2114/    8A85 : 06 00                               ld    b, 0             ; | string terminator (0), i.e. until 
    2115/    8A87 :                                                            ; | end of buf
    2116/    8A87 : CD F0 90                            call  copy_0string     ; | copy a string
    2117/    8A8A : EB                                  ex    de, hl           ; | save ptr to inputbuf
    2118/    8A8B : 21 93 8A                            ld    hl, loc_D93      ; | push handler
    2119/    8A8E : E3                                  ex    (sp), hl         ; | HL is curlineptr
    2120/    8A8F : D5                                  push  de               ; | save inputbufptr
    2121/    8A90 : C3 4D 88                            jp    store_string     ; | 
    2122/    8A93 : E1                  loc_D93:        pop   hl               ; | restore curlineptr
    2123/    8A94 : CD 48 86                            call  skipspace        ; | advance
    2124/    8A97 : C8                                  ret   z                ; | end of line? exit
    2125/    8A98 : (MACRO)                             EXPECT CHAR_COMMA      ; | require a comma
    2125/    8A98 : 3E 2C                               ld    a, CHAR_COMMA
    2125/    8A9A : CD 51 81                            call  expect_char
    2126/    8A9D : E5                                  push  hl               ; | save curlineptr
    2127/    8A9E : CD DD 83                            call  get_moreinput    ; | print ?? andget an inputbuf
    2128/    8AA1 : CA 8F 86                            jp    z, input_ctrlc1  ; | exit if CTRL-C
    2129/    8AA4 : 18 D6                               jr    loopD7C          ;-+ loop
    2130/    8AA6 :                     
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 39 - 8/15/2019 11:33:6


    2131/    8AA6 : E5                  exec_read:      push  hl               ; save curlineptr
    2132/    8AA7 : 2A 64 0C                            ld    hl, (data_ptr)   ; get ptr to current data item to read
    2133/    8AAA : F6                                  db    0F6h             ; OR xxxx to skip next instruction
    2134/    8AAB : AF                  read_input:     xor   a                ; ** skipped, enters here from exec_input
    2135/    8AAC : 32 4F 0C                            ld    (input_read_flag), a ; flag: != 0 if coming from READ,
    2136/    8AAF :                                                            ; = 0 if coming from INPUT
    2137/    8AAF : E3                                  ex    (sp), hl         ; stack is data_ptr
    2138/    8AB0 :                                                            ; HL is    curlineptr
    2139/    8AB0 : 18 05                               jr    loc_DB7          ; skip
    2140/    8AB2 : (MACRO)             loc_DB2:        EXPECT CHAR_COMMA      ; expect a comma
    2140/    8AB2 : 3E 2C                               ld    a, CHAR_COMMA
    2140/    8AB4 : CD 51 81                            call  expect_char
    2141/    8AB7 : CD 6A 8D            loc_DB7:        call  find_var         ; get variable name, payload address in DE
    2142/    8ABA : E3                                  ex    (sp), hl         ; stack is curlineptr
    2143/    8ABB :                                                            ; HL is data_ptr
    2144/    8ABB : D5                                  push  de               ; save address of variable
    2145/    8ABC : 7E                                  ld    a, (hl)          ; get char from data_ptr
    2146/    8ABD : FE 2C                               cp    CHAR_COMMA       ; is it comma?
    2147/    8ABF : 28 0C                               jr    z, get_next_dataitem ; yes, advance
    2148/    8AC1 : 3A 4F 0C                            ld    a, (input_read_flag) ; get input/read flag
    2149/    8AC4 : B7                                  or    a
    2150/    8AC5 : 20 54                               jr    nz, find_next_DATA ; comes from READ, skip
    2151/    8AC7 : CD DD 83                            call  get_moreinput    ; INPUT: not enough data, query    more
    2152/    8ACA : CA 8E 86                            jp    z, input_ctrlc   ; if CTRL-C, leave
    2153/    8ACD :                     get_next_dataitem:            
    2154/    8ACD : 3A 02 0C                            ld    a, (expr_type)   ; get required expression
    2155/    8AD0 : B7                                  or	a
    2156/    8AD1 : 28 1A                               jr    z, get_numeric_data ; is numeric, skip
    2157/    8AD3 : CD 47 86                            call  nextchar         ; advance in DATA/INPUT    buf
    2158/    8AD6 : 57                                  ld    d, a             ; save as delimiters
    2159/    8AD7 : 47                                  ld    b, a
    2160/    8AD8 : FE 22                               cp    CHAR_QUOTE       ; is it a dbl quote?
    2161/    8ADA : 28 05                               jr    z, loc_DE1       ; yes, skip
    2162/    8ADC : 16 3A                               ld    d, CHAR_COLON    ; no, set line delimiter (:) and comma delimiter
    2163/    8ADE : 06 2C                               ld    b, CHAR_COMMA
    2164/    8AE0 : 2B                                  dec   hl               ; point to start of string
    2165/    8AE1 : CD F1 90            loc_DE1:        call  copy_string1     ; copy a string into straccu
    2166/    8AE4 : EB                                  ex    de, hl           ; save ptr to data/input
    2167/    8AE5 : 21 F8 8A                            ld    hl, data_handler ; insert DATA/INPUT handler return
    2168/    8AE8 : E3                                  ex    (sp), hl         ; stack is handler
    2169/    8AE9 :                                                            ; HL is address of variable
    2170/    8AE9 : D5                                  push  de               ; save data/input ptr
    2171/    8AEA : C3 4D 88                            jp    store_string     ; copy string to payload address in HL
    2172/    8AED :                                                            ; and continue at data_handler
    2173/    8AED :                     get_numeric_data:            
    2174/    8AED : CD 47 86                            call  nextchar         ; get next char
    2175/    8AF0 : CD DE A0                            call  parse_number_fpaccu ; get a number into fpaccu
    2176/    8AF3 : E3                                  ex    (sp), hl         ; stack is data ptr
    2177/    8AF4 :                                                            ; HL is address of variable
    2178/    8AF4 : CD 16 A0                            call  fpaccu_to_mem    ; save number read
    2179/    8AF7 : E1                                  pop   hl               ; restore data ptr
    2180/    8AF8 :                     data_handler:                          ; advance to next input data
    2181/    8AF8 : CD 48 86                            call  skipspace
    2182/    8AFB : 28 05                               jr    z, loc_E02       ; end of input, skip
    2183/    8AFD : FE 2C                               cp    CHAR_COMMA       ; comma follows?
    2184/    8AFF : C2 57 81                            jp    nz, invalid_input ; no, notify invalid input (INPUT)
    2185/    8B02 :                                                            ; or syntax error (READ)
    2186/    8B02 : E3                  loc_E02:        ex    (sp), hl         ; stack is data_ptr
    2187/    8B03 :                     				                       ; HL is curlineptr
    2188/    8B03 : CD 48 86                            call  skipspace        ; advance to next READ/INPUT variable
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 40 - 8/15/2019 11:33:6


    2189/    8B06 : 20 AA                               jr    nz, loc_DB2      ; if not end of line, loop
    2190/    8B08 : D1                                  pop   de               ; restore data ptr
    2191/    8B09 : 3A 4F 0C                            ld    a, (input_read_flag) ; get mode flag
    2192/    8B0C : B7                                  or    a
    2193/    8B0D : EB                                  ex    de, hl           ; HL is input line ptr
    2194/    8B0E :                                                            ; DE is curlineptr
    2195/    8B0E : C2 80 86                            jp    nz, set_dataptr1 ; is data, save new data_ptr andexit
    2196/    8B11 : B6                                  or	(hl)		;char from input line to set flags
    2197/    8B12 : 21 A3 AC                            ld    hl, a_extralost  ; load EXTRA LOST message
    2198/    8B15 : D5                                  push  de               ; save curlineptr
    2199/    8B16 : C4 BD 84                            call  nz, print_string ; if more chars in input line,
    2200/    8B19 :                                                            ; print *EXTRA_LOST*
    2201/    8B19 : E1                                  pop   hl               ; restore curlineptr
    2202/    8B1A : C9                                  ret                    ; done
    2203/    8B1B :                     
    2204/    8B1B :                     ; HL is data_ptr, find the next DATA statement
    2205/    8B1B :                     find_next_DATA:
    2206/    8B1B : CD 0B 88                            call  exec_data        ; end of DATA line, advance to next DATA
    2207/    8B1E : B7                                  or    a                ; end of line?
    2208/    8B1F : 20 10                               jr    nz, loc_E31      ; no, advance
    2209/    8B21 : 23                                  inc   hl               ; at end of line, go to next char
    2210/    8B22 : 7E                                  ld    a, (hl)          ; is the link 0?
    2211/    8B23 : 23                                  inc   hl
    2212/    8B24 : B6                                  or    (hl)
    2213/    8B25 : 1E 04                               ld    e, 4             ; load OUT OF DATA error code
    2214/    8B27 : 28 69                               jr    z, loc_E92       ; link, is 0, error
    2215/    8B29 : 23                                  inc   hl               ; advance and get current lineno
    2216/    8B2A : (MACRO)                             LDDE_M       
    2216/    8B2A : 5E                                  ld    e, (hl)
    2216/    8B2B : 23                                  inc   hl
    2216/    8B2C : 56                                  ld    d, (hl)
    2217/    8B2D : ED 53 4C 0C                         ld    (currentlineno), de ; save it
    2218/    8B31 : CD 47 86            loc_E31:        call  nextchar         ; get next char
    2219/    8B34 : FE 83                               cp    TOKEN_DATA       ; is it a DATA token?
    2220/    8B36 : 20 E3                               jr    nz, find_next_DATA ; no, advance until found
    2221/    8B38 : C3 CD 8A                            jp    get_next_dataitem ; yes, found one, continue READ
    2222/    8B3B :                     
    2223/    8B3B :                     ; process NEXT
    2224/    8B3B : 11 00 00            exec_next:      ld    de, 0            ; preload zero variable name
    2225/    8B3E : C4 6A 8D            sub_E3E:        call  nz, find_var     ; if not EOLN, find the named variable
    2226/    8B41 : 22 50 0C                            ld    (curlineptr), hl ; save curlineptr
    2227/    8B44 : CD F6 80                            call  discard_open_forloops ; discard loops
    2228/    8B47 : C2 7C 81                            jp    nz, next_wo_for_error ; didn't find a FORSTRUCT? error
    2229/    8B4A : F9                                  ld    sp, hl           ; correct stack level
    2230/    8B4B : D5                                  push  de               ; push address of var
    2231/    8B4C : 7E                                  ld    a, (hl)          ; load UP/DOWN marker
    2232/    8B4D : 23                                  inc   hl               ; advance, point to step value now
    2233/    8B4E : F5                                  push  af               ; save up/down
    2234/    8B4F : D5                                  push  de               ; push address of var
    2235/    8B50 : CD EC 9F                            call  mem_to_fpaccu    ; load step value in fpaccu, add6 to HL
    2236/    8B53 : E3                                  ex    (sp), hl         ; HL = address of var
    2237/    8B54 :                                                            ; STACK = address of end value
    2238/    8B54 : E5                                  push  hl               ; push var
    2239/    8B55 : CD 83 9C                            call  load_and_add_fpaccu ; add step to variable
    2240/    8B58 : E1                                  pop   hl               ; restore address of var
    2241/    8B59 : CD 16 A0                            call  fpaccu_to_mem    ; move result back into for variable
    2242/    8B5C : E1                                  pop   hl               ; load variable in fpreg
    2243/    8B5D : CD 05 A0                            call  load_fpreg
    2244/    8B60 : E5                                  push  hl               ; save address of end value
    2245/    8B61 : CD 36 A0                            call  fpaccu_compare
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 41 - 8/15/2019 11:33:6


    2246/    8B64 : E1                                  pop   hl               ; restore ptr to end value
    2247/    8B65 : C1                                  pop   bc               ; restore UP/DOWN flag in B
    2248/    8B66 : 90                                  sub   b
    2249/    8B67 : CD 6C A0                            call  restore_de_bc    ; DE = lineno, BC = curlineptr
    2250/    8B6A : 28 09                               jr    z, loc_E75       ; loop ended, continue
    2251/    8B6C : EB                                  ex    de, hl           ; save new line number
    2252/    8B6D : 22 54 0C                            ld    (lineno), hl
    2253/    8B70 :                                     ;LDHL_BC                ; load curlineptr
    2254/    8B70 : 69                                  ld	l,c
    2255/    8B71 : 60                                  ld	h,b
    2256/    8B72 : C3 C8 85                            jp    loc_8C8          ; put up FOR marker again, set SP and
    2257/    8B75 :                                                            ; continue processing
    2258/    8B75 : F9                  loc_E75:        ld    sp, hl           ; adjust stack (discard this loop)
    2259/    8B76 : 2A 50 0C                            ld    hl, (curlineptr) ; restore curlineptr
    2260/    8B79 : 7E                                  ld    a, (hl)          ; get char
    2261/    8B7A : FE 2C                               cp    CHAR_COMMA       ; a NEXT X,Y ?
    2262/    8B7C : C2 CC 85                            jp    nz, command_done ; no, continue processing
    2263/    8B7F : CD 47 86                            call  nextchar         ; get next char
    2264/    8B82 : CD 3E 8B                            call  sub_E3E          ; recurse into NEXT processing
    2265/    8B85 :                     
    2266/    8B85 :                     ; evaluate an expression, result in fpaccu
    2267/    8B85 : CD 9A 8B            expression:     call  expression1
    2268/    8B88 :                     
    2269/    8B88 : F6                  assert_numeric: db    0F6h             ; OR xx to skip next instruction
    2270/    8B89 :                                                            ; clears CY
    2271/    8B89 : 37                  assert_string:  scf                    ;** set CY for string type
    2272/    8B8A :                     
    2273/    8B8A :                     ; CY = 0 for numeric, 1 for string type required
    2274/    8B8A :                     verify_exprtype:
    2275/    8B8A : 3A 02 0C                            ld    a, (expr_type)   ; get expression type of last expression
    2276/    8B8D : 8F                                  adc   a, a             ; add CY
    2277/    8B8E : B7                                  or    a                ; test result
    2278/    8B8F : E8                                  ret   pe               ; okay?
    2279/    8B90 :                     type_mismatch_error:                   ; no, types don't match
    2280/    8B90 : 1E 0D                               ld    e, 13
    2281/    8B92 : C3 7E 81            loc_E92:        jp    print_error
    2282/    8B95 :                     
    2283/    8B95 :                     string_expression1:
    2284/    8B95 : CD 9A 8B                            call  expression1
    2285/    8B98 : 18 EF                               jr    assert_string
    2286/    8B9A :                     
    2287/    8B9A :                     ; evaluate expression
    2288/    8B9A : 2B                  expression1:    dec   hl               ; point to char before expression
    2289/    8B9B : 16 00                               ld    d, 0             ; precedence
    2290/    8B9D :                     ; highly recursive expression handler
    2291/    8B9D : D5                  expresssion2:   push  de               ; save precedence
    2292/    8B9E : 0E 01                               ld    c, 1
    2293/    8BA0 : CD 31 81                            call  verify_space     ; verify still 2 bytes free
    2294/    8BA3 : CD 14 8C                            call  expr             ; calculate an expression
    2295/    8BA6 : 22 52 0C                            ld    (lineptrsave), hl
    2296/    8BA9 : 2A 52 0C            loc_EA9:        ld    hl, (lineptrsave)
    2297/    8BAC : C1                  loc_EAC:        pop   bc               ; restore precedence
    2298/    8BAD : 78                                  ld    a, b             ; into A
    2299/    8BAE : FE 78                               cp    PREC_RELOP
    2300/    8BB0 : D4 88 8B                            call  nc, assert_numeric ; result must be numeric
    2301/    8BB3 : 7E                                  ld    a, (hl)          ; get current char in line
    2302/    8BB4 : 16 00                               ld    d, 0             ; initialize relation flag
    2303/    8BB6 :                     loopEB6:                               ;<+ subtract token '>'
    2304/    8BB6 : D6 AC                               sub   TOKEN_GREATER    ; | '<' is 0
    2305/    8BB8 :                                                            ; | '=' is 1
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 42 - 8/15/2019 11:33:6


    2306/    8BB8 :                                                            ; | '>' is 2
    2307/    8BB8 : 38 15                               jr    c, loc_ECF       ; | is it lower?
    2308/    8BBA : FE 03                               cp    3                ; | is it above token '<'?
    2309/    8BBC : 30 11                               jr    nc, loc_ECF      ; | no not comparison
    2310/    8BBE : FE 01                               cp    1                ; | is it '='? set CY if less
    2311/    8BC0 : 17                                  rla                    ; | and shift
    2312/    8BC1 :                                                            ; | '<' is 001
    2313/    8BC1 :                                                            ; | '=' is 010
    2314/    8BC1 :                                                            ; | '>' is 100
    2315/    8BC1 : AA                                  xor    d               ; | xor with previous comparison value
    2316/    8BC2 :                                                            ; | <> or >< is 101
    2317/    8BC2 :                                                            ; | <= or =< is 011
    2318/    8BC2 :                                                            ; | >= or => is 110
    2319/    8BC2 : BA                                  cp    d                ; | compare with previous
    2320/    8BC3 : 57                                  ld    d, a             ; | and store as new compare value
    2321/    8BC4 : DA 6D 81                            jp    c, syntax_error  ; | did the value decrease, e.g. by
    2322/    8BC7 :                                                            ; | invalid '=' '='?
    2323/    8BC7 :                                                            ; | yes, error
    2324/    8BC7 : 22 4A 0C                            ld    (arrayvalptr), hl ;| save curlineptr
    2325/    8BCA : CD 47 86                            call  nextchar         ; | get next char
    2326/    8BCD : 18 E7                               jr    loopEB6          ;-+ loop comparison operator
    2327/    8BCF :                     ; has expression and a relational operator in D
    2328/    8BCF : 7A                  loc_ECF:        ld    a, d             ; get compare operator
    2329/    8BD0 : B7                                  or    a                ; was zero, not a relational operator
    2330/    8BD1 : C2 E2 8C                            jp    nz, expr_compare
    2331/    8BD4 : 7E                                  ld    a, (hl)          ; store end of relational operator
    2332/    8BD5 : 22 4A 0C                            ld    (arrayvalptr), hl
    2333/    8BD8 : D6 A5                               sub   TOKEN_PLUS       ; subtract '+' token
    2334/    8BDA : D8                                  ret   c                ; exit if less than '+'
    2335/    8BDB : FE 07                               cp    7                ; check if '+', '-', '*', '/', '^', 'AND', 'OR'
    2336/    8BDD : D0                                  ret   nc               ; no, above or equal, exit
    2337/    8BDE : 5F                                  ld    e, a             ; store dyadic operator in E
    2338/    8BDF :                                                            ; '+' is 0
    2339/    8BDF :                                                            ; '-' is 1
    2340/    8BDF :                                                            ; '*' is 2
    2341/    8BDF :                                                            ; '/' is 3
    2342/    8BDF :                                                            ; '^' is 4
    2343/    8BDF :                                                            ; AND is 5
    2344/    8BDF :                                                            ; OR  is 6
    2345/    8BDF : 3A 02 0C                            ld    a, (expr_type)   ; get expression type
    2346/    8BE2 : 3D                                  dec   a                ; FF=numeric, 0=string
    2347/    8BE3 : B3                                  or    e                ; becomes 0 for string addition, FF otherwise
    2348/    8BE4 : 7B                                  ld    a, e             ; get operator
    2349/    8BE5 : CA 12 92                            jp    z, string_add    ; handle string addition
    2350/    8BE8 : 07                                  rlca
    2351/    8BE9 : 83                                  add   a, e             ; multiply with 3
    2352/    8BEA : 5F                                  ld    e, a             ; into E
    2353/    8BEB :                                                            ; note: D=0 because it was no relational operator
    2354/    8BEB : 21 61 80                            ld    hl, oper_tbl     ; load operator table
    2355/    8BEE : 19                                  add   hl, de           ; add index
    2356/    8BEF : 78                                  ld    a, b             ; get current precedence
    2357/    8BF0 : 56                                  ld    d, (hl)          ; get precedence of new operator
    2358/    8BF1 : BA                                  cp    d                ; compare curprec - newprec
    2359/    8BF2 : D0                                  ret   nc               ; above or equal, exit
    2360/    8BF3 : 23                                  inc   hl               ; advance to next char
    2361/    8BF4 : CD 88 8B                            call  assert_numeric   ; require current subexpression is numeric
    2362/    8BF7 : C5                  loc_EF7:        push  bc               ; save precedence
    2363/    8BF8 : 01 A9 8B                            ld    bc, loc_EA9      ; push expression loop
    2364/    8BFB : C5                                  push  bc               ; as return
    2365/    8BFC : ED 4B 66 0C                         ld    bc, (fpaccu_mant32) ; push current accu on stack
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 43 - 8/15/2019 11:33:6


    2366/    8C00 : C5                                  push  bc
    2367/    8C01 : ED 4B 68 0C                         ld    bc, (fpaccu_mant54)
    2368/    8C05 : C5                                  push  bc
    2369/    8C06 : ED 4B 6A 0C                         ld    bc, (fpaccu_mant6)
    2370/    8C0A : C5                                  push  bc
    2371/    8C0B : (MACRO)                             LDBC_M                 ; get operator handler
    2371/    8C0B : 4E                                  ld    c, (hl)
    2371/    8C0C : 23                                  inc   hl
    2371/    8C0D : 46                                  ld    b, (hl)
    2372/    8C0E : C5                                  push  bc               ; push it, to be called at the end of expression
    2373/    8C0F : 2A 4A 0C                            ld    hl, (arrayvalptr) ; restore ptr to start
    2374/    8C12 :                                                            ; of second operandexpression
    2375/    8C12 : 18 89                               jr    expresssion2
    2376/    8C14 :                     
    2377/    8C14 :                     ; process single expression
    2378/    8C14 :                     ; including functions
    2379/    8C14 :                     ;
    2380/    8C14 :                     ; precedence:
    2381/    8C14 :                     ; 0x46:    OR
    2382/    8C14 :                     ; 0x50:    AND
    2383/    8C14 :                     ; 0x5a:    NOT
    2384/    8C14 :                     ; 0x78:    relational ops
    2385/    8C14 :                     ; 0x79:    dyadic '+', '-'
    2386/    8C14 :                     ; 0x7c:    '*', '/'
    2387/    8C14 :                     ; 0x7d:    monadic    '-'
    2388/    8C14 :                     ; 0x7f:    '^'
    2389/    8C14 : AF                  expr:           xor    a               ; set expression type = numeric
    2390/    8C15 : 32 02 0C                            ld    (expr_type), a
    2391/    8C18 : CD 47 86                            call  nextchar         ; get char
    2392/    8C1B : DA E3 A0                            jp    c, expr_numeric  ; is numeric?, yes skip
    2393/    8C1E : CD 14 87                            call  check_alpha
    2394/    8C21 : 30 44                               jr    nc, expr_alpha   ; yes is letter
    2395/    8C23 : FE A5                               cp    TOKEN_PLUS       ; is token '+' ?
    2396/    8C25 : 28 ED                               jr    z, expr          ; yes, ignore it
    2397/    8C27 : FE 2E                               cp    CHAR_PERIOD      ; is a minus?
    2398/    8C29 : CA E3 A0                            jp    z, expr_numeric
    2399/    8C2C : FE A6                               cp    TOKEN_MINUS      ; is token '-'?
    2400/    8C2E : 28 26                               jr    z, expr_minus
    2401/    8C30 : FE 22                               cp    CHAR_QUOTE       ; is string delimiter?
    2402/    8C32 : CA EE 90                            jp    z, copy_strconst
    2403/    8C35 : FE A3                               cp    TOKEN_NOT        ; is token NOT
    2404/    8C37 : CA 45 8D                            jp    z, expr_not
    2405/    8C3A : FE A0                               cp    TOKEN_FN         ; is token FN?
    2406/    8C3C : CA 6C 8F                            jp    z, expr_fn
    2407/    8C3F : FE 26                               cp    CHAR_AMP         ; is & ?
    2408/    8C41 : CA 71 A1                            jp    z, expr_hex
    2409/    8C44 : D6 AF                               sub   TOKEN_SGN        ; subtract token SGN
    2410/    8C46 : 30 30                               jr    nc, expr_function ; is above or equal, i.e. a function
    2411/    8C48 :                     expr_paren:
    2412/    8C48 : (MACRO)                             EXPECT CHAR_LPAREN     ; expect an opening parenthesis
    2412/    8C48 : 3E 28                               ld    a, CHAR_LPAREN
    2412/    8C4A : CD 51 81                            call  expect_char
    2413/    8C4D : CD 9A 8B                            call  expression1      ; evaluate expression
    2414/    8C50 : (MACRO)                             EXPECT CHAR_RPAREN     ; expect closing parenthesis
    2414/    8C50 : 3E 29                               ld    a, CHAR_RPAREN
    2414/    8C52 : CD 51 81                            call  expect_char
    2415/    8C55 : C9                                  ret                    ; exit, result is in fpaccu
    2416/    8C56 :                     
    2417/    8C56 :                     expr_minus:
    2418/    8C56 : 16 7D                               ld    d, PREC_MINUS    ; set precedence
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 44 - 8/15/2019 11:33:6


    2419/    8C58 : CD 9D 8B                            call  expresssion2     ; recurse evaluator
    2420/    8C5B : 2A 52 0C                            ld    hl, (lineptrsave)
    2421/    8C5E : E5                                  push  hl
    2422/    8C5F : CD D2 9F                            call  fpaccu_changesign
    2423/    8C62 : CD 88 8B            loc_F62:        call  assert_numeric   ; verify numeric result
    2424/    8C65 : E1                                  pop   hl
    2425/    8C66 : C9                                  ret
    2426/    8C67 :                     
    2427/    8C67 : CD 6A 8D            expr_alpha:     call  find_var         ; locate variable, return address
    2428/    8C6A :                                                            ; of value/descriptor
    2429/    8C6A : E5                  loc_F6A:        push  hl               ; save curlineptr
    2430/    8C6B : EB                                  ex    de, hl           ; get payload address in DE
    2431/    8C6C : 22 66 0C                            ld    (fpaccu_mant32), hl ; store string descriptor in accu
    2432/    8C6F : 3A 02 0C                            ld    a, (expr_type)   ; get type of variable
    2433/    8C72 : B7                                  or    a
    2434/    8C73 : CC EC 9F                            call  z, mem_to_fpaccu ; if numeric, copy value into FPaccu
    2435/    8C76 : E1                                  pop   hl               ; restore curlineptr
    2436/    8C77 : C9                                  ret
    2437/    8C78 :                     
    2438/    8C78 : 06 00               expr_function:  ld    b, 0             ; high value
    2439/    8C7A : 07                                  rlca                   ; multiply function token (minus TOKEN_SGN) with 2
    2440/    8C7B : 4F                                  ld    c, a             ; make 16 bit
    2441/    8C7C : C5                                  push  bc               ; save offset to func table
    2442/    8C7D : CD 47 86                            call  nextchar         ; get next char
    2443/    8C80 : 79                                  ld    a, c
    2444/    8C81 : FE 29                               cp    2*(TOKEN_CHRS-TOKEN_SGN)+1 ; less than CHR$()?
    2445/    8C83 : 38 26                               jr    c, loc_FAB       ; yes, handle single parenthesis
    2446/    8C85 : FE 30                               cp    2*(TOKEN_LPOS-TOKEN_SGN) ; is LPOS?
    2447/    8C87 : 28 22                               jr    z, loc_FAB       ; yes, handle single parenthesis
    2448/    8C89 : FE 32                               cp    2*(TOKEN_INSTR-TOKEN_SGN) ; is INSTR?
    2449/    8C8B : 28 1B                               jr    z, loc_FA8       ; yes, skip
    2450/    8C8D : D2 44 87                            jp    nc, illfunc_error ; above or equal? not a function token
    2451/    8C90 :                                                            ; here we have string functions
    2452/    8C90 :                                                            ; with more than one argument
    2453/    8C90 : (MACRO)                             EXPECT CHAR_LPAREN    ; expect opening parenthesis
    2453/    8C90 : 3E 28                               ld    a, CHAR_LPAREN
    2453/    8C92 : CD 51 81                            call  expect_char
    2454/    8C95 : CD 95 8B                            call  string_expression1 ; get a string expression
    2455/    8C98 : (MACRO)                             EXPECT CHAR_COMMA      ; expect a second argument
    2455/    8C98 : 3E 2C                               ld    a, CHAR_COMMA
    2455/    8C9A : CD 51 81                            call  expect_char
    2456/    8C9D : EB                                  ex    de, hl           ; save curlineptr in DE
    2457/    8C9E : 2A 66 0C                            ld    hl, (fpaccu_mant32) ; get string descriptor in fpaccu
    2458/    8CA1 : E3                                  ex    (sp), hl         ; insert on stack
    2459/    8CA2 : E5                                  push  hl
    2460/    8CA3 : EB                                  ex    de, hl           ; restore curlineptr
    2461/    8CA4 : CD 1B 94                            call  expression_u8_ae ; get an 8 bit expression in E
    2462/    8CA7 : EB                                  ex    de, hl           ; into HL
    2463/    8CA8 : E3                  loc_FA8:        ex    (sp), hl         ; stack is 2nd arg of function
    2464/    8CA9 :                     				                       ; HL is offset to function table
    2465/    8CA9 : 18 08                               jr    loc_FB3
    2466/    8CAB : CD 48 8C            loc_FAB:        call  expr_paren       ; get single argument expression into fpaccu
    2467/    8CAE : E3                                  ex    (sp), hl         ; stack is curlineptr
    2468/    8CAF :                                                            ; HL is offset to function table
    2469/    8CAF : 11 62 8C                            ld    de, loc_F62      ; insert checker that result is numeric
    2470/    8CB2 : D5                                  push  de
    2471/    8CB3 : 01 2D 80            loc_FB3:        ld    bc, func_tbl     ; get function offset
    2472/    8CB6 : 09                                  add   hl, bc           ; add to function table
    2473/    8CB7 : (MACRO)                             LDHL_M C               ; get function handler address into HL
    2473/    8CB7 : 4E                                  ld    C, (hl)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 45 - 8/15/2019 11:33:6


    2473/    8CB8 : 23                                  inc   hl
    2473/    8CB9 : 66                                  ld    h, (hl)
    2473/    8CBA : 69                                  ld    l, C
    2474/    8CBB : E9                                  jp    (hl)             ; jump to it
    2475/    8CBC :                     
    2476/    8CBC :                     pop_fpreg_and_boolor:
    2477/    8CBC : F6                                  db    0F6h             ; OR xxxx to skip next instruction
    2478/    8CBD :                                                            ; ensure A is not zero
    2479/    8CBD :                     pop_fpreg_and_booland:
    2480/    8CBD : AF                                  xor    a               ;** skipped, clears A
    2481/    8CBE : F5                                  push  af               ; Z = 1 for AND, 0 for OR
    2482/    8CBF : CD 1C 87                            call  sub_A1C          ; get value from fpaccu
    2483/    8CC2 : F1                                  pop   af               ; restore AF
    2484/    8CC3 : EB                                  ex    de, hl           ; get 1st result in HL
    2485/    8CC4 : C1                                  pop   bc               ; restore operandon stack in BC, IX, DE
    2486/    8CC5 : DD E1                               pop   ix
    2487/    8CC7 : E3                                  ex    (sp), hl         ; put 1st result on stack
    2488/    8CC8 : EB                                  ex    de, hl           ; restore rest of fpreg
    2489/    8CC9 : CD F5 9F                            call  store_fpaccu     ; save in FPaccu
    2490/    8CCC : F5                                  push  af               ; save A
    2491/    8CCD : CD 2D 87                            call  fpaccu_to_16     ; get value from fpaccu into DE
    2492/    8CD0 : F1                                  pop   af               ; restore A
    2493/    8CD1 : C1                                  pop   bc               ; restore 1st result
    2494/    8CD2 : 79                                  ld    a, c             ; get first result low
    2495/    8CD3 : 21 1D 8F                            ld    hl, AC_to_fpaccu ; load routine of result copy routine
    2496/    8CD6 : 20 05                               jr    nz, boolor       ; was not zero, to OR operation
    2497/    8CD8 : A3                                  and   e                ; and of low part
    2498/    8CD9 : 4F                                  ld    c, a             ; into C
    2499/    8CDA : 78                                  ld    a, b             ; and of high part
    2500/    8CDB : A2                                  and   d
    2501/    8CDC : E9                                  jp    (hl)             ; copy result (AC_to_fpaccu)
    2502/    8CDD : B3                  boolor:         or    e                ; or of low part
    2503/    8CDE : 4F                                  ld    c, a             ; save
    2504/    8CDF : 78                                  ld    a, b             ; get high part
    2505/    8CE0 : B2                                  or    d                ; or of high part
    2506/    8CE1 : E9                                  jp    (hl)             ; copy result (AC_to_fpaccu)
    2507/    8CE2 :                     
    2508/    8CE2 :                     ; has compare operator in D:
    2509/    8CE2 :                     ; 001 <
    2510/    8CE2 :                     ; 010 =
    2511/    8CE2 :                     ; 011 <=
    2512/    8CE2 :                     ; 100 >
    2513/    8CE2 :                     ; 101 <>
    2514/    8CE2 :                     ; 110 >=
    2515/    8CE2 : 21 F4 8C            expr_compare:   ld    hl, compare_tbl  ; load handler
    2516/    8CE5 : 3A 02 0C                            ld    a, (expr_type)   ; get type of expression
    2517/    8CE8 : 1F                                  rra                    ; set CY for string
    2518/    8CE9 : 7A                                  ld    a, d             ; get condition
    2519/    8CEA : 17                                  rla                    ; shift in CY
    2520/    8CEB : 5F                                  ld    e, a             ; save in E
    2521/    8CEC : 16 64                               ld    d, PREC_STRCMP   ; set precedence
    2522/    8CEE : 78                                  ld    a, b
    2523/    8CEF : BA                                  cp    d                ; compare with current precedence
    2524/    8CF0 : D0                                  ret   nc               ; don't handle yet
    2525/    8CF1 : C3 F7 8B                            jp    loc_EF7          ; push on stack and get second operand
    2526/    8CF4 :                     
    2527/    8CF4 : F6 8C               compare_tbl:    dw    compare_handler  ; routine to handle comparison
    2528/    8CF6 :                     
    2529/    8CF6 :                     compare_handler:            
    2530/    8CF6 : 79                                  ld    a, c             ; get operation
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 46 - 8/15/2019 11:33:6


    2531/    8CF7 : B7                                  or    a                ; ensure CY = 0
    2532/    8CF8 : 1F                                  rra                    ; discard lowest bit, i.e. convert back
    2533/    8CF9 :                                                            ; to operation code
    2534/    8CF9 : (MACRO)                             POP_FPREG              ; pop 1st operand off stack
    2534/    8CF9 : C1                                  pop   bc
    2534/    8CFA : DD E1                               pop   ix
    2534/    8CFC : D1                                  pop   de
    2535/    8CFD : F5                                  push  af
    2536/    8CFE : CD 8A 8B                            call  verify_exprtype  ; check that types match
    2537/    8D01 : 21 3B 8D                            ld    hl, exit_compare ; push routine to call on exit
    2538/    8D04 : E5                                  push  hl
    2539/    8D05 : CA 36 A0                            jp    z, fpaccu_compare ; do comparison of numerics
    2540/    8D08 :                                                            ; will go to exit_compare on ret
    2541/    8D08 : AF                                  xor    a               ; string comparison
    2542/    8D09 : 32 02 0C                            ld    (expr_type), a   ; set expression result type numeric
    2543/    8D0C : D5                                  push  de               ; descriptor of second operand
    2544/    8D0D : CD 63 92                            call  fpaccu_getstr    ; get 2nd string descr in HL
    2545/    8D10 : D1                                  pop   de               ; restore 2nd descriptor
    2546/    8D11 : (MACRO)                             LDBC_M                 ; get string length into BC
    2546/    8D11 : 4E                                  ld    c, (hl)
    2546/    8D12 : 23                                  inc   hl
    2546/    8D13 : 46                                  ld    b, (hl)
    2547/    8D14 : 23                                  inc   hl
    2548/    8D15 : C5                                  push  bc               ; save
    2549/    8D16 : (MACRO)                             LDBC_M                 ; get string address into BC
    2549/    8D16 : 4E                                  ld    c, (hl)
    2549/    8D17 : 23                                  inc   hl
    2549/    8D18 : 46                                  ld    b, (hl)
    2550/    8D19 : C5                                  push  bc               ; save
    2551/    8D1A : CD 67 92                            call  peek_str_stringstk ; discard 1st string
    2552/    8D1D : CD 6C A0                            call  restore_de_bc    ; restore 1st string descr in
    2553/    8D20 :                                                            ; E=length / BC = string addr
    2554/    8D20 : E1                                  pop   hl               ; pop string address
    2555/    8D21 : E3                                  ex    (sp), hl         ; stack is string addr
    2556/    8D22 :                                                            ; HL is string length
    2557/    8D22 : 55                                  ld    d, l             ; get length into D
    2558/    8D23 : E1                                  pop   hl               ; HL is string addr
    2559/    8D24 : 7B                  loop1024:       ld    a, e             ;<+ both strings are empty? yes return Z=1
    2560/    8D25 : B2                                  or    d                ; | 
    2561/    8D26 : C8                                  ret   z                ; | yes exit with A=0
    2562/    8D27 : 7A                                  ld    a, d             ; | subtract 1 from length of 1st string
    2563/    8D28 : D6 01                               sub   1                ; | 
    2564/    8D2A : D8                                  ret   c                ; | cntr negative?
    2565/    8D2B : AF                                  xor    a               ; | clear A
    2566/    8D2C : BB                                  cp    e                ; | is other length also 0?
    2567/    8D2D : 3C                                  inc   a                ; | set A = 1
    2568/    8D2E : D0                                  ret   nc               ; | exit if 1st is longer
    2569/    8D2F : 15                                  dec   d                ; | decrement string lengths
    2570/    8D30 : 1D                                  dec   e                ; |
    2571/    8D31 : 0A                                  ld    a, (bc)          ; | compare strings
    2572/    8D32 : BE                                  cp    (hl)             ; |
    2573/    8D33 : 23                                  inc   hl               ; | advance to next string positions
    2574/    8D34 : 03                                  inc   bc               ; |
    2575/    8D35 : 28 ED                               jr    z, loop1024      ;-+ still same? yes loop
    2576/    8D37 : 3F                                  ccf                    ; complement CY
    2577/    8D38 : C3 CA 9F                            jp    loc_22CA         ; set A = FF or 1, depending on CY result
    2578/    8D3B : 3C                  exit_compare:   inc   a                ; adjust result to 0, 1, 2
    2579/    8D3C : 8F                                  adc   a, a             ; to 0, 2, 4
    2580/    8D3D : C1                                  pop   bc               ; restore compare operation
    2581/    8D3E : A0                                  and   b                ; mask result (will produce 1 <, 2 =, 4    >
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 47 - 8/15/2019 11:33:6


    2582/    8D3F : C6 FF                               add   a, 0FFh          ; adjust to 0, 1, 3
    2583/    8D41 : 9F                                  sbc   a, a             ; subtract CY -> -1,    0, 2
    2584/    8D42 : C3 A6 9F                            jp    s8_to_fp         ; convert into numeric result
    2585/    8D45 :                     
    2586/    8D45 : 16 5A               expr_not:       ld    d, PREC_NOT      ; set precedence
    2587/    8D47 : CD 9D 8B                            call  expresssion2     ; get expression
    2588/    8D4A : CD 88 8B                            call  assert_numeric   ; require it to be numeric
    2589/    8D4D : CD 2D 87                            call  fpaccu_to_16     ; convert to 16 bit
    2590/    8D50 : 7B                                  ld    a, e             ; complement
    2591/    8D51 : 2F                                  cpl                    ; E is low value
    2592/    8D52 : 4F                                  ld    c, a
    2593/    8D53 : 7A                                  ld    a, d
    2594/    8D54 : 2F                                  cpl                    ; A is high value
    2595/    8D55 : CD 1D 8F                            call  AC_to_fpaccu     ; convert to numeric
    2596/    8D58 : C1                                  pop   bc               ; discard caller
    2597/    8D59 : C3 A9 8B                            jp    loc_EA9          ; jump back into expression
    2598/    8D5C :                     
    2599/    8D5C : CD 48 86            dim_loop:       call  skipspace        ; skip white space
    2600/    8D5F : C8                                  ret   z                ; end of line, exit
    2601/    8D60 : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    2601/    8D60 : 3E 2C                               ld    a, CHAR_COMMA
    2601/    8D62 : CD 51 81                            call  expect_char
    2602/    8D65 :                     
    2603/    8D65 : 01 5C 8D            exec_dim:       ld    bc, dim_loop     ; stay in DIM
    2604/    8D68 : C5                                  push  bc
    2605/    8D69 : F6                                  db    0F6h             ; OR 0AFh instruction, sets dim_flag
    2606/    8D6A :                                                            ; for DIM to non-zero
    2607/    8D6A :                     
    2608/    8D6A :                     ; find anddefine variable pointed to by HL
    2609/    8D6A :                     ; return payload address in DE
    2610/    8D6A : AF                  find_var:       xor    a               ; clear dim_flag (non-zero if declaring arrays)
    2611/    8D6B : 32 01 0C                            ld    (dim_flag), a    ; set by exec_dim
    2612/    8D6E : 46                                  ld    b, (hl)          ; get 1st char of variable
    2613/    8D6F : CD 14 87            loc_106F:       call  check_alpha      ; error, if not alpha
    2614/    8D72 : DA 6D 81                            jp    c, syntax_error
    2615/    8D75 : AF                                  xor   a                ; preload 2nd letter
    2616/    8D76 : 4F                                  ld    c, a             ; clear expression type
    2617/    8D77 : 32 02 0C                            ld    (expr_type), a
    2618/    8D7A : CD 47 86                            call  nextchar         ; get a char
    2619/    8D7D : 38 05                               jr    c, loc_1084      ; numeric, skip
    2620/    8D7F : CD 14 87                            call  check_alpha      ; second letter alpha?
    2621/    8D82 : 38 0B                               jr    c, loc_108F      ; no, skip
    2622/    8D84 : 4F                  loc_1084:       ld    c, a             ; store second letter
    2623/    8D85 :                     loop1085:                              ;<+ ignore following variable characters
    2624/    8D85 : CD 47 86                            call  nextchar         ; | only two are significant
    2625/    8D88 : 38 FB                               jr    c, loop1085      ;>+ numeric, ignore
    2626/    8D8A : CD 14 87                            call  check_alpha      ; | alpha, ignore
    2627/    8D8D : 30 F6                               jr    nc, loop1085     ;-+
    2628/    8D8F :                     loc_108F:                
    2629/    8D8F : D6 24                               sub   CHAR_DOLLAR      ; is it a string variable?
    2630/    8D91 : 20 09                               jr    nz, loc_109C     ; no, numeric
    2631/    8D93 : 3C                                  inc   a                ; set expression type = string (1)
    2632/    8D94 : 32 02 0C                            ld    (expr_type), a
    2633/    8D97 : CB F9                               set    7, c            ; set bit 7 to mark string variable
    2634/    8D99 : CD 47 86                            call  nextchar         ; get next character
    2635/    8D9C :                     
    2636/    8D9C :                     ; subscript flag is 0 in normal    processing
    2637/    8D9C :                     ; ie will here go to var_subscript to evaluate an
    2638/    8D9C :                     ; array or FN expression
    2639/    8D9C :                     ; flag is 1 for processing exec_kill
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 48 - 8/15/2019 11:33:6


    2640/    8D9C :                     ; flag is CHAR_RPAREN to locate and create variable/FN
    2641/    8D9C :                     ; return ptr to payload in DE
    2642/    8D9C :                     loc_109C:                ; get subscript    flag
    2643/    8D9C : 3A 4E 0C                            ld    a, (subscript_flag)
    2644/    8D9F : 3D                                  dec   a
    2645/    8DA0 : CA 3C 8E                            jp    z, kill_matrix   ; subscript flag is 1 (exec_kill), set number of indices = 0
    2646/    8DA3 : 86                                  add   a, (hl)          ; addnext char
    2647/    8DA4 :                                                            ; if it was '(', result will be 0x27
    2648/    8DA4 : D6 27                               sub   CHAR_LPAREN-1    ; subtract 0x27
    2649/    8DA6 : 28 6C                               jr    z, var_subscript ; we found a subscript and are in an expression
    2650/    8DA8 :                                                            ; evaluate the whole item
    2651/    8DA8 : AF                                  xor    a               ; not in var evaluation or func definition
    2652/    8DA9 :                                                            ; clear subscript flag
    2653/    8DA9 : 32 4E 0C                            ld    (subscript_flag), a
    2654/    8DAC : E5                                  push  hl               ; save curlineptr
    2655/    8DAD : 2A 60 0C                            ld    hl, (end_of_vars)
    2656/    8DB0 : EB                                  ex    de, hl           ; DE = end of vars
    2657/    8DB1 : 2A 5E 0C                            ld    hl, (prog_end)   ; HL = prog_end
    2658/    8DB4 : (MACRO)             find_var1:      CPHL_DE                ; compare with end
    2658/    8DB4 : 7C                                  ld    a, h
    2658/    8DB5 : 92                                  sub   d
    2658/    8DB6 : 20 02                               jr    nz, m1
    2658/    8DB8 : 7D                                  ld    a, l
    2658/    8DB9 : 93                                  sub   e
    2658/    8DBA :                     m1:
    2659/    8DBA : 28 12                               jr    z, var_not_found ; end of variables found?
    2660/    8DBC : 79                                  ld    a, c             ; compare variable name with name in var table
    2661/    8DBD : 96                                  sub   (hl)
    2662/    8DBE : 23                                  inc   hl
    2663/    8DBF : 20 02                               jr    nz, loc_10C3
    2664/    8DC1 : 78                                  ld    a, b
    2665/    8DC2 : 96                                  sub   (hl)
    2666/    8DC3 : 23                  loc_10C3:       inc   hl
    2667/    8DC4 : 28 40                               jr    z, var_found     ; found variable, return address of payload in DE
    2668/    8DC6 : 23                                  inc   hl               ; advance to next variable
    2669/    8DC7 :                                                            ; (skip over the floating point/string value)
    2670/    8DC7 : 23                                  inc   hl
    2671/    8DC8 : 23                                  inc   hl
    2672/    8DC9 : 23                                  inc   hl
    2673/    8DCA : 23                                  inc   hl
    2674/    8DCB : 23                                  inc   hl
    2675/    8DCC : 18 E6                               jr    find_var1        ; loop
    2676/    8DCE : E1                  var_not_found:  pop   hl               ; restore curlineptr
    2677/    8DCF : E3                                  ex    (sp), hl         ; stack: curlineptr
    2678/    8DD0 :                                                            ; HL: return address
    2679/    8DD0 : D5                                  push  de               ; save DE
    2680/    8DD1 : 11 6A 8C                            ld    de, loc_F6A      ; came from expression handler?
    2681/    8DD4 : (MACRO)                             CPHL_DE   
    2681/    8DD4 : 7C                                  ld    a, h
    2681/    8DD5 : 92                                  sub   d
    2681/    8DD6 : 20 02                               jr    nz, m1
    2681/    8DD8 : 7D                                  ld    a, l
    2681/    8DD9 : 93                                  sub   e
    2681/    8DDA :                     m1:
    2682/    8DDA : D1                                  pop   de               ; restore DE
    2683/    8DDB : 28 2C                               jr    z, fpaccu_clear  ; yes, called out of expression handler
    2684/    8DDD :                                                            ; clear fpaccu
    2685/    8DDD : E3                                  ex    (sp), hl         ; restore return address, HL = curlineptr
    2686/    8DDE : E5                                  push  hl               ; save curlineptr
    2687/    8DDF : C5                                  push  bc               ; save variable name
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 49 - 8/15/2019 11:33:6


    2688/    8DE0 : 01 08 00                            ld    bc, 8            ; require space for 8 bytes
    2689/    8DE3 : 2A 62 0C                            ld    hl, (end_arrays) ; get start of arrays
    2690/    8DE6 : E5                                  push  hl               ; save it
    2691/    8DE7 : 09                                  add   hl, bc           ; calculate new end address
    2692/    8DE8 : C1                                  pop   bc               ; old end address
    2693/    8DE9 : E5                                  push  hl               ; new end address
    2694/    8DEA :                                                            ; DE is start address
    2695/    8DEA : CD 19 81                            call  make_space       ; copy area 8 bytes up
    2696/    8DED : E1                                  pop   hl
    2697/    8DEE : 22 62 0C                            ld    (end_arrays), hl ; save new end address
    2698/    8DF1 : (MACRO)                             LDHL_BC                ; get end of free space
    2698/    8DF1 : 60                                  ld    h, b
    2698/    8DF2 : 69                                  ld    l, c
    2699/    8DF3 : 22 60 0C                            ld    (end_of_vars), hl ; new end of variables
    2700/    8DF6 : 2B                  loop10F6:       dec   hl               ;<+ clear free space
    2701/    8DF7 : 36 00                               ld    (hl), NULL       ; |
    2702/    8DF9 : (MACRO)                             CPHL_DE                ; |
    2702/    8DF9 : 7C                                  ld    a, h
    2702/    8DFA : 92                                  sub   d
    2702/    8DFB : 20 02                               jr    nz, m1
    2702/    8DFD : 7D                                  ld    a, l
    2702/    8DFE : 93                                  sub   e
    2702/    8DFF :                     m1:
    2703/    8DFF : 20 F5                               jr    nz, loop10F6     ;-+ loop
    2704/    8E01 : D1                                  pop   de               ; get variable name
    2705/    8E02 : (MACRO)                             LDM_DE                 ; save it in variable
    2705/    8E02 : 73                                  ld    (hl), e
    2705/    8E03 : 23                                  inc   hl
    2705/    8E04 : 72                                  ld    (hl), d
    2706/    8E05 : 23                                  inc   hl
    2707/    8E06 : EB                  var_found:      ex    de, hl           ; address of payload of variable in DE
    2708/    8E07 : E1                                  pop   hl               ; curlineptr in HL
    2709/    8E08 : C9                                  ret                    ; exit
    2710/    8E09 :                     
    2711/    8E09 : 32 6B 0C            fpaccu_clear:   ld    (fpaccu_exp), a  ; A is 0
    2712/    8E0C : 21 FF 0D                            ld    hl, memend       ; should be irrelevant, as exp=0
    2713/    8E0F : 22 66 0C                            ld    (fpaccu_mant32), hl ; mark newly initialized variable
    2714/    8E12 : E1                                  pop   hl
    2715/    8E13 : C9                                  ret
    2716/    8E14 :                     
    2717/    8E14 :                     ; called to evaluate a var expression for an
    2718/    8E14 :                     ; already declared array
    2719/    8E14 : E5                  var_subscript:  push  hl               ; save curlineptr
    2720/    8E15 : 2A 01 0C                            ld    hl, (dim_flag)   ; load dim_flag and expression type
    2721/    8E18 : E3                                  ex    (sp), hl         ; save it, restore curlineptr
    2722/    8E19 : 57                                  ld    d, a             ; clear D, A was 0
    2723/    8E1A : D5                  loop111A:       push  de               ;<+ save registers
    2724/    8E1B : C5                                  push  bc               ; | 
    2725/    8E1C : CD 21 87                            call  getnext_expression_U16 ; get index in DE
    2726/    8E1F : C1                                  pop   bc               ; | restore reg
    2727/    8E20 : F1                                  pop   af               ; | restore cntr of indices
    2728/    8E21 : EB                                  ex    de, hl           ; | index in HL
    2729/    8E22 : E3                                  ex    (sp), hl         ; | push on stack
    2730/    8E23 : E5                                  push  hl               ; | 
    2731/    8E24 : EB                                  ex    de, hl           ; | get current line ptr again
    2732/    8E25 : 3C                                  inc   a                ; | increment # of indices
    2733/    8E26 : 57                                  ld    d, a             ; | into D
    2734/    8E27 : 7E                                  ld    a, (hl)          ; | get next char
    2735/    8E28 : FE 2C                               cp    CHAR_COMMA       ; | is it comma?
    2736/    8E2A : 28 EE                               jr    z, loop111A      ;-+ yes, loop
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 50 - 8/15/2019 11:33:6


    2737/    8E2C : (MACRO)                             EXPECT CHAR_RPAREN     ; must be end of subscript
    2737/    8E2C : 3E 29                               ld    a, CHAR_RPAREN
    2737/    8E2E : CD 51 81                            call  expect_char
    2738/    8E31 : 22 52 0C                            ld    (lineptrsave), hl ; save line ptr
    2739/    8E34 : E1                                  pop   hl               ; restore expression/var types
    2740/    8E35 : 22 01 0C                            ld    (dim_flag), hl
    2741/    8E38 : 1E 00                               ld    e, 0             ; D is # indices, E = 0
    2742/    8E3A : D5                                  push  de               ; save
    2743/    8E3B : 11                                  db    11h              ; LD DE, xxxx to skip next 2 instructions
    2744/    8E3C : E5                  kill_matrix:    push  hl               ;** save curlineptr
    2745/    8E3D : F5                                  push  af               ;** number of indices
    2746/    8E3E :                                                            ; is 0 if coming from exec_kill
    2747/    8E3E :                     ; var_subscript skips here
    2748/    8E3E : 2A 60 0C                            ld    hl, (end_of_vars) ; HL = end_of_vars = start_arrays
    2749/    8E41 : 3E                                  db    3Eh              ; LD A, xx to skip next instruction
    2750/    8E42 : 19                  loop1142:       add   hl, de           ;**
    2751/    8E43 : ED 5B 62 0C                         ld    de, (end_arrays) ;<+ is end_of_arrays reached?
    2752/    8E47 : (MACRO)                             CPHL_DE                ; | 
    2752/    8E47 : 7C                                  ld    a, h
    2752/    8E48 : 92                                  sub   d
    2752/    8E49 : 20 02                               jr    nz, m1
    2752/    8E4B : 7D                                  ld    a, l
    2752/    8E4C : 93                                  sub   e
    2752/    8E4D :                     m1:
    2753/    8E4D : 28 21                               jr    z, array_declare ; | end of table, not found, go declare it
    2754/    8E4F : 7E                                  ld    a, (hl)          ; | compare with name
    2755/    8E50 : B9                                  cp    c                ; | 
    2756/    8E51 : 23                                  inc   hl               ; | 
    2757/    8E52 : 20 02                               jr    nz, loc_1156     ; | 
    2758/    8E54 : 7E                                  ld    a, (hl)          ; | 
    2759/    8E55 : B8                                  cp    b                ; | 
    2760/    8E56 : 23                  loc_1156:       inc   hl               ; | 
    2761/    8E57 : (MACRO)                             LDDE_M                 ; | DE = size of array in bytes
    2761/    8E57 : 5E                                  ld    e, (hl)
    2761/    8E58 : 23                                  inc   hl
    2761/    8E59 : 56                                  ld    d, (hl)
    2762/    8E5A : 23                                  inc   hl               ; |
    2763/    8E5B : 20 E5                               jr    nz, loop1142     ;-+ array not found, loop
    2764/    8E5D :                                                            ; the array is found
    2765/    8E5D : 3A 01 0C                            ld    a, (dim_flag)    ; was it from DIM?
    2766/    8E60 : B7                                  or    a
    2767/    8E61 : C2 76 81                            jp    nz, redim_array_error ; yes, and it already exists
    2768/    8E64 :                                                            ; otherwise error!
    2769/    8E64 : F1                                  pop   af               ; restore number of indices
    2770/    8E65 : CA 01 9C                            jp    z, kill_array    ; zero, ie comes from exec_kill
    2771/    8E68 : 96                                  sub   (hl)             ; subtract from #indices of declared array
    2772/    8E69 : 28 61                               jr    z, find_arrayvar ; both match
    2773/    8E6B :                     
    2774/    8E6B :                     subscript_range_error:            
    2775/    8E6B : 1E 09                               ld    e, 9             ; no, error 
    2776/    8E6D : C3 7E 81                            jp    print_error
    2777/    8E70 : 11 06 00            array_declare:  ld    de, 6            ; sizeof element
    2778/    8E73 : F1                                  pop   af               ; restore #indices
    2779/    8E74 : CA 19 9C                            jp    z, loc_1F19      ; zero?
    2780/    8E77 : (MACRO)                             LDM_BC                 ; store variable name
    2780/    8E77 : 71                                  ld    (hl), c
    2780/    8E78 : 23                                  inc   hl
    2780/    8E79 : 70                                  ld    (hl), b
    2781/    8E7A : 23                                  inc   hl
    2782/    8E7B : 4F                                  ld    c, a             ; reserve space for index words
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 51 - 8/15/2019 11:33:6


    2783/    8E7C : CD 31 81                            call  verify_space
    2784/    8E7F : 23                                  inc   hl               ; advance 2 bytes (for total size)
    2785/    8E80 : 23                                  inc   hl
    2786/    8E81 : 22 4A 0C                            ld    (arrayvalptr), hl ; save index table ptr
    2787/    8E84 : 71                                  ld    (hl), c          ; save #index bytes
    2788/    8E85 : 23                                  inc   hl
    2789/    8E86 : 3A 01 0C                            ld    a, (dim_flag)    ; get dimension flag
    2790/    8E89 : 17                                  rla                    ; put flag in CY
    2791/    8E8A : 79                                  ld    a, c             ; load index count
    2792/    8E8B : 01 0B 00            loop118B:       ld    bc, 0Bh          ;<+ load default value for index
    2793/    8E8E : 30 02                               jr    nc, loc_1192     ; | not DIM, skip
    2794/    8E90 : C1                                  pop   bc               ; | get index
    2795/    8E91 : 03                                  inc   bc               ; | +1 (zero based)
    2796/    8E92 : (MACRO)             loc_1192:       LDM_BC                 ; | store index
    2796/    8E92 : 71                                  ld    (hl), c
    2796/    8E93 : 23                                  inc   hl
    2796/    8E94 : 70                                  ld    (hl), b
    2797/    8E95 : 23                                  inc   hl               ; | 
    2798/    8E96 : F5                                  push  af               ; | save count
    2799/    8E97 : E5                                  push  hl               ; | save ptr to index tbl
    2800/    8E98 : CD C6 A0                            call  umultiply16      ; | calculate total size
    2801/    8E9B : EB                                  ex    de, hl           ; | result in DE
    2802/    8E9C : E1                                  pop   hl               ; | restore ptr
    2803/    8E9D : F1                                  pop   af               ; | restore #indices
    2804/    8E9E : 3D                                  dec   a                ; | decrement
    2805/    8E9F : 20 EA                               jr    nz, loop118B     ;-+ loop over all indices
    2806/    8EA1 : F5                                  push  af               ; A = 0, save
    2807/    8EA2 : 42                                  ld    b, d             ; get total size in BC
    2808/    8EA3 : 4B                                  ld    c, e
    2809/    8EA4 : EB                                  ex    de, hl           ; HL = end of index table
    2810/    8EA5 : 19                                  add   hl, de           ; add total size
    2811/    8EA6 : 38 C3                               jr    c, subscript_range_error ; overflow? error
    2812/    8EA8 : CD 3E 81                            call  check_memfree    ; enough space free?
    2813/    8EAB : 22 62 0C                            ld    (end_arrays), hl ; store new end of array
    2814/    8EAE : 2B                  loop11AE:       dec   hl               ;<+ clear array
    2815/    8EAF : 36 00                               ld    (hl), NULL       ; |
    2816/    8EB1 : (MACRO)                             CPHL_DE                ; |
    2816/    8EB1 : 7C                                  ld    a, h
    2816/    8EB2 : 92                                  sub   d
    2816/    8EB3 : 20 02                               jr    nz, m1
    2816/    8EB5 : 7D                                  ld    a, l
    2816/    8EB6 : 93                                  sub   e
    2816/    8EB7 :                     m1:
    2817/    8EB7 : 20 F5                               jr    nz, loop11AE     ;-+ loop
    2818/    8EB9 : 03                                  inc   bc               ; total size +1
    2819/    8EBA : 57                                  ld    d, a             ; D = 0, because A is 0
    2820/    8EBB : 2A 4A 0C                            ld    hl, (arrayvalptr) ; get ptr to array index table
    2821/    8EBE : 5E                                  ld    e, (hl)
    2822/    8EBF : EB                                  ex    de, hl           ; HL = # indices
    2823/    8EC0 : 29                                  add   hl, hl           ;  HL * 2
    2824/    8EC1 : 09                                  add   hl, bc           ; add size of payload
    2825/    8EC2 : EB                                  ex    de, hl           ; into DE
    2826/    8EC3 : 2B                                  dec   hl               ; point to total size field
    2827/    8EC4 : 2B                                  dec   hl
    2828/    8EC5 : (MACRO)                             LDM_DE                 ; store array length
    2828/    8EC5 : 73                                  ld    (hl), e
    2828/    8EC6 : 23                                  inc   hl
    2828/    8EC7 : 72                                  ld    (hl), d
    2829/    8EC8 : 23                                  inc   hl
    2830/    8EC9 : F1                                  pop   af               ; restore CY = dimflag
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 52 - 8/15/2019 11:33:6


    2831/    8ECA : 38 26                               jr    c, loc_11F2      ; restore curlineptr and exit
    2832/    8ECC : 47                  find_arrayvar:  ld    b, a             ; clear BC
    2833/    8ECD : 4F                                  ld    c, a
    2834/    8ECE : 7E                                  ld    a, (hl)          ; load #indices of declared array
    2835/    8ECF : 23                                  inc   hl               ; advance to index list
    2836/    8ED0 : 16                                  db    16h              ; LD D, xx to skip next instruction
    2837/    8ED1 :                                                            ; is uncritical because D is loaded 3 instrs
    2838/    8ED1 :                                                            ; later again
    2839/    8ED1 : E1                  loop11D1:       pop   hl               ;<+ ** pop requested index
    2840/    8ED2 : (MACRO)                             LDDE_M                 ; | load requested subscript in DE
    2840/    8ED2 : 5E                                  ld    e, (hl)
    2840/    8ED3 : 23                                  inc   hl
    2840/    8ED4 : 56                                  ld    d, (hl)
    2841/    8ED5 : 23                                  inc   hl               ; | 
    2842/    8ED6 : E3                                  ex    (sp), hl         ; | get next index dimension
    2843/    8ED7 : F5                                  push  af               ; | save #indices
    2844/    8ED8 : (MACRO)                             CPHL_DE                ; | reqd index to large?
    2844/    8ED8 : 7C                                  ld    a, h
    2844/    8ED9 : 92                                  sub   d
    2844/    8EDA : 20 02                               jr    nz, m1
    2844/    8EDC : 7D                                  ld    a, l
    2844/    8EDD : 93                                  sub   e
    2844/    8EDE :                     m1:
    2845/    8EDE : 30 8B                               jr    nc, subscript_range_error ; yes, error
    2846/    8EE0 : E5                                  push  hl               ; | save dimension
    2847/    8EE1 : CD C6 A0                            call  umultiply16      ; | HL = DE * BC
    2848/    8EE4 : D1                                  pop   de               ; | restore dimension
    2849/    8EE5 : 19                                  add   hl, de           ; | add dimension size
    2850/    8EE6 : F1                                  pop   af               ; | restore #indices
    2851/    8EE7 : 3D                                  dec   a                ; | decrement
    2852/    8EE8 : (MACRO)                             LDBC_HL                ; | move to new position
    2852/    8EE8 : 44                                  ld    b, h
    2852/    8EE9 : 4D                                  ld    c, l
    2853/    8EEA : 20 E5                               jr    nz, loop11D1     ;-+ loop over all indices
    2854/    8EEC : 29                                  add   hl, hl           ; HL * 2
    2855/    8EED : 09                                  add   hl, bc           ; HL + BC
    2856/    8EEE : 29                                  add   hl, hl           ; HL * 2
    2857/    8EEF :                                                            ; -> multiply with 6 (element size)
    2858/    8EEF : C1                                  pop   bc               ; add base
    2859/    8EF0 : 09                                  add   hl, bc
    2860/    8EF1 : EB                                  ex    de, hl           ; address of variable in DE
    2861/    8EF2 : 2A 52 0C            loc_11F2:       ld    hl, (lineptrsave) ; restore curlineptr
    2862/    8EF5 : C9                                  ret
    2863/    8EF6 :                     
    2864/    8EF6 : 2A 62 0C            math_fre:       ld    hl, (end_arrays) ; get end of array space
    2865/    8EF9 : EB                                  ex    de, hl           ; into DE
    2866/    8EFA : 21 00 00                            ld    hl, 0            ; get SP
    2867/    8EFD : 39                                  add   hl, sp
    2868/    8EFE : 3A 02 0C                            ld    a, (expr_type)   ; check expression type of FRE
    2869/    8F01 : B7                                  or    a
    2870/    8F02 : 28 0D                               jr    z, loc_1211      ; is numeric? skip
    2871/    8F04 : CD 63 92                            call  fpaccu_getstr    ; put string on expr stack
    2872/    8F07 :                                                            ; to allow it to be disposed directly
    2873/    8F07 : CD 73 91                            call  gc               ; do garbage collection
    2874/    8F0A : 2A 5A 0C                            ld    hl, (string_base) ; get current base of strings
    2875/    8F0D : EB                                  ex    de, hl           ; into DE
    2876/    8F0E : 2A 48 0C            loc_120E:       ld    hl, (string_top) ; get end of strings
    2877/    8F11 : AF                  loc_1211:       xor    a               ; set expression type to numeric
    2878/    8F12 : 32 02 0C                            ld    (expr_type), a
    2879/    8F15 : ED 52                               sbc   hl, de           ; subtract start of range from end of range
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 53 - 8/15/2019 11:33:6


    2880/    8F17 :                                                            ; => used space by strings
    2881/    8F17 :                     
    2882/    8F17 : EB                  hl_to_fpaccu:   ex    de, hl           ; copy number in DE
    2883/    8F18 :                     
    2884/    8F18 :                     ; convert unsigned 16 bit DE number into FPACCU
    2885/    8F18 : AF                  uDE_to_fpaccu:  xor    a               ; sign is 0
    2886/    8F19 : 06 98                               ld    b, 98h           ; preload exponent with 0x98
    2887/    8F1B : 18 0A                               jr    loc_1227         ; go convert 16 bit
    2888/    8F1D :                     
    2889/    8F1D :                     ; convert C into FP, A is sign
    2890/    8F1D : 41                  AC_to_fpaccu:   ld    b, c
    2891/    8F1E :                     
    2892/    8F1E :                     ; convert B into FP, A is sign
    2893/    8F1E : 50                  AB_to_fpaccu:   ld    d, b
    2894/    8F1F : 1E 00                               ld    e, 0
    2895/    8F21 : 21 02 0C                            ld    hl, expr_type
    2896/    8F24 : 73                                  ld    (hl), e          ; clear cell
    2897/    8F25 : 06 90                               ld    b, 90h           ; exponent = 0x90 (16 bit)
    2898/    8F27 : C3 AB 9F            loc_1227:       jp    s24_to_fp
    2899/    8F2A :                     
    2900/    8F2A :                     ; process LPOS()
    2901/    8F2A : 3A 95 0C            math_lpos:      ld    a, (prtparam+ioparams_curpos) ; get printer position
    2902/    8F2D : 18 03                               jr    uA_to_fpaccu
    2903/    8F2F :                     
    2904/    8F2F :                     ; process POS()
    2905/    8F2F : 3A 90 0C            math_pos:       ld    a, (conparam+ioparams_curpos) ; load current cursor position
    2906/    8F32 :                     
    2907/    8F32 :                     ; convert unsigned 8 bit in A into FP
    2908/    8F32 : 47                  uA_to_fpaccu:   ld    b, a             ; put into B
    2909/    8F33 : AF                                  xor    a               ; clear sign
    2910/    8F34 : 18 E8                               jr    AB_to_fpaccu     ; convert into FP
    2911/    8F36 :                     
    2912/    8F36 : CD AA 90            exec_def:       call  locate_fn_info   ; define or read a variable for FN
    2913/    8F39 :                                                            ; ptr to payload in DE
    2914/    8F39 : CD 9C 90                            call  assert_run_program ; only allowed in program
    2915/    8F3C : EB                                  ex    de, hl           ; payload to function in HL
    2916/    8F3D : (MACRO)                             LDM_DE                 ; save current line ptr in function
    2916/    8F3D : 73                                  ld    (hl), e
    2916/    8F3E : 23                                  inc   hl
    2916/    8F3F : 72                                  ld    (hl), d
    2917/    8F40 : EB                                  ex    de, hl           ; DE = payload, FL = curlineptr
    2918/    8F41 : 2B                                  dec   hl               ; point to previous char
    2919/    8F42 : CD 47 86            loop1242:       call  nextchar         ;<+ get next char
    2920/    8F45 : 28 07                               jr    z, fn_program    ; | EOLN or end of statement?
    2921/    8F47 :                                                            ; | yes function subprogram
    2922/    8F47 : FE AD                               cp    TOKEN_EQUAL      ; | token '=' ?
    2923/    8F49 : 20 F7                               jr    nz, loop1242     ;-+ no possibly argument list, skip over it
    2924/    8F4B : C3 0B 88            loop124B:       jp    exec_data        ;<+ one-line function, ignore until EOLN or ':'
    2925/    8F4E : B7                  fn_program:     or    a                ; | is a real EOLN?
    2926/    8F4F : 20 0F                               jr    nz, loop1260     ; | no, something follows
    2927/    8F51 : 23                                  inc   hl               ; | multiline FN definition at the end of program?
    2928/    8F52 : 7E                                  ld    a, (hl)          ; | 
    2929/    8F53 : 23                                  inc   hl               ; | 
    2930/    8F54 : B6                                  or    (hl)             ; | 
    2931/    8F55 : CA 6D 81                            jp    z, syntax_error  ; | yes, not terminated with FNEND
    2932/    8F58 : 23                                  inc   hl               ; | get new lineno
    2933/    8F59 : (MACRO)                             LDDE_M                 ; | 
    2933/    8F59 : 5E                                  ld    e, (hl)
    2933/    8F5A : 23                                  inc   hl
    2933/    8F5B : 56                                  ld    d, (hl)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 54 - 8/15/2019 11:33:6


    2934/    8F5C : ED 53 54 0C                         ld    (lineno), de     ; | and store it
    2935/    8F60 : CD 47 86            loop1260:       call  nextchar         ;<--+ get next char (argument list or function body)
    2936/    8F63 : 28 E9                               jr    z, fn_program    ; | | EOLN or end statement, go loop
    2937/    8F65 : FE 89                               cp    TOKEN_FNEND      ; | | an FNEND found?
    2938/    8F67 : 28 E2                               jr    z, loop124B      ;-+ | yes, advance until end 
    2939/    8F69 :                                                            ;   | of statement (return expression)
    2940/    8F69 : C3 60 8F                            jp    loop1260         ;---+ no, skip over it
    2941/    8F6C :                     
    2942/    8F6C : CD AA 90            expr_fn:        call  locate_fn_info
    2943/    8F6F : 3A 02 0C                            ld    a, (expr_type)
    2944/    8F72 : B7                                  or    a
    2945/    8F73 : F5                                  push  af
    2946/    8F74 : 22 52 0C                            ld    (lineptrsave), hl
    2947/    8F77 : EB                                  ex    de, hl
    2948/    8F78 : (MACRO)                             LDHL_M A     
    2948/    8F78 : 7E                                  ld    A, (hl)
    2948/    8F79 : 23                                  inc   hl
    2948/    8F7A : 66                                  ld    h, (hl)
    2948/    8F7B : 6F                                  ld    l, A
    2949/    8F7C : B4                                  or    h
    2950/    8F7D : CA 79 81                            jp    z, usercall_error
    2951/    8F80 : 7E                                  ld    a, (hl)
    2952/    8F81 : FE 28                               cp    CHAR_LPAREN
    2953/    8F83 : 20 71                               jr    nz, loc_12F6
    2954/    8F85 : CD 47 86                            call  nextchar
    2955/    8F88 : 22 4A 0C                            ld    (arrayvalptr), hl
    2956/    8F8B : 18 05                               jr    loc_1292
    2957/    8F8D : (MACRO)             loop128D:       EXPECT CHAR_COMMA      ;<+
    2957/    8F8D : 3E 2C                               ld    a, CHAR_COMMA
    2957/    8F8F : CD 51 81                            call  expect_char
    2958/    8F92 : 0E 05               loc_1292:       ld    c, 5             ; |
    2959/    8F94 : CD 31 81                            call  verify_space     ; |
    2960/    8F97 : 3E 29                               ld    a, CHAR_RPAREN   ; |
    2961/    8F99 : 32 4E 0C                            ld    (subscript_flag), a
    2962/    8F9C : CD 6A 8D                            call  find_var         ; |
    2963/    8F9F : EB                                  ex    de, hl           ; |
    2964/    8FA0 : 3A 02 0C                            ld    a, (expr_type)   ; |
    2965/    8FA3 : B7                                  or    a                ; |
    2966/    8FA4 : 37                                  scf                    ; |
    2967/    8FA5 : 20 10                               jr    nz, loc_12B7     ; |
    2968/    8FA7 : (MACRO)                             LDBC_M                 ; |
    2968/    8FA7 : 4E                                  ld    c, (hl)
    2968/    8FA8 : 23                                  inc   hl
    2968/    8FA9 : 46                                  ld    b, (hl)
    2969/    8FAA : C5                                  push  bc               ; |
    2970/    8FAB : 23                                  inc   hl               ; |
    2971/    8FAC : (MACRO)                             LDBC_M                 ; |
    2971/    8FAC : 4E                                  ld    c, (hl)
    2971/    8FAD : 23                                  inc   hl
    2971/    8FAE : 46                                  ld    b, (hl)
    2972/    8FAF : C5                                  push  bc               ; |
    2973/    8FB0 : 23                                  inc   hl               ; |
    2974/    8FB1 : (MACRO)                             LDBC_M                 ; |
    2974/    8FB1 : 4E                                  ld    c, (hl)
    2974/    8FB2 : 23                                  inc   hl
    2974/    8FB3 : 46                                  ld    b, (hl)
    2975/    8FB4 : C5                                  push  bc               ; |
    2976/    8FB5 : 18 08                               jr    loc_12BF         ; |
    2977/    8FB7 : F5                  loc_12B7:       push  af               ; |
    2978/    8FB8 : D5                                  push  de               ; |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 55 - 8/15/2019 11:33:6


    2979/    8FB9 : EB                                  ex    de, hl           ; |
    2980/    8FBA : CD 10 91                            call  de_push_stringstk ;|
    2981/    8FBD : D1                                  pop   de               ; |
    2982/    8FBE : F1                                  pop   af               ; |
    2983/    8FBF : E5                  loc_12BF:       push  hl               ; |
    2984/    8FC0 : F5                                  push  af               ; |
    2985/    8FC1 : EB                                  ex    de, hl           ; |
    2986/    8FC2 : 7E                                  ld    a, (hl)          ; |
    2987/    8FC3 : FE 29                               cp    CHAR_RPAREN      ; | 
    2988/    8FC5 : 20 C6                               jr    nz, loop128D     ;-+
    2989/    8FC7 : 2A 52 0C                            ld    hl, (lineptrsave)
    2990/    8FCA : (MACRO)                             EXPECT CHAR_LPAREN
    2990/    8FCA : 3E 28                               ld    a, CHAR_LPAREN
    2990/    8FCC : CD 51 81                            call  expect_char
    2991/    8FCF : E5                                  push  hl
    2992/    8FD0 : 2A 4A 0C                            ld    hl, (arrayvalptr)
    2993/    8FD3 : CD 6A 8D            loop12D3:       call  find_var         ;<+
    2994/    8FD6 : E3                                  ex    (sp), hl         ; |
    2995/    8FD7 : CD 33 88                            call  do_assignment1          ; |
    2996/    8FDA : 7E                                  ld    a, (hl)          ; |
    2997/    8FDB : FE 29                               cp    CHAR_RPAREN      ; |
    2998/    8FDD : 28 0D                               jr    z, loc_12EC      ; |
    2999/    8FDF : (MACRO)                             EXPECT CHAR_COMMA      ; |
    2999/    8FDF : 3E 2C                               ld    a, CHAR_COMMA
    2999/    8FE1 : CD 51 81                            call  expect_char
    3000/    8FE4 : E3                                  ex    (sp), hl         ; |
    3001/    8FE5 : (MACRO)                             EXPECT CHAR_COMMA      ; |
    3001/    8FE5 : 3E 2C                               ld    a, CHAR_COMMA
    3001/    8FE7 : CD 51 81                            call  expect_char
    3002/    8FEA : 18 E7                               jr    loop12D3         ;-+
    3003/    8FEC : CD 47 86            loc_12EC:       call  nextchar
    3004/    8FEF : E3                                  ex    (sp), hl
    3005/    8FF0 : (MACRO)                             EXPECT CHAR_RPAREN
    3005/    8FF0 : 3E 29                               ld    a, CHAR_RPAREN
    3005/    8FF2 : CD 51 81                            call  expect_char
    3006/    8FF5 : 3E                                  db    3Eh              ; LD A, xx to skip next instruction
    3007/    8FF6 :                                                            ; LD A is uncritical because	skipspace_buf
    3008/    8FF6 :                                                            ; will destroy A
    3009/    8FF6 : D5                  loc_12F6:       push  de               ;* skipped
    3010/    8FF7 : CD 48 86                            call  skipspace
    3011/    8FFA : 28 10                               jr    z, loc_130C
    3012/    8FFC : (MACRO)                             EXPECT TOKEN_EQUAL
    3012/    8FFC : 3E AD                               ld    a, TOKEN_EQUAL
    3012/    8FFE : CD 51 81                            call  expect_char
    3013/    9001 : CD 9A 8B                            call  expression1
    3014/    9004 : CD 48 86                            call  skipspace
    3015/    9007 : C2 6D 81                            jp    nz, syntax_error
    3016/    900A : 18 3A                               jr    loc_1346
    3017/    900C : 0E 02               loc_130C:       ld    c, 2
    3018/    900E : CD 31 81                            call  verify_space
    3019/    9011 : ED 5B 54 0C                         ld    de, (lineno)
    3020/    9015 : D5                                  push  de
    3021/    9016 : 16 A0                               ld    d, TOKEN_FN
    3022/    9018 : D5                                  push  de
    3023/    9019 : 33                                  inc   sp
    3024/    901A : C3 CC 85                            jp    command_done
    3025/    901D :                     
    3026/    901D : 20 0C               exec_fnend:     jr    nz, has_fnreturn ; return expression follows?
    3027/    901F : CD 0E 9D                            call  fpaccu_zero      ; no, return value is zero
    3028/    9022 : 32 44 0C                            ld    (straccu_length), a ; set to 0
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 56 - 8/15/2019 11:33:6


    3029/    9025 : 2F                                  cpl
    3030/    9026 : 32 02 0C                            ld    (expr_type), a   ; set to FF
    3031/    9029 : 18 09                               jr    loc_1334         ; continue
    3032/    902B : CD 9A 8B            has_fnreturn:   call  expression1      ; parse result expression
    3033/    902E : CD 48 86                            call  skipspace        ; advance
    3034/    9031 : C2 6D 81                            jp    nz, syntax_error ; is not EOLN? error
    3035/    9034 : 16 FF               loc_1334:       ld    d, 0FFh          ; destroy any FOR loops that were in function
    3036/    9036 : CD F6 80                            call  discard_open_forloops
    3037/    9039 : F9                                  ld    sp, hl           ; store new stack top
    3038/    903A : FE A0                               cp    TOKEN_FN         ; is a FN structure on stack?
    3039/    903C : 1E 17               fnreturn_error: ld    e, 23            ; no, FNRETURN W/O FUNCTION error
    3040/    903E : C2 7E 81                            jp    nz, print_error
    3041/    9041 : D1                                  pop   de               ; restore old lineno
    3042/    9042 : ED 53 54 0C                         ld    (lineno), de
    3043/    9046 :                     
    3044/    9046 : 3A 02 0C            loc_1346:       ld    a, (expr_type)
    3045/    9049 : 3C                                  inc   a
    3046/    904A : 28 03                               jr    z, loop134F
    3047/    904C : 3D                                  dec   a
    3048/    904D : 20 2E                               jr    nz, loc_137D
    3049/    904F : D1                  loop134F:       pop   de               ;<---+
    3050/    9050 : F1                  loop1350:       pop   af               ;<-+ |
    3051/    9051 : 30 13                               jr    nc, loc_1366     ;  | |
    3052/    9053 : 20 37                               jr    nz, loc_138C     ;  | |
    3053/    9055 : E1                                  pop   hl               ;  | |
    3054/    9056 : C1                                  pop   bc               ;  | |
    3055/    9057 : 70                                  ld    (hl), b          ;  | |
    3056/    9058 : 2B                                  dec   hl               ;  | |
    3057/    9059 : 71                                  ld    (hl), c          ;  | |
    3058/    905A : 2B                                  dec   hl               ;  | |
    3059/    905B : C1                                  pop   bc               ;  | |
    3060/    905C : 70                                  ld    (hl), b          ;  | |
    3061/    905D : 2B                                  dec   hl               ;  | |
    3062/    905E : 71                                  ld    (hl), c          ;  | |
    3063/    905F : 2B                                  dec   hl               ;  | |
    3064/    9060 : C1                                  pop   bc               ;  | |
    3065/    9061 : 70                                  ld    (hl), b          ;  | |
    3066/    9062 : 2B                                  dec   hl               ;  | |
    3067/    9063 : 71                                  ld    (hl), c          ;  | |
    3068/    9064 : 18 EA                               jr    loop1350         ;--+ |
    3069/    9066 : F5                  loc_1366:       push  af               ;  | |    
    3070/    9067 : D5                                  push  de               ;  | |    
    3071/    9068 : 21 02 0C                            ld    hl, expr_type    ;  | |    
    3072/    906B : CB 7E                               bit    7, (hl)         ;  | |    
    3073/    906D : 28 01                               jr    z, loc_1370      ;  | |    
    3074/    906F : 77                                  ld    (hl), a          ;  | |    
    3075/    9070 : B7                  loc_1370:       or    a                ;  | |    
    3076/    9071 : 11 44 0C                            ld    de, straccu      ;  | |    
    3077/    9074 : C4 10 91                            call  nz, de_push_stringstk
    3078/    9077 : E1                                  pop   hl               ;  | |    
    3079/    9078 : F1                                  pop   af               ;  | |    
    3080/    9079 : 1F                                  rra                    ;  | |    
    3081/    907A : C3 8A 8B                            jp    verify_exprtype  ;  | |    
    3082/    907D : ED 5B 66 0C         loc_137D:       ld    de, (fpaccu_mant32) ; | |    
    3083/    9081 : CD 83 92                            call  peekpop_str_stringstk ; |    	peekpop_str_exprstk
    3084/    9084 : 21 44 0C                            ld    hl, straccu      ;  | |    
    3085/    9087 : CD 19 A0                            call  move_to_var      ;  | |    
    3086/    908A : 18 C3                               jr    loop134F         ;--|-+
    3087/    908C : CD 83 92            loc_138C:       call  peekpop_str_stringstk
    3088/    908F : 7E                                  ld    a, (hl)          ;  |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 57 - 8/15/2019 11:33:6


    3089/    9090 : 22 06 0C                            ld    (stringstkptr), hl ;|
    3090/    9093 : E1                                  pop   hl               ;  |
    3091/    9094 : 77                                  ld    (hl), a          ;  |
    3092/    9095 : 23                                  inc   hl               ;  |
    3093/    9096 : 23                                  inc   hl               ;  |
    3094/    9097 : (MACRO)                             LDM_BC                 ;  |
    3094/    9097 : 71                                  ld    (hl), c
    3094/    9098 : 23                                  inc   hl
    3094/    9099 : 70                                  ld    (hl), b
    3095/    909A : 18 B4                               jr    loop1350         ;--+
    3096/    909C :                     
    3097/    909C :                     ; check if function is called while program is running
    3098/    909C :                     assert_run_program:
    3099/    909C : E5                                  push  hl               ; save curlineptr
    3100/    909D : 2A 54 0C                            ld    hl, (lineno)     ; get lineno
    3101/    90A0 : 23                                  inc   hl
    3102/    90A1 : (MACRO)                             TEST_0
    3102/    90A1 : 7C                                  ld    a, h
    3102/    90A2 : B5                                  or    l
    3103/    90A3 : E1                                  pop   hl
    3104/    90A4 : C0                                  ret   nz               ; if not zero, return
    3105/    90A5 :                     ill_direct_error:                      
    3106/    90A5 : 1E 0C                               ld    e, 12            ; illegal direct error
    3107/    90A7 : C3 7E 81                            jp    print_error
    3108/    90AA :                     
    3109/    90AA : (MACRO)             locate_fn_info: EXPECT TOKEN_FN        ; expect FN
    3109/    90AA : 3E A0                               ld    a, TOKEN_FN
    3109/    90AC : CD 51 81                            call  expect_char
    3110/    90AF : F6 80                               or    80h              ; set bit7 of first character of func name
    3111/    90B1 : 47                                  ld    b, a             ; store in B
    3112/    90B2 : 3E 29                               ld    a, CHAR_RPAREN   ; set subscript flag
    3113/    90B4 : 32 4E 0C                            ld    (subscript_flag), a
    3114/    90B7 : C3 6F 8D                            jp    loc_106F         ; jump into find_var
    3115/    90BA :                     
    3116/    90BA :                     math_strs:
    3117/    90BA : CD 88 8B                            call  assert_numeric   ; require argument to be numeric
    3118/    90BD : CD DD A1                            call  format_number    ; format it into scratchpad
    3119/    90C0 : CD ED 90                            call  straccu_copy     ; copy it into straccu
    3120/    90C3 : CD 63 92                            call  fpaccu_getstr    ; get it
    3121/    90C6 : 01 C2 92                            ld    bc, loc_15C2     ; push result on exprstack later
    3122/    90C9 : C5                                  push  bc
    3123/    90CA :                     
    3124/    90CA :                     ; reserve space for string (descr at HL) and copy it to this area
    3125/    90CA : 7E                  string_dup:     ld    a, (hl)          ; get length of string
    3126/    90CB : 23                                  inc   hl               ; point to address of string
    3127/    90CC : 23                                  inc   hl
    3128/    90CD : E5                                  push  hl
    3129/    90CE : CD 49 91                            call  reserve_strspace ; reserve space on stack
    3130/    90D1 : E1                                  pop   hl
    3131/    90D2 : (MACRO)                             LDBC_M                 ; get string address into BC
    3131/    90D2 : 4E                                  ld    c, (hl)
    3131/    90D3 : 23                                  inc   hl
    3131/    90D4 : 46                                  ld    b, (hl)
    3132/    90D5 : CD E1 90                            call  straccu_store    ; store string descr in straccu
    3133/    90D8 : E5                                  push  hl               ; save descriptor
    3134/    90D9 : CD 59 92                            call  copy_string      ; copy string to reserved space
    3135/    90DC : D1                                  pop   de
    3136/    90DD : C9                                  ret
    3137/    90DE :                     
    3138/    90DE :                     ; reserve space for A bytes and store descriptor in straccu
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 58 - 8/15/2019 11:33:6


    3139/    90DE :                     straccu_reserve_strspace:
    3140/    90DE : CD 49 91                            call  reserve_strspace ; reserve space for A bytes
    3141/    90E1 :                     
    3142/    90E1 :                     ; store A=len, DE=addr into string accu
    3143/    90E1 : 21 44 0C            straccu_store:  ld    hl, straccu      ; point to current string descriptor
    3144/    90E4 : E5                                  push  hl               ; save it
    3145/    90E5 : 77                                  ld    (hl), a          ; save string length
    3146/    90E6 : 23                                  inc   hl               ; skip a cell
    3147/    90E7 : 23                                  inc   hl
    3148/    90E8 : (MACRO)                             LDM_DE                 ; save current address of string
    3148/    90E8 : 73                                  ld    (hl), e
    3148/    90E9 : 23                                  inc   hl
    3148/    90EA : 72                                  ld    (hl), d
    3149/    90EB : E1                                  pop   hl
    3150/    90EC : C9                                  ret
    3151/    90ED :                     
    3152/    90ED : 2B                  straccu_copy:   dec   hl               ; position to double quote character
    3153/    90EE :                     
    3154/    90EE :                     ; enters here with double quote 8") seen
    3155/    90EE :                     ; copy a string constant into straccu, and push on stringstk
    3156/    90EE :                     ; set expr_type to string
    3157/    90EE : 06 22               copy_strconst:  ld    b, CHAR_QUOTE    ; load constant string terminator
    3158/    90F0 :                     
    3159/    90F0 :                     ; entered here with terminator 0 as well
    3160/    90F0 : 50                  copy_0string:   ld    d, b             ; store terminator
    3161/    90F1 : E5                  copy_string1:   push  hl               ; save ptr to string
    3162/    90F2 : 0E FF                               ld    c, 0FFh          ; set char cntr to -1
    3163/    90F4 : 23                  loop13F4:       inc   hl               ;<+ advance to next string char
    3164/    90F5 : 7E                                  ld    a, (hl)          ; | get string char
    3165/    90F6 : 0C                                  inc   c                ; | increment length
    3166/    90F7 : B7                                  or    a                ; | is it zero?
    3167/    90F8 : 28 06                               jr    z, string_end    ; | yes, done
    3168/    90FA : BA                                  cp    d                ; | is it terminator in D?
    3169/    90FB : 28 03                               jr    z, string_end    ; | yes, done
    3170/    90FD : B8                                  cp    b                ; | is it terminator in B?
    3171/    90FE : 20 F4                               jr    nz, loop13F4     ;-+ no, loop
    3172/    9100 : FE 22               string_end:     cp    CHAR_QUOTE       ; if terminator was ", advance
    3173/    9102 : CC 47 86                            call  z, nextchar
    3174/    9105 : E3                                  ex    (sp), hl         ; stack is current position
    3175/    9106 :                                                            ; HL is start of string
    3176/    9106 : 23                                  inc   hl               ; skip over the starting "
    3177/    9107 : EB                                  ex    de, hl           ; put into DE
    3178/    9108 : 79                                  ld    a, c             ; get length in A
    3179/    9109 : CD E1 90                            call  straccu_store    ; store in string accu
    3180/    910C :                     
    3181/    910C :                     straccu_push_exprstack:                ; get string accu
    3182/    910C : 11 44 0C                            ld    de, straccu
    3183/    910F : 3E                                  db    3Eh              ; LD A, xx to skip instruction
    3184/    9110 :                                                            ; is uncritical, because A is loaded later again
    3185/    9110 :                     de_push_stringstk:
    3186/    9110 : D5                                  push  de
    3187/    9111 : 2A 06 0C                            ld    hl, (stringstkptr) ; HL points to exprstack
    3188/    9114 : 22 66 0C                            ld    (fpaccu_mant32), hl ; store exprstackptr in fpaccu
    3189/    9117 : 3E 01                               ld    a, 1
    3190/    9119 : 32 02 0C                            ld    (expr_type), a   ; set expression type to string
    3191/    911C : CD 19 A0                            call  move_to_var      ; put into exypression stack
    3192/    911F :                                                            ; HL points to next position
    3193/    911F :                                                            ; DE = stringaccu+6
    3194/    911F : (MACRO)                             CPHL_DE                ; check if exprstack full
    3194/    911F : 7C                                  ld    a, h
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 59 - 8/15/2019 11:33:6


    3194/    9120 : 92                                  sub   d
    3194/    9121 : 20 02                               jr    nz, m1
    3194/    9123 : 7D                                  ld    a, l
    3194/    9124 : 93                                  sub   e
    3194/    9125 :                     m1:
    3195/    9125 :                                                            ; assume DE was stringaccu
    3196/    9125 :                                                            ; on 11th call level, this will
    3197/    9125 :                                                            ; copy stringaccu -> stringaccu
    3198/    9125 :                                                            ; and will result in overflow
    3199/    9125 : 22 06 0C                            ld    (stringstkptr), hl ; store new exprstack ptr
    3200/    9128 : E1                                  pop   hl               ; restore stringaccu
    3201/    9129 : 7E                                  ld    a, (hl)          ; get length of string
    3202/    912A : C0                                  ret   nz               ; return if no stack overflow
    3203/    912B : 1E 10                               ld    e, 16            ; error code "too complex"
    3204/    912D :                     
    3205/    912D : C3 7E 81            print_error1:   jp    print_error      ; exit error
    3206/    9130 :                     
    3207/    9130 : 23                  loc_1430:       inc   hl
    3208/    9131 :                     straccu_copy_print:
    3209/    9131 : CD ED 90                            call  straccu_copy
    3210/    9134 :                     
    3211/    9134 :                     ; print string pointed to by fpaccu
    3212/    9134 : CD 63 92            straccu_print:  call  fpaccu_getstr    ; get the string pointed to by fpaccu
    3213/    9137 : CD 6C A0                            call  restore_de_bc    ; restore string descriptor into DE andBC
    3214/    913A :                                                            ; E is length, BC is address
    3215/    913A : 1C                                  inc   e                ; preincrement for loop
    3216/    913B : 1D                  loop143B:       dec   e                ;<+ decrement length
    3217/    913C : C8                                  ret   z                ; | return if zero
    3218/    913D : 0A                                  ld    a, (bc)          ; | get char of string
    3219/    913E : CD 66 84                            call  print_char       ; | print it
    3220/    9141 : FE 0D                               cp    CHAR_CR          ; | was it a CR?
    3221/    9143 : CC FB 89                            call  z, print_nul_delay ; yes, print padding characters
    3222/    9146 : 03                                  inc   bc               ; | advance to next position
    3223/    9147 : 18 F2                               jr    loop143B         ;-+ loop
    3224/    9149 :                     
    3225/    9149 :                     ; reserve space on string scratchpad
    3226/    9149 :                     ; A=requested size
    3227/    9149 :                     ; DE = start of string space
    3228/    9149 :                     ; HL = string_base
    3229/    9149 :                     reserve_strspace:
    3230/    9149 : B7                                  or    a                ; set flags of requested length
    3231/    914A : 0E                                  db    0Eh              ; LD C, xx to skip next instruction
    3232/    914B :                                                            ; is uncritical because C is loaded later again
    3233/    914B :                     
    3234/    914B :                     ; will arrive here twice, first coming from reserve_strspace
    3235/    914B :                     ; and second, if string scratchpad space overflows
    3236/    914B :                     reserve_strspace1:            
    3237/    914B : F1                                  pop   af               ; ** skipped
    3238/    914C : F5                                  push  af               ; save A
    3239/    914D : 2A 5A 0C                            ld    hl, (string_base) ; get stringbase into DE
    3240/    9150 : EB                                  ex    de, hl
    3241/    9151 : 2A 48 0C                            ld    hl, (string_top) ; get start of strings
    3242/    9154 : 4F                                  ld    c, a             ; get requested length
    3243/    9155 : AF                                  xor    a               ; extend to 16 bit in BC, clear CY
    3244/    9156 : 47                                  ld    b, a
    3245/    9157 : ED 42                               sbc   hl, bc           ; subtract from string start
    3246/    9159 : (MACRO)                             CPHL_DE                ; compare with base of strings
    3246/    9159 : 7C                                  ld    a, h
    3246/    915A : 92                                  sub   d
    3246/    915B : 20 02                               jr    nz, m1
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 60 - 8/15/2019 11:33:6


    3246/    915D : 7D                                  ld    a, l
    3246/    915E : 93                                  sub   e
    3246/    915F :                     m1:
    3247/    915F : 38 07                               jr    c, loc_1468      ; overflow?, error
    3248/    9161 : 22 48 0C                            ld    (string_top), hl ; store as new string start
    3249/    9164 : 23                                  inc   hl               ; point to string
    3250/    9165 : EB                                  ex    de, hl           ; into DE
    3251/    9166 : F1                                  pop   af               ; restore requested length
    3252/    9167 : C9                                  ret
    3253/    9168 :                     
    3254/    9168 :                     ; on first call, Z is never 1
    3255/    9168 :                     ; on second call, Z is forced to be 1
    3256/    9168 :                     ; to fall thru to no-memory error
    3257/    9168 : F1                  loc_1468:       pop   af               ; drop length
    3258/    9169 : 1E 0E                               ld    e, 14            ; error "no string space"
    3259/    916B : 28 C0                               jr    z, print_error1  ; if Z flag == 1, error
    3260/    916D :                                                            ; note comment above
    3261/    916D : BF                                  cp    a                ; enforce Z=1
    3262/    916E : F5                                  push  af               ; save requested size andZ=1
    3263/    916F : 01 4B 91                            ld    bc, reserve_strspace1 ; schedule reserve_space again
    3264/    9172 : C5                                  push  bc
    3265/    9173 :                     
    3266/    9173 :                     ; try garbage collection
    3267/    9173 :                     ;
    3268/    9173 :                     ; GC algorithm:
    3269/    9173 :                     ; set string_top = memory_top
    3270/    9173 :                     ; while not at string_base do
    3271/    9173 :                     ;   for each string in system
    3272/    9173 :                     ;     find xstring with highest address
    3273/    9173 :                     ;     copy xstring below string_top
    3274/    9173 :                     ;     set string_top = start of xstring
    3275/    9173 :                     ;     correct string descriptor of xstring
    3276/    9173 :                     ;   end for
    3277/    9173 :                     ; end while
    3278/    9173 :                     ;
    3279/    9173 : 2A 04 0C            gc:             ld    hl, (memory_top) ; get highest memory address
    3280/    9176 : 22 48 0C            gc_outer_while: ld    (string_top), hl ; set as new start of string area
    3281/    9179 :                     ; run the following entirely in the alternative register set
    3282/    9179 : AF                                  xor   a                ; clear A' and F' (CY=0)
    3283/    917A : 08                                  ex    af, af'
    3284/    917B : ED 5B 5A 0C                         ld    de, (string_base) ; DE = loop variable for traversing
    3285/    917F :                                                             ; strings to find the currently upmost one
    3286/    917F :                                                             ; initialized with lowest string in system,
    3287/    917F :                                                             ; so any string above it this will override it
    3288/    917F : D9                                  exx                     ; swap to alternative set
    3289/    9180 : 21 08 0C                            ld    hl, stringstk     ; HL' = exprstack
    3290/    9183 :                     
    3291/    9183 :                     ; garbage collection of string expression stack
    3292/    9183 :                     ;
    3293/    9183 :                     ; loop to handle scalar vars and expr stack
    3294/    9183 :                     gc_inner_scalar:            
    3295/    9183 : ED 5B 06 0C                         ld    de, (stringstkptr) ; DE' = current exprstackptr
    3296/    9187 : (MACRO)                             CPHL_DE                ; compare
    3296/    9187 : 7C                                  ld    a, h
    3296/    9188 : 92                                  sub   d
    3296/    9189 : 20 02                               jr    nz, m1
    3296/    918B : 7D                                  ld    a, l
    3296/    918C : 93                                  sub   e
    3296/    918D :                     m1:
    3297/    918D : 01 83 91                            ld    bc, gc_inner_scalar ; BC' is addr to return to outer loop
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 61 - 8/15/2019 11:33:6


    3298/    9190 : 20 3F                               jr    nz, gc_inner_find_xstring ; stack is not empty,
    3299/    9192 :                                                            ; do garbage collection
    3300/    9192 :                     
    3301/    9192 :                     ; garbage collection for string variable list
    3302/    9192 : 2A 5E 0C                            ld    hl, (prog_end)   ; get end_of_prog (start_of_vars table)
    3303/    9195 : ED 5B 60 0C         loop1495:       ld    de, (end_of_vars) ;<+ get end_of_vars ptr
    3304/    9199 : (MACRO)                             CPHL_DE                ;  | compare
    3304/    9199 : 7C                                  ld    a, h
    3304/    919A : 92                                  sub   d
    3304/    919B : 20 02                               jr    nz, m1
    3304/    919D : 7D                                  ld    a, l
    3304/    919E : 93                                  sub   e
    3304/    919F :                     m1:
    3305/    919F : 28 0A                               jr    z, loc_14AB      ;  | end of vars reached? yes, to array processing
    3306/    91A1 : CB 7E                               bit    7, (hl)         ;  | test bit 7 of 1st char of variable name
    3307/    91A3 :                                                            ;  | is set for string variable
    3308/    91A3 : 23                                  inc   hl               ;  | point to payload (string descriptor)
    3309/    91A4 : 23                                  inc   hl               ;  |
    3310/    91A5 : CD D2 91                            call  gc_inner_find_xstring1 ; check if this is highest (no outer loop)
    3311/    91A8 : 18 EB                               jr    loop1495         ;--+ loop until all variables have been traversed
    3312/    91AA :                     
    3313/    91AA :                     ; garbage collection for string arrays
    3314/    91AA : C1                  loop14AA:       pop   bc               ;<+ drop saved ptr to array declaration
    3315/    91AB : EB                  loc_14AB:       ex    de, hl           ; | HL' is current string descriptor
    3316/    91AC : 2A 62 0C                            ld    hl, (end_arrays) ; | compare with end of end of array ptr
    3317/    91AF : ED 52                               sbc   hl, de           ; |
    3318/    91B1 : EB                                  ex    de, hl           ; | HL' is again current string descriptor
    3319/    91B2 : 28 44                               jr    z, loc_14F8      ; | is it at the end of array space? yes, skip
    3320/    91B4 : CD 6C A0                            call  restore_de_bc    ; | DE' is variable name
    3321/    91B7 :                                                            ; | BC' is total size
    3322/    91B7 : CB 7B                               bit    7, e            ; | check variable name bit7=1: string var
    3323/    91B9 : E5                                  push  hl               ; | save ptr to array declaration
    3324/    91BA : 09                                  add   hl, bc           ; | advance to next array element
    3325/    91BB : 28 ED                               jr    z, loop14AA      ;-+ is it not a string array? loop
    3326/    91BD : E3                                  ex    (sp), hl         ; stack is ptr to next array element
    3327/    91BE :                                                            ; HL' is ptr to declaration
    3328/    91BE : 4E                                  ld    c, (hl)          ; load # of array indices
    3329/    91BF : 06 00                               ld    b, 0             ; make 16 bit
    3330/    91C1 : 09                                  add   hl, bc           ; skip over space for indices
    3331/    91C2 : 09                                  add   hl, bc
    3332/    91C3 : 23                                  inc   hl               ; +1 for #indices
    3333/    91C4 :                                                            ; HL' points to list of array elements
    3334/    91C4 :                                                            ; note: even for a multidimensional array,
    3335/    91C4 :                                                            ; these are sequential, and the actual element
    3336/    91C4 :                                                            ; subscripts are irrelevant
    3337/    91C4 :                     
    3338/    91C4 :                     ; loop to handle string arrays
    3339/    91C4 : D1                  gc_inner_array: pop   de               ; DE' is ptr to next array element
    3340/    91C5 : (MACRO)                             CPHL_DE                ; compare ptr to curr. element with end of array
    3340/    91C5 : 7C                                  ld    a, h
    3340/    91C6 : 92                                  sub   d
    3340/    91C7 : 20 02                               jr    nz, m1
    3340/    91C9 : 7D                                  ld    a, l
    3340/    91CA : 93                                  sub   e
    3340/    91CB :                     m1:
    3341/    91CB : 28 DE                               jr    z, loc_14AB      ; end reached? loop
    3342/    91CD : D5                                  push  de               ; restore end of element list of array
    3343/    91CE : 01 C4 91                            ld    bc, gc_inner_array ; setup outer loop to find highest string
    3344/    91D1 :                     
    3345/    91D1 :                     ; find xstring (string with highest address below string_top)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 62 - 8/15/2019 11:33:6


    3346/    91D1 :                     ; IX is ptr to descriptor for this
    3347/    91D1 :                     gc_inner_find_xstring:            
    3348/    91D1 : C5                                  push  bc               ; push address for loop
    3349/    91D2 :                     
    3350/    91D2 :                     ; HL points to current string descriptor
    3351/    91D2 :                     gc_inner_find_xstring1:            
    3352/    91D2 : 7E                                  ld    a, (hl)          ; A' = length of string
    3353/    91D3 : 23                                  inc   hl
    3354/    91D4 : 23                                  inc   hl
    3355/    91D5 : (MACRO)                             LDDE_M                 ; DE' is addr of potential xstring
    3355/    91D5 : 5E                                  ld    e, (hl)
    3355/    91D6 : 23                                  inc   hl
    3355/    91D7 : 56                                  ld    d, (hl)
    3356/    91D8 : 23                                  inc   hl               ; advance to next entry
    3357/    91D9 : 23                                  inc   hl
    3358/    91DA : 23                                  inc   hl
    3359/    91DB : C8                                  ret   z                ; Z was 1? yes return to inner loop
    3360/    91DC :                                                            ; note: on call of gc_inner_find_xstring, Z=0
    3361/    91DC :                                                            ; when entering through gc_inner_find_xstring1,
    3362/    91DC :                                                            ; Z depends on whether entered
    3363/    91DC :                                                            ; with a string var name (bit7=1)
    3364/    91DC : B7                                  or    a                ; is string length = 0?
    3365/    91DD : C8                                  ret   z                ; yes, return to inner loop
    3366/    91DE : D5                                  push  de               ; transfer string address into std reg set
    3367/    91DF : D9                                  exx                    ; back to std register set
    3368/    91E0 : C1                                  pop   bc               ; restore string address
    3369/    91E1 : 2A 48 0C                            ld    hl, (string_top) ; get current top of string set
    3370/    91E4 : ED 42                               sbc   hl, bc           ; subtract string address
    3371/    91E6 : D9                                  exx                    ; alternate register set
    3372/    91E7 : D8                                  ret   c                ; is above string_top, already GC'd
    3373/    91E8 : D9                                  exx                    ; back to standard set
    3374/    91E9 : (MACRO)                             LDHL_DE                ; DE is currently highest string
    3374/    91E9 : 62                                  ld    h, d
    3374/    91EA : 6B                                  ld    l, e
    3375/    91EB : ED 42                               sbc   hl, bc           ; subtract curr_high_string - stringaddr
    3376/    91ED : D9                                  exx                    ; alternate set
    3377/    91EE : D0                                  ret   nc               ; is below curr_high_string
    3378/    91EF :                                                            ; don't handle now, and return
    3379/    91EF : D9                                  exx                    ; standard set
    3380/    91F0 : 50                                  ld    d, b             ; DE = new curr_high_string
    3381/    91F1 : 59                                  ld    e, c
    3382/    91F2 : D9                                  exx                    ; alternate set
    3383/    91F3 : 08                                  ex    af, af'          ; restore string length requested
    3384/    91F4 :                                                            ; and set CY=1 in std set: found a descriptor
    3385/    91F4 : E5                                  push  hl               ; put descr of curr_high_string into IX
    3386/    91F5 : DD E1                               pop   ix
    3387/    91F7 : C9                                  ret                    ; return to inner loop
    3388/    91F8 :                     
    3389/    91F8 :                     ; we have found the string descriptor of xstring in IX
    3390/    91F8 : 08                  loc_14F8:       ex    af, af'          ; check std set CY flag: IX contains a descriptor
    3391/    91F9 : D0                                  ret   nc               ; no, we haven't found one,
    3392/    91FA :                                                            ; -> terminate garbage collection.
    3393/    91FA : D9                                  exx                    ; switch back to std set
    3394/    91FB : 2A 48 0C                            ld    hl, (string_top) ; get start of string space
    3395/    91FE : EB                                  ex    de, hl           ; into DE
    3396/    91FF : 4F                                  ld    c, a             ; get string length of xstring
    3397/    9200 : 06 00                               ld    b, 0             ; make 16 bit in BC
    3398/    9202 : 09                                  add   hl, bc
    3399/    9203 : 2B                                  dec   hl               ; move string below string_top area
    3400/    9204 : ED B8                               lddr
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 63 - 8/15/2019 11:33:6


    3401/    9206 : (MACRO)                             LDHL_DE                ; HL is new string_top
    3401/    9206 : 62                                  ld    h, d
    3401/    9207 : 6B                                  ld    l, e
    3402/    9208 : 13                                  inc   de               ; DE is new start of string
    3403/    9209 : DD 72 FD                            ld    (ix-3), d        ; adjust ptr to string in descriptor
    3404/    920C : DD 73 FC                            ld    (ix-4), e        ; IX points to end of 6 byte string descriptor
    3405/    920F : C3 76 91                            jp    gc_outer_while   ; loop again with next string
    3406/    9212 :                     
    3407/    9212 : C5                  string_add:     push  bc
    3408/    9213 : E5                                  push  hl
    3409/    9214 : 2A 66 0C                            ld    hl, (fpaccu_mant32)
    3410/    9217 : E3                                  ex    (sp), hl
    3411/    9218 : CD 14 8C                            call  expr
    3412/    921B : E3                                  ex    (sp), hl
    3413/    921C : CD 89 8B                            call  assert_string
    3414/    921F : 7E                                  ld    a, (hl)
    3415/    9220 : E5                                  push  hl
    3416/    9221 : 2A 66 0C                            ld    hl, (fpaccu_mant32)
    3417/    9224 : E5                                  push  hl
    3418/    9225 : 86                                  add   a, (hl)
    3419/    9226 : 1E 0F                               ld    e, 0Fh        ; error    code
    3420/    9228 : DA 7E 81                            jp    c, print_error    ; "string to long error"
    3421/    922B : CD DE 90                            call  straccu_reserve_strspace
    3422/    922E : D1                                  pop   de
    3423/    922F : CD 67 92                            call  peek_str_stringstk
    3424/    9232 : E3                                  ex    (sp), hl
    3425/    9233 : CD 66 92                            call  pop_str_stringstk
    3426/    9236 : E5                                  push  hl
    3427/    9237 : 2A 46 0C                            ld    hl, (straccu_addr)
    3428/    923A : EB                                  ex    de, hl
    3429/    923B : CD 49 92                            call  sub_1549
    3430/    923E : CD 49 92                            call  sub_1549
    3431/    9241 : 21 AC 8B                            ld    hl, loc_EAC
    3432/    9244 : E3                                  ex    (sp), hl
    3433/    9245 : E5                                  push  hl
    3434/    9246 : C3 0C 91                            jp    straccu_push_exprstack
    3435/    9249 :                     
    3436/    9249 : E1                  sub_1549:       pop   hl
    3437/    924A : E3                                  ex    (sp), hl
    3438/    924B : (MACRO)                             LDBC_M       
    3438/    924B : 4E                                  ld    c, (hl)
    3438/    924C : 23                                  inc   hl
    3438/    924D : 46                                  ld    b, (hl)
    3439/    924E : 23                                  inc   hl
    3440/    924F : (MACRO)                             LDHL_M A    
    3440/    924F : 7E                                  ld    A, (hl)
    3440/    9250 : 23                                  inc   hl
    3440/    9251 : 66                                  ld    h, (hl)
    3440/    9252 : 6F                                  ld    l, A
    3441/    9253 : 78                  loc_1553:       ld    a, b
    3442/    9254 : B1                                  or    c
    3443/    9255 : C8                                  ret   z
    3444/    9256 : ED B0                               ldir
    3445/    9258 : C9                                  ret
    3446/    9259 :                     
    3447/    9259 :                     ; copy a string in BC of length A to DE
    3448/    9259 : (MACRO)             copy_string:    LDHL_BC                ; get source length into HL
    3448/    9259 : 60                                  ld    h, b
    3448/    925A : 69                                  ld    l, c
    3449/    925B : 4F                                  ld    c, a             ; get length into BC
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 64 - 8/15/2019 11:33:6


    3450/    925C : 06 00                               ld    b, 0
    3451/    925E : 18 F3                               jr    loc_1553         ; move string to DE space
    3452/    9260 :                     
    3453/    9260 :                     ; get string, descriptor in fpaccu, HL points to descriptor
    3454/    9260 :                     string_expression:
    3455/    9260 : CD 89 8B                            call  assert_string    ; verify that fpaccu contains a string result
    3456/    9263 :                     
    3457/    9263 :                     ; get string from stringstk, pointed to by fpaccu
    3458/    9263 : 2A 66 0C            fpaccu_getstr:  ld    hl, (fpaccu_mant32) ; point to string on exprstack
    3459/    9266 :                     
    3460/    9266 :                     ; popstring descr from exprstack, and discard it from string space, if easily
    3461/    9266 :                     ; possible
    3462/    9266 :                     pop_str_stringstk:
    3463/    9266 : EB                                  ex    de, hl           ; move to DE, i.e. pop
    3464/    9267 :                     ; discard string from exprstack, and also discard it from string space, if at
    3465/    9267 :                     ; the beginning of area
    3466/    9267 :                     peek_str_stringstk:
    3467/    9267 : CD 83 92                            call  peekpop_str_stringstk ; popstring descr from stringstk
    3468/    926A : EB                                  ex    de, hl           ; DE is current stkptr
    3469/    926B :                                                            ; HL is previous stkptr
    3470/    926B : C0                                  ret   nz               ; exit if not popped
    3471/    926C : D5                                  push  de               ; save stkptr
    3472/    926D : 50                                  ld    d, b             ; DE is address of string
    3473/    926E : 59                                  ld    e, c
    3474/    926F : 1B                                  dec   de               ; decrement stringptr
    3475/    9270 : 4E                                  ld    c, (hl)          ; get string length into C
    3476/    9271 : 2A 48 0C                            ld    hl, (string_top) ; get top of strings ptr
    3477/    9274 : (MACRO)                             CPHL_DE                ; is at string space?
    3477/    9274 : 7C                                  ld    a, h
    3477/    9275 : 92                                  sub   d
    3477/    9276 : 20 02                               jr    nz, m1
    3477/    9278 : 7D                                  ld    a, l
    3477/    9279 : 93                                  sub   e
    3477/    927A :                     m1:
    3478/    927A : 20 05                               jr    nz, loc_1581     ; no, some other string, restore stringstkptr
    3479/    927C : 47                                  ld    b, a             ; clear B (A is zero)
    3480/    927D : 09                                  add   hl, bc           ; yes, discard string from string space
    3481/    927E : 22 48 0C                            ld    (string_top), hl
    3482/    9281 : E1                  loc_1581:       pop   hl
    3483/    9282 : C9                                  ret
    3484/    9283 :                     
    3485/    9283 :                     ; peek or pop a value from expr stack
    3486/    9283 :                     ; if DE == (stringstk-6) pop, else peek
    3487/    9283 :                     peekpop_str_stringstk:
    3488/    9283 : 2A 06 0C                            ld    hl, (stringstkptr) ; point to exprstack
    3489/    9286 : 2B                                  dec   hl               ; skip 2 unused bytes in exprstack
    3490/    9287 : 2B                                  dec   hl
    3491/    9288 : 2B                                  dec   hl
    3492/    9289 : 46                                  ld    b, (hl)          ; get string address into BC
    3493/    928A : 2B                                  dec   hl
    3494/    928B : 4E                                  ld    c, (hl)
    3495/    928C : 2B                                  dec   hl               ; skip unused byte
    3496/    928D : 2B                                  dec   hl               ; skip string length
    3497/    928E : (MACRO)                             CPHL_DE                ; compare ptr with DE value
    3497/    928E : 7C                                  ld    a, h
    3497/    928F : 92                                  sub   d
    3497/    9290 : 20 02                               jr    nz, m1
    3497/    9292 : 7D                                  ld    a, l
    3497/    9293 : 93                                  sub   e
    3497/    9294 :                     m1:
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 65 - 8/15/2019 11:33:6


    3498/    9294 :                                                            ; something strange happened, don't pop
    3499/    9294 : C0                                  ret   nz               ; but exit with NZ
    3500/    9295 : 22 06 0C                            ld    (stringstkptr), hl ; store ptr
    3501/    9298 : C9                                  ret
    3502/    9299 :                     
    3503/    9299 : 01 32 8F            math_len:       ld    bc, uA_to_fpaccu ; push function convert A to fpaccu
    3504/    929C : C5                                  push  bc
    3505/    929D :                     
    3506/    929D :                     ; parse a string argument
    3507/    929D :                     ; HL = fpaccu
    3508/    929D :                     ; A = string length
    3509/    929D :                     fpaccu_get_string:
    3510/    929D : CD 60 92                            call  string_expression ; get a string expression
    3511/    92A0 : AF                                  xor   a                ; clear D
    3512/    92A1 : 57                                  ld    d, a
    3513/    92A2 : 32 02 0C                            ld    (expr_type), a   ; set resulting exprtype to numeric
    3514/    92A5 : 7E                                  ld    a, (hl)          ; get string length
    3515/    92A6 : B7                                  or    a                ; set flags
    3516/    92A7 : C9                                  ret
    3517/    92A8 :                     
    3518/    92A8 : CD 9D 92            math_asc:       call  fpaccu_get_string ; get string
    3519/    92AB : 28 58                               jr    z, error_illfunc ; is length zero? error
    3520/    92AD : 23                                  inc   hl               ; advance to string address
    3521/    92AE : 23                                  inc   hl
    3522/    92AF : (MACRO)                             LDDE_M                 ; get address into DE
    3522/    92AF : 5E                                  ld    e, (hl)
    3522/    92B0 : 23                                  inc   hl
    3522/    92B1 : 56                                  ld    d, (hl)
    3523/    92B2 : 1A                                  ld    a, (de)          ; get first char
    3524/    92B3 : C3 32 8F                            jp    uA_to_fpaccu     ; convert to FPaccu
    3525/    92B6 :                     
    3526/    92B6 : 3E 01               math_chrs:      ld    a, 1             ; set request size
    3527/    92B8 : CD DE 90                            call  straccu_reserve_strspace ; reserve space for 1 byte of string
    3528/    92BB : CD 1E 94                            call  fpaccu_u8        ; Get a single byte
    3529/    92BE : 2A 46 0C                            ld    hl, (straccu_addr) ; load address of reserved string
    3530/    92C1 : 73                                  ld    (hl), e          ; store char into string space
    3531/    92C2 : C1                  loc_15C2:       pop   bc               ; drop caller
    3532/    92C3 : C3 0C 91                            jp    straccu_push_exprstack ; push result on exprstack
    3533/    92C6 :                     
    3534/    92C6 : CD FF 93            math_lefts:     call  get_numarg_stack ; get the numeric argument in B
    3535/    92C9 : AF                                  xor   a                ; starting position is 0
    3536/    92CA : E3                  loc_15CA:       ex    (sp), hl         ; HL is string descriptor
    3537/    92CB : 4F                                  ld    c, a             ; copy starting position
    3538/    92CC : 3E                                  db    3Eh              ; LD A, xx to skip next instruction
    3539/    92CD : E5                  loc_15CD:       push  hl               ; ** skipped, save descriptor
    3540/    92CE : E5                  loc_15CE:       push  hl               ; save string descriptor
    3541/    92CF : 7E                                  ld    a, (hl)          ; get length of string
    3542/    92D0 : B8                                  cp    b                ; compare with LEFT$ arg
    3543/    92D1 : 38 02                               jr    c, loc_15D5      ; is less?, yes skip
    3544/    92D3 : 78                                  ld    a, b             ; B = minimum length
    3545/    92D4 : 11                                  db    11h              ; LD DE, xxxx to skip next instruction
    3546/    92D5 :                                                            ; is uncritical because next call will destroy DE
    3547/    92D5 : 0E 00               loc_15D5:       ld    c, 0             ; ** skipped
    3548/    92D7 : C5                                  push  bc               ; save B, C
    3549/    92D8 : CD 49 91                            call  reserve_strspace ; reserve space for result string
    3550/    92DB : C1                                  pop   bc
    3551/    92DC : E1                                  pop   hl               ; reload descriptor
    3552/    92DD : E5                                  push  hl
    3553/    92DE : 23                                  inc   hl               ; point to string addr
    3554/    92DF : 23                                  inc   hl
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 66 - 8/15/2019 11:33:6


    3555/    92E0 : (MACRO)                             LDHL_M B               ; get string address into HL
    3555/    92E0 : 46                                  ld    B, (hl)
    3555/    92E1 : 23                                  inc   hl
    3555/    92E2 : 66                                  ld    h, (hl)
    3555/    92E3 : 68                                  ld    l, B
    3556/    92E4 : 06 00                               ld    b, 0             ; make C 16 bit
    3557/    92E6 : 09                                  add   hl, bc           ; add starting position
    3558/    92E7 : (MACRO)                             LDBC_HL                ; into BC
    3558/    92E7 : 44                                  ld    b, h
    3558/    92E8 : 4D                                  ld    c, l
    3559/    92E9 : CD E1 90                            call  straccu_store    ; setup target string descriptor (A, DE)
    3560/    92EC : CD 59 92                            call  copy_string      ; copy string
    3561/    92EF : D1                                  pop   de               ; restore original string descr
    3562/    92F0 : CD 67 92                            call  peek_str_stringstk ; discard original string, if possible
    3563/    92F3 : C3 0C 91                            jp    straccu_push_exprstack ; put result on expr stack
    3564/    92F6 :                     
    3565/    92F6 : CD FF 93            math_rights:    call  get_numarg_stack ; get numeric argument
    3566/    92F9 : D1                                  pop   de               ; reload original string descriptor
    3567/    92FA : D5                                  push  de
    3568/    92FB : 1A                                  ld    a, (de)          ; get string length
    3569/    92FC : 90                                  sub   b                ; subtract right position to be copied
    3570/    92FD : 18 CB                               jr    loc_15CA         ; use LEFT$ code to copy substring
    3571/    92FF :                     
    3572/    92FF : EB                  math_mids:      ex    de, hl           ; HL is string descriptor
    3573/    9300 : 7E                                  ld    a, (hl)          ; get string length
    3574/    9301 : D1                                  pop   de               ; restore first argument
    3575/    9302 : 43                                  ld    b, e             ; into B
    3576/    9303 : 04                                  inc   b                ; set flags
    3577/    9304 : 05                                  dec   b
    3578/    9305 : CA 44 87            error_illfunc:  jp    z, illfunc_error ; 1st arg is zero?, error
    3579/    9308 : C5                                  push  bc               ; save starting position
    3580/    9309 : 1E FF                               ld    e, 0FFh          ; preload maximum length
    3581/    930B : FE 29                               cp    CHAR_RPAREN      ; no third argument?
    3582/    930D : 28 08                               jr    z, loc_1617      ; no, don't have it, skip
    3583/    930F : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    3583/    930F : 3E 2C                               ld    a, CHAR_COMMA
    3583/    9311 : CD 51 81                            call  expect_char
    3584/    9314 : CD 1B 94                            call  expression_u8_ae ; get an 8 bit expression in E
    3585/    9317 : (MACRO)             loc_1617:       EXPECT CHAR_RPAREN     ; now really expect closing parenthesis
    3585/    9317 : 3E 29                               ld    a, CHAR_RPAREN
    3585/    9319 : CD 51 81                            call  expect_char
    3586/    931C : F1                                  pop   af               ; restore starting position in A
    3587/    931D : E3                                  ex    (sp), hl         ; stack is curlineptr
    3588/    931E :                                                            ; HL is string descriptor
    3589/    931E : 3D                                  dec   a                ; adjust starting pos to 0-justified
    3590/    931F : BE                                  cp    (hl)             ; compare with string pos
    3591/    9320 : 06 00                               ld    b, 0
    3592/    9322 : 30 AA                               jr    nc, loc_15CE
    3593/    9324 : 4F                                  ld    c, a             ; starting pos, save in C
    3594/    9325 : 7E                                  ld    a, (hl)          ; get length again
    3595/    9326 : 91                                  sub   c                ; subtract start
    3596/    9327 : BB                                  cp    e                ; compare with length to copy
    3597/    9328 : 47                                  ld    b, a
    3598/    9329 : 38 A3                               jr    c, loc_15CE
    3599/    932B : 43                                  ld    b, e             ; calculate minimum value
    3600/    932C : 18 A0                               jr    loc_15CE         ; and use LEFT$ to copy B chars from position C
    3601/    932E :                     
    3602/    932E : E1                  math_instr:     pop   hl               ; restore curlineptr
    3603/    932F : (MACRO)                             EXPECT CHAR_LPAREN     ; require '('
    3603/    932F : 3E 28                               ld    a, CHAR_LPAREN
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 67 - 8/15/2019 11:33:6


    3603/    9331 : CD 51 81                            call  expect_char
    3604/    9334 : CD 95 8B                            call  string_expression1 ; get first argument
    3605/    9337 : ED 5B 66 0C                         ld    de, (fpaccu_mant32)
    3606/    933B : D5                                  push  de               ; save ptr to string
    3607/    933C : (MACRO)                             EXPECT CHAR_COMMA      ; require comma
    3607/    933C : 3E 2C                               ld    a, CHAR_COMMA
    3607/    933E : CD 51 81                            call  expect_char
    3608/    9341 : CD 95 8B                            call  string_expression1 ; get second argument
    3609/    9344 : ED 5B 66 0C                         ld    de, (fpaccu_mant32) ; save ptr to second string
    3610/    9348 : D5                                  push  de
    3611/    9349 : 01 FF 00                            ld    bc, 0FFh         ; preload start B=0, length C=FF
    3612/    934C : 7E                                  ld    a, (hl)          ; get next char
    3613/    934D : FE 2C                               cp    CHAR_COMMA       ; does a start position follow?
    3614/    934F : 20 15                               jr    nz, loc_1666     ; no, search from beginning to end
    3615/    9351 : C5                                  push  bc               ; save BC
    3616/    9352 : CD 18 94                            call  next_fpaccu_u8   ; get a starting position
    3617/    9355 : C1                                  pop   bc               ; restore BC
    3618/    9356 : 1D                                  dec   e                ; adjust start position 0-based
    3619/    9357 : 43                                  ld    b, e             ; put into B (starting position)
    3620/    9358 : 1C                                  inc   e                ; check if it was 255
    3621/    9359 : 28 AA                               jr    z, error_illfunc ; yes error
    3622/    935B : 7E                                  ld    a, (hl)          ; get next char
    3623/    935C : FE 2C                               cp    CHAR_COMMA       ; is it a comma?
    3624/    935E : 20 06                               jr    nz, loc_1666     ; no, search from given start position to end
    3625/    9360 : C5                                  push  bc               ; save BC
    3626/    9361 : CD 18 94                            call  next_fpaccu_u8   ; get length argument
    3627/    9364 : C1                                  pop   bc               ; restore start/length
    3628/    9365 : 4B                                  ld    c, e             ; put length argument
    3629/    9366 : (MACRO)             loc_1666:       EXPECT CHAR_RPAREN     ; require closing paren
    3629/    9366 : 3E 29                               ld    a, CHAR_RPAREN
    3629/    9368 : CD 51 81                            call  expect_char
    3630/    936B : E3                                  ex    (sp), hl         ; stack is curlineptr
    3631/    936C :                                                            ; DE is second string
    3632/    936C : C5                                  push  bc               ; save start/length
    3633/    936D : CD 66 92                            call  pop_str_stringstk ; discard second string
    3634/    9370 : C1                                  pop   bc               ; restore start/length
    3635/    9371 : EB                                  ex    de, hl           ; DE is second string
    3636/    9372 : E1                                  pop   hl               ; restore curlineptr
    3637/    9373 : E3                                  ex    (sp), hl         ; stack is curlineptr
    3638/    9374 :                                                            ; HL is first string
    3639/    9374 : D5                                  push  de               ; save second string
    3640/    9375 : C5                                  push  bc               ; save start/length
    3641/    9376 : CD 66 92                            call  pop_str_stringstk ; discard first string
    3642/    9379 : C1                                  pop   bc               ; restore start/length
    3643/    937A : D1                                  pop   de               ; restore second string
    3644/    937B : 78                                  ld    a, b             ; get start position
    3645/    937C : 96                                  sub   (hl)             ; get length of first string
    3646/    937D : D2 D1 93                            jp    nc, loc_16D1     ; check beyond end of string? exit - no match
    3647/    9380 : ED 44                               neg                    ; length - start
    3648/    9382 : B9                                  cp    c                ; compare with length to search
    3649/    9383 : 30 01                               jr    nc, loc_1686
    3650/    9385 : 4F                                  ld    c, a             ; set minimum of both
    3651/    9386 : 23                  loc_1686:       inc   hl               ; advance to string address
    3652/    9387 : 23                                  inc   hl
    3653/    9388 : (MACRO)                             LDHL_M A               ; into HL
    3653/    9388 : 7E                                  ld    A, (hl)
    3653/    9389 : 23                                  inc   hl
    3653/    938A : 66                                  ld    h, (hl)
    3653/    938B : 6F                                  ld    l, A
    3654/    938C : E5                                  push  hl               ; save 1st address
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 68 - 8/15/2019 11:33:6


    3655/    938D : C5                                  push  bc               ; save start/length
    3656/    938E : 48                                  ld    c, b             ; start as 16 bit
    3657/    938F : 06 00                               ld    b, 0
    3658/    9391 : 09                                  add   hl, bc           ; build string start poisiton
    3659/    9392 : C1                                  pop   bc               ; restore start/lengh
    3660/    9393 : EB                                  ex    de, hl           ; DE is first string address
    3661/    9394 :                                                            ; HL is second string descriptor
    3662/    9394 : 79                                  ld    a, c             ; get search length
    3663/    9395 : 96                                  sub   (hl)             ; subtract length of 2nd string
    3664/    9396 : 38 38                               jr    c, loc_16D0      ; is less, cannot match in this range, exit
    3665/    9398 : 3C                                  inc   a                ; add 1 to compare length
    3666/    9399 : 4F                                  ld    c, a             ; length to check in C
    3667/    939A : 46                                  ld    b, (hl)          ; get length of 2nd string in B
    3668/    939B : 23                                  inc   hl               ; advance to string address
    3669/    939C : 23                                  inc   hl
    3670/    939D : (MACRO)                             LDHL_M A               ; get string address in HL
    3670/    939D : 7E                                  ld    A, (hl)
    3670/    939E : 23                                  inc   hl
    3670/    939F : 66                                  ld    h, (hl)
    3670/    93A0 : 6F                                  ld    l, A
    3671/    93A1 : EB                                  ex    de, hl           ; DE is addr of 2nd string
    3672/    93A2 :                                                            ; HL is addr of 1st string
    3673/    93A2 : 78                                  ld    a, b             ; get length of 2nd string
    3674/    93A3 : B7                                  or    a
    3675/    93A4 : 28 1D                               jr    z, loc_16C3      ; is zero?, skip
    3676/    93A6 : C5                  loc_16A6:       push  bc               ; save B = 2nd length, C = compare width
    3677/    93A7 : 06 00                               ld    b, 0             ; make 16 bit comparison length
    3678/    93A9 : 1A                                  ld    a, (de)          ; get first char to search
    3679/    93AA : ED B1                               cpir                   ; find position of first char of
    3680/    93AC :                                                            ; 2nd string in 1st string
    3681/    93AC : 79                                  ld    a, c             ; save position
    3682/    93AD : C1                                  pop   bc               ; restore length, compare width
    3683/    93AE : 20 20                               jr    nz, loc_16D0     ; not found
    3684/    93B0 : 4F                                  ld    c, a             ; set new compare length
    3685/    93B1 : C5                                  push  bc               ; save regs
    3686/    93B2 : D5                                  push  de
    3687/    93B3 : E5                                  push  hl
    3688/    93B4 : 18 06                               jr    loc_16BC         ; found first char in 1st string, skip
    3689/    93B6 : 13                  loop16B6:       inc   de               ;<+ advance ptr to char in 2nd string
    3690/    93B7 : 1A                                  ld    a, (de)          ; | get char
    3691/    93B8 : BE                                  cp    (hl)             ; | does it match 1st string?
    3692/    93B9 : 20 03                               jr    nz, loc_16BE     ; | no, leave loop
    3693/    93BB : 23                                  inc   hl               ; | yes, advance to next position in 1st string
    3694/    93BC : 10 F8               loc_16BC:       djnz  loop16B6         ;-+ end of 2nd string reached? no loop
    3695/    93BE : E1                  loc_16BE:       pop   hl               ; restore regs
    3696/    93BF : D1                                  pop   de
    3697/    93C0 : C1                                  pop   bc
    3698/    93C1 : 20 09                               jr    nz, loc_16CC     ; no match, skip
    3699/    93C3 : D1                  loc_16C3:       pop   de               ; drop 2nd string descr
    3700/    93C4 : ED 52                               sbc   hl, de           ; subtract string positions
    3701/    93C6 : 7D                                  ld    a, l             ; get difference into A -> returned position
    3702/    93C7 : CD 32 8F            loc_16C7:       call  uA_to_fpaccu     ; convert position to FP
    3703/    93CA : E1                                  pop   hl               ; restore curlineptr
    3704/    93CB : C9                                  ret                    ; done
    3705/    93CC : 79                  loc_16CC:       ld    a, c             ; at end of range to search?
    3706/    93CD : B7                                  or    a
    3707/    93CE : 20 D6                               jr    nz, loc_16A6     ; no, try again
    3708/    93D0 : D1                  loc_16D0:       pop   de               ; drop saved 2nd string descr
    3709/    93D1 : AF                  loc_16D1:       xor    a               ; return position 0 (not found)
    3710/    93D2 : 18 F3                               jr    loc_16C7         ; return result
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 69 - 8/15/2019 11:33:6


    3711/    93D4 :                     
    3712/    93D4 :                     ; process INP(port)
    3713/    93D4 : CD 1E 94            math_inp:       call  fpaccu_u8        ; get port number in A
    3714/    93D7 : 4F                                  ld    c, a             ; move into C
    3715/    93D8 : ED 78                               in    a, (c)           ; read from port into A
    3716/    93DA : C3 32 8F                            jp    uA_to_fpaccu     ; convert to fpaccu
    3717/    93DD :                     
    3718/    93DD :                     ; process OUT command
    3719/    93DD : CD 0A 94            exec_out:       call  expression_2u8   ; get port in C, data in A
    3720/    93E0 : ED 79                               out    (c), a          ; do out port
    3721/    93E2 : C9                                  ret
    3722/    93E3 :                     
    3723/    93E3 :                     ; process WAIT command
    3724/    93E3 : CD 0A 94            exec_wait:      call  expression_2u8   ; get port in C, mask in A
    3725/    93E6 : 47                                  ld    b, a             ; save mask in B
    3726/    93E7 : C5                                  push  bc               ; save mask
    3727/    93E8 : 1E 00                               ld    e, 0             ; exor argument
    3728/    93EA : CD 48 86                            call  skipspace        ; advance
    3729/    93ED : 28 08                               jr    z, loc_16F7      ; end of line?, no exor
    3730/    93EF : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    3730/    93EF : 3E 2C                               ld    a, CHAR_COMMA
    3730/    93F1 : CD 51 81                            call  expect_char
    3731/    93F4 :                     ;;;                call  expression_u8_ae ; get exxor expression in E
    3732/    93F4 : CD 1B 84            		call	0841Bh	; vp:definitiv ein Fehler !!!
    3733/    93F7 : C1                  loc_16F7:       pop   bc               ; restore mask
    3734/    93F8 : ED 78               loop16F8:       in    a, (c)           ;<+ read port
    3735/    93FA : AB                                  xor   e                ; | exor with arg
    3736/    93FB : A0                                  and   b                ; | mask out bits
    3737/    93FC : 28 FA                               jr    z, loop16F8      ;-+ wait as long port remains zero
    3738/    93FE :                                                            ; DANGEROUS: if port bit never changes,
    3739/    93FE :                                                            ; program will hang forever, need RESET
    3740/    93FE : C9                                  ret
    3741/    93FF :                     
    3742/    93FF :                     ; get numeric second arg off stack, which was
    3743/    93FF :                     ; pushed there by function evaluator
    3744/    93FF :                     get_numarg_stack:
    3745/    93FF : EB                                  ex    de, hl           ; HL = curlineptr
    3746/    9400 : (MACRO)                             EXPECT CHAR_RPAREN     ; expect closing paren
    3746/    9400 : 3E 29                               ld    a, CHAR_RPAREN
    3746/    9402 : CD 51 81                            call  expect_char
    3747/    9405 : C1                                  pop   bc               ; restore caller
    3748/    9406 : D1                                  pop   de               ; restore 2nd arg of LEFT$/RIGHT$ off stack
    3749/    9407 : C5                                  push  bc               ; push caller
    3750/    9408 : 43                                  ld    b, e             ; get argument in B
    3751/    9409 : C9                                  ret
    3752/    940A :                     
    3753/    940A :                     ; get 2 u8 expressions, return first in C, second in E
    3754/    940A : CD 1B 94            expression_2u8: call  expression_u8_ae ; get an 8 bit expression
    3755/    940D : D5                                  push  de               ; save it
    3756/    940E : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    3756/    940E : 3E 2C                               ld    a, CHAR_COMMA
    3756/    9410 : CD 51 81                            call  expect_char
    3757/    9413 : CD 1B 94                            call  expression_u8_ae ; get an 8 bit expression in A and E
    3758/    9416 : C1                                  pop   bc               ; return 1st arg in C
    3759/    9417 : C9                                  ret                    ; return 2nd in A and E
    3760/    9418 :                     
    3761/    9418 :                     ; get next char and parse a 8 bit expression
    3762/    9418 : CD 47 86            next_fpaccu_u8: call  nextchar
    3763/    941B :                     
    3764/    941B :                     ; evaluate an unsigned 8 bit expression, return in A or E
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 70 - 8/15/2019 11:33:6


    3765/    941B :                     expression_u8_ae:
    3766/    941B : CD 85 8B                            call  expression
    3767/    941E : CD 27 87            fpaccu_u8:      call  fpaccu_to_u16
    3768/    9421 : 7A                                  ld    a, d             ; larger than 8 bit?
    3769/    9422 : B7                                  or    a
    3770/    9423 : C2 44 87                            jp    nz, illfunc_error ; yes, error
    3771/    9426 : CD 48 86                            call  skipspace        ; advance to non-whitespace
    3772/    9429 : 7B                                  ld    a, e             ; get result in A and E
    3773/    942A : C9                                  ret
    3774/    942B :                     
    3775/    942B : CD 9D 92            math_val:       call  fpaccu_get_string ; evaluate string expression
    3776/    942E :                                                            ; set exprtype to numeric
    3777/    942E : CA 0E 9D                            jp    z, fpaccu_zero   ; length of string zero?
    3778/    9431 :                                                            ; yes, return 0
    3779/    9431 : 5F                                  ld    e, a             ; store string length
    3780/    9432 :                                                            ; note: D is 0
    3781/    9432 : 23                                  inc   hl
    3782/    9433 : 23                                  inc   hl
    3783/    9434 : (MACRO)                             LDHL_M A               ; get string address into HL
    3783/    9434 : 7E                                  ld    A, (hl)
    3783/    9435 : 23                                  inc   hl
    3783/    9436 : 66                                  ld    h, (hl)
    3783/    9437 : 6F                                  ld    l, A
    3784/    9438 : E5                                  push  hl               ; save start of string
    3785/    9439 : 19                                  add   hl, de           ; get end of string
    3786/    943A : 46                                  ld    b, (hl)          ; save original value
    3787/    943B : 72                                  ld    (hl), d          ; make 0-terminated
    3788/    943C : E3                                  ex    (sp), hl         ; save end of string, HL is start of string
    3789/    943D : C5                                  push  bc               ; save BC
    3790/    943E : 7E                                  ld    a, (hl)          ; load first char of number
    3791/    943F : CD DE A0                            call  parse_number_fpaccu ; convert string to number
    3792/    9442 : C1                                  pop   bc               ; restore BC
    3793/    9443 : E1                                  pop   hl               ; restore end of string
    3794/    9444 : 70                                  ld    (hl), b          ; restore original value
    3795/    9445 : C9                                  ret                    ; done
    3796/    9446 :                     
    3797/    9446 :                     ; process SWITCH command
    3798/    9446 : 38 09               exec_switch:    jr    c, loc_1751      ; has an argument?
    3799/    9448 : CD 1B 80                            call  IOCHECK          ; get IO byte of Zapple monitor
    3800/    944B : EE 03                               xor   3                ; invert (why that?)
    3801/    944D : 4F                  loc_174D:       ld    c, a             ; put into C
    3802/    944E : C3 1E 80                            jp    IOSET            ; set it
    3803/    9451 : CD 1B 94            loc_1751:       call  expression_u8_ae ; get an 8 bit expression
    3804/    9454 : FE 04                               cp    4                ; is it >= 4?
    3805/    9456 : D2 6D 81                            jp    nc, syntax_error ; yes, error
    3806/    9459 : 47                                  ld    b, a             ; save it
    3807/    945A : CD 1B 80                            call  IOCHECK          ; get IO byte from Zapple monitor
    3808/    945D : E6 FC                               and   0FCh             ; mask out lowest bits
    3809/    945F : B0                                  or    b                ; put in new console switch
    3810/    9460 : 18 EB                               jr    loc_174D         ; set IO byte
    3811/    9462 :                     
    3812/    9462 :                     ; process LWIDTH, WIDTH commands
    3813/    9462 : CD 9F 95            exec_lwidth:    call  temporary_select_printer
    3814/    9465 : CD 1B 94            exec_width:     call  expression_u8_ae ; get an 8 bit expression
    3815/    9468 : FE 0E                               cp    14               ; less or equal 14?
    3816/    946A : DA 44 87                            jp    c, illfunc_error ; invalid
    3817/    946D : FD 77 01                            ld    (iy+ioparams_linelength), a ; store as line width
    3818/    9470 : 4F                                  ld    c, a             ; get width again
    3819/    9471 : D6 0E               loop1771:       sub   14               ;<+ subtract 14
    3820/    9473 : 30 FC                               jr    nc, loop1771     ;-+ loop until negative
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 71 - 8/15/2019 11:33:6


    3821/    9475 : C6 1C                               add   a, 28            ; make a number between 14 and 27
    3822/    9477 : ED 44                               neg                    ; invert
    3823/    9479 : 81                                  add   a, c             ; length of last printout field
    3824/    947A : FD 77 02                            ld    (iy+ioparams_last_field), a
    3825/    947D : C9                                  ret
    3826/    947E :                     
    3827/    947E : CD 14 87            sub_177E:       call  check_alpha      ; check for alpha character
    3828/    9481 : DA 6D 81                            jp    c, syntax_error  ; no, return error
    3829/    9484 : 4F                                  ld    c, a             ; save program name to load
    3830/    9485 : 06 03               loop1785:       ld    b, 3             ;<+ cntr for chars
    3831/    9487 : CD 0C 80            loop1787:       call  READERIN         ;<--+ get a char from reader
    3832/    948A : 38 1B                               jr    c, loc_17A7      ; | | error, exit
    3833/    948C : 3C                                  inc   a                ; | | expect at least 3 * FF chars
    3834/    948D : 20 F6                               jr    nz, loop1785     ;-+ |
    3835/    948F : 10 F6                               djnz  loop1787         ;---+ wait for three FF
    3836/    9491 : CD 0C 80            loop1791:       call  READERIN         ;<+ get a char from reader
    3837/    9494 : 38 11                               jr    c, loc_17A7      ; | error, exit
    3838/    9496 : 3C                                  inc   a                ; | expect a FF
    3839/    9497 : 28 F8                               jr    z, loop1791      ;-+ loop as long as FF
    3840/    9499 : 3D                                  dec   a                ; regenerate char
    3841/    949A : B9                                  cp    c                ; compare with file name
    3842/    949B : 28 05                               jr    z, loc_17A2      ; yes, correct program found
    3843/    949D : CD AB 94                            call  read_reader_zero ; wait for 00 or EOF
    3844/    94A0 : 18 E3                               jr    loop1785         ; redo load
    3845/    94A2 : 0E 07               loc_17A2:       ld    c, 7             ; load BEL char
    3846/    94A4 : C3 0F 80                            jp    CONSOLEOUT       ; emit it to console
    3847/    94A7 : 1E 13               loc_17A7:       ld    e, 19            ; error code "file not found"
    3848/    94A9 : 18 11                               jr    loc_17BC         ; print error
    3849/    94AB :                     
    3850/    94AB :                     read_reader_zero:
    3851/    94AB : 06 03                               ld    b, 3
    3852/    94AD : CD B6 94            loop17AD:       call  read_reader      ;<---+ get char
    3853/    94B0 : B7                                  or    a                ;    | wait for three 00
    3854/    94B1 : 20 F8                               jr    nz, read_reader_zero ;|
    3855/    94B3 : 10 F8                               djnz  loop17AD         ;----+
    3856/    94B5 : C9                                  ret                    ; got them
    3857/    94B6 :                     
    3858/    94B6 : CD 0C 80            read_reader:    call  READERIN         ; get a char from reader
    3859/    94B9 : D0                                  ret   nc               ; return if char found
    3860/    94BA : 1E 14               loc_17BA:       ld    e, 20            ; error code "illegal EOF error"
    3861/    94BC : C3 7E 81            loc_17BC:       jp    print_error
    3862/    94BF : 14                  loc_17BF:       inc   d
    3863/    94C0 : C4 B4 82                            call  nz, new_memory
    3864/    94C3 : 18 F5                               jr    loc_17BA
    3865/    94C5 :                     
    3866/    94C5 :                     ; process binary SAVE
    3867/    94C5 : CD 14 87            exec_save:      call  check_alpha      ; get program name character
    3868/    94C8 : DA 6D 81                            jp    c, syntax_error  ; not found, error
    3869/    94CB : 4F                                  ld    c, a             ; save in C
    3870/    94CC : CD 47 86                            call  nextchar         ; get next char
    3871/    94CF : C2 6D 81                            jp    nz, syntax_error ; error if not end of line
    3872/    94D2 : E5                                  push  hl               ; save buf address
    3873/    94D3 : C5                                  push  bc               ; save program name
    3874/    94D4 : 01 FF 08                   		ld    bc, 8FFh         ;<+ load char FF and cntr 8
    3875/    94D7 : CD 12 80            loop17D7:       call  PUNCHOUT         ; | punch tape
    3876/    94DA : 10 FB                               djnz  loop17D7         ;-+ loop to emit 8 * FF
    3877/    94DC : C1                                  pop   bc               ; restore program name
    3878/    94DD : CD 12 80                            call  PUNCHOUT         ; write program name
    3879/    94E0 : 2A 5E 0C                            ld    hl, (prog_end)   ; load end of program
    3880/    94E3 : EB                                  ex    de, hl           ; into DE
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 72 - 8/15/2019 11:33:6


    3881/    94E4 : 2A 5C 0C                            ld    hl, (start_memory) ; load start of program
    3882/    94E7 : 4E                  loop17E7:       ld    c, (hl)          ;<+ get byte to write
    3883/    94E8 : 23                                  inc   hl               ; | advance ptr
    3884/    94E9 : CD 12 80                            call  PUNCHOUT         ; | punch it
    3885/    94EC : (MACRO)                             CPHL_DE                ; | compare with end
    3885/    94EC : 7C                                  ld    a, h
    3885/    94ED : 92                                  sub   d
    3885/    94EE : 20 02                               jr    nz, m1
    3885/    94F0 : 7D                                  ld    a, l
    3885/    94F1 : 93                                  sub   e
    3885/    94F2 :                     m1:
    3886/    94F2 : 20 F3                               jr    nz, loop17E7     ;-+ loop until at end
    3887/    94F4 : 01 FF 08                            ld    bc, 8FFh         ; load byte FF and cntr 8
    3888/    94F7 : CD 12 80            loop17F7:       call  PUNCHOUT         ;<+ punch trailer
    3889/    94FA : 10 FB                               djnz  loop17F7         ;-+ loop to emit 8 * FF
    3890/    94FC : E1                                  pop   hl               ; restore bufptr
    3891/    94FD : C9                                  ret                    ; exit
    3892/    94FE :                     
    3893/    94FE :                     ; process LOAD, LOAD?
    3894/    94FE : FE 97               exec_load:      cp    TOKEN_QUEST      ; "LOAD?"
    3895/    9500 : 16 FF                               ld    d, 0FFh          ; set flag verify
    3896/    9502 : 28 0B                               jr    z, loc_180F      ; yes, skip verify
    3897/    9504 : 32 66 0C                            ld    (fpaccu_mant32), a ; save argument of LOAD
    3898/    9507 : CD B4 82            loc_1807:       call  new_memory       ; clear memory
    3899/    950A : 16 00                               ld    d, 0             ; set flag load
    3900/    950C : 21 65 0C                            ld    hl, data_ptr+1   ; ***** this is possibly a bug, it should
    3901/    950F :                                                            ; have been data_ptr+0
    3902/    950F : CD 47 86            loc_180F:       call  nextchar         ; reload char
    3903/    9512 : CD 7E 94                            call  sub_177E         ; read program name
    3904/    9515 : 2A 5C 0C                            ld    hl, (start_memory) ; get start of memory
    3905/    9518 : 06 03               loop1818:       ld    b, 3             ;<--+
    3906/    951A : CD 0C 80            loop181A:       call  READERIN         ;<+ | get a char
    3907/    951D : 38 A0                               jr    c, loc_17BF      ; | | EOF?
    3908/    951F : 5F                                  ld    e, a             ; | | put into E
    3909/    9520 : 96                                  sub   (hl)             ; | | compare with memory
    3910/    9521 : A2                                  and   d                ; | | and with LOAD=0, VERIFY=FF
    3911/    9522 : 20 18                               jr    nz, loc_183C     ; | | if not zero, does not match
    3912/    9524 : 73                                  ld    (hl), e          ; | | store data
    3913/    9525 : CD 3E 81                            call  check_memfree    ; | | check whether there is still space
    3914/    9528 : 7E                                  ld    a, (hl)          ; | | get current character
    3915/    9529 : B7                                  or    a                ; | | set flags
    3916/    952A : 23                                  inc   hl               ; | | next cell
    3917/    952B : 20 EB                               jr    nz, loop1818     ;---+ loop until three consecutive zeros
    3918/    952D : 10 EB                               djnz  loop181A         ;-+
    3919/    952F : 22 5E 0C                            ld    (prog_end), hl   ; save end address
    3920/    9532 : 3A AB 0C                            ld    a, (prompt_flag) ; print prompt if flag is zero
    3921/    9535 : B7                                  or    a
    3922/    9536 : CC DB 89                            call  z, print_ready_prompt
    3923/    9539 : C3 56 82                            jp    rebuild_nextchain ; go execute
    3924/    953C : 1E 15               loc_183C:       ld    e, 21            ; error code "files different"
    3925/    953E : C3 7E 81                            jp    print_error
    3926/    9541 :                     
    3927/    9541 :                     ; process ASAVE command
    3928/    9541 : C0                  exec_asave:     ret   nz               ; exit if argument follows
    3929/    9542 : E1                                  pop   hl               ; discard return address
    3930/    9543 : 01 FF 08                            ld    bc, 8FFh         ; B=8, C=FF
    3931/    9546 : CD 12 80            loop1846:       call  PUNCHOUT         ;<+ write FF to punch device
    3932/    9549 : 10 FB                               djnz    loop1846       ;-+ loop 8 times
    3933/    954B : 2A 5C 0C                            ld    hl, (start_memory) ; get start of program
    3934/    954E : 7E                  loop184E:       ld    a, (hl)          ;<+ get next link
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 73 - 8/15/2019 11:33:6


    3935/    954F : 23                                  inc   hl               ; |
    3936/    9550 : B6                                  or    (hl)             ; |
    3937/    9551 : 23                                  inc   hl               ; |
    3938/    9552 : 28 31                               jr    z, loc_1885      ; | is it zero? end of program
    3939/    9554 : (MACRO)                             LDDE_M                 ; | get lineno into DE
    3939/    9554 : 5E                                  ld    e, (hl)
    3939/    9555 : 23                                  inc   hl
    3939/    9556 : 56                                  ld    d, (hl)
    3940/    9557 : 23                                  inc   hl               ; |
    3941/    9558 : E5                                  push  hl               ; | save position in line
    3942/    9559 : CD 18 8F                            call  uDE_to_fpaccu    ; | put into FPaccu
    3943/    955C : CD DD A1                            call  format_number    ; | format as number
    3944/    955F : 23                                  inc   hl               ; | advance to number (no sign)
    3945/    9560 : CD 95 95                            call  punch_asciz      ; | write number
    3946/    9563 : E1                                  pop   hl               ; | restore line ptr
    3947/    9564 : 7E                                  ld    a, (hl)          ; | get character
    3948/    9565 : FE 09                               cp    9                ; | is TAB?
    3949/    9567 : 28 05                               jr    z, loc_186E      ; | yes, ignore
    3950/    9569 : 0E 20                               ld    c, CHAR_SPACE    ; | punch a space
    3951/    956B : CD 12 80                            call  PUNCHOUT         ; |
    3952/    956E : CD 37 85            loc_186E:       call  detokenize       ; | convert line decoded into inputbuf
    3953/    9571 : E5                                  push  hl               ; | save current position
    3954/    9572 : 21 B1 0C                            ld    hl, inputbuf     ; | get inputbuf
    3955/    9575 : CD 95 95                            call  punch_asciz      ; | dump it
    3956/    9578 : E1                                  pop   hl               ; | restore line position
    3957/    9579 : 0E 0D                               ld    c, CHAR_CR       ; | punch a CRLF
    3958/    957B : CD 12 80                            call  PUNCHOUT         ; |
    3959/    957E : 0E 0A                               ld    c, CHAR_LF       ; |
    3960/    9580 : CD 12 80                            call  PUNCHOUT         ; |
    3961/    9583 : 18 C9                               jr    loop184E         ;-+ loop
    3962/    9585 : 0E 1A               loc_1885:       ld    c, CHAR_CTRLZ    ; punch a CTRL-Z
    3963/    9587 : CD 12 80                            call  PUNCHOUT
    3964/    958A : 01 FF 08                            ld    bc, 8FFh         ; B=8 C=FF
    3965/    958D : CD 12 80            loop188D:       call  PUNCHOUT         ;<+ send a FF to punch
    3966/    9590 : 10 FB                               djnz  loop188D         ;-+ 8 times
    3967/    9592 : C3 A0 81                            jp    print_prompt     ; return to interpreter loop
    3968/    9595 :                     
    3969/    9595 :                     ; send a 0-terminated string in    HL to PUNCH device
    3970/    9595 : 7E                  punch_asciz:    ld    a, (hl)          ;<+ get character
    3971/    9596 : B7                                  or    a                ; | is 0?
    3972/    9597 : C8                                  ret   z                ; | yes exit
    3973/    9598 : 4F                                  ld    c, a             ; | put int C
    3974/    9599 : CD 12 80                            call  PUNCHOUT         ; | and punch
    3975/    959C : 23                                  inc   hl               ; | advance to next position
    3976/    959D : 18 F6                               jr    punch_asciz      ;-+ loop
    3977/    959F :                     
    3978/    959F :                     temporary_select_printer:
    3979/    959F : EB                                  ex    de, hl           ; save HL
    3980/    95A0 : 21 FC 82                            ld    hl, select_console
    3981/    95A3 : E3                                  ex    (sp), hl         ; insert into stack
    3982/    95A4 : E5                                  push  hl
    3983/    95A5 : EB                                  ex    de, hl           ; restore HL
    3984/    95A6 :                     
    3985/    95A6 : FD 21 15 80         select_printer: ld    iy, LISTOUT
    3986/    95AA : FD 22 8E 0C                         ld    (output_addr), iy
    3987/    95AE : FD 21 95 0C                         ld    iy, prtparam
    3988/    95B2 : C9                                  ret
    3989/    95B3 :                     
    3990/    95B3 : 08                  exec_renumber:  ex    af, af'          ; save flags (following arguments?)
    3991/    95B4 : EB                                  ex    de, hl           ; save curlineptr
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 74 - 8/15/2019 11:33:6


    3992/    95B5 : 2A 54 0C                            ld    hl, (lineno)     ; get lineno
    3993/    95B8 : (MACRO)                             TEST_FFFF              ; is it FFFF?
    3993/    95B8 : 7C                                  ld    a, h
    3993/    95B9 : A5                                  and   l
    3993/    95BA : 3C                                  inc   a                ; is valid (!= ffff)
    3994/    95BB : C2 44 87                            jp    nz, illfunc_error ; no, error, not in  direct mode
    3995/    95BE : 2A 5C 0C                            ld    hl, (start_memory) ; start of program
    3996/    95C1 : 7E                                  ld    a, (hl)          ; get nextlink
    3997/    95C2 : 23                                  inc   hl
    3998/    95C3 : B6                                  or    (hl)
    3999/    95C4 : EB                                  ex    de, hl           ; restore curlineptr
    4000/    95C5 : CA 0D 88                            jp    z, advance_to_eoln ; no program? ignore the whole junk
    4001/    95C8 : 11 0A 00                            ld    de, 10           ; preload starting line
    4002/    95CB : D5                                  push  de
    4003/    95CC : 08                                  ex    af, af'          ; restore flags
    4004/    95CD : DC 85 86                            call  c, read_lineno   ; number follows?, yes get a lineno
    4005/    95D0 :                                                            ; otherwise reuse the preloaded number
    4006/    95D0 : ED 53 A1 0C                         ld    (renum_new), de  ; save it
    4007/    95D4 : D1                                  pop   de               ; drop preload
    4008/    95D5 : FE 2C                               cp    CHAR_COMMA       ; comma follows?
    4009/    95D7 : 20 06                               jr    nz, loc_18DF     ; no, skip
    4010/    95D9 : CD 47 86                            call  nextchar         ; get next char
    4011/    95DC : DC 85 86                            call  c, read_lineno   ; and read increment
    4012/    95DF : ED 53 9F 0C         loc_18DF:       ld    (renum_incr), de ; save increment (if not given, DE was 10)
    4013/    95E3 : E5                                  push  hl               ; save curlineptr
    4014/    95E4 : 2A 5C 0C                            ld    hl, (start_memory) ; get program start
    4015/    95E7 : 23                                  inc   hl               ; skip over nextlink
    4016/    95E8 : 23                                  inc   hl
    4017/    95E9 : (MACRO)                             LDDE_M                 ; get first line
    4017/    95E9 : 5E                                  ld    e, (hl)
    4017/    95EA : 23                                  inc   hl
    4017/    95EB : 56                                  ld    d, (hl)
    4018/    95EC : E1                                  pop   hl
    4019/    95ED : FE 2C                               cp    CHAR_COMMA       ; another comma follows?
    4020/    95EF : 20 0E                               jr    nz, loc_18FF     ; no, skip
    4021/    95F1 : CD 47 86                            call  nextchar         ; get the lineno to start
    4022/    95F4 : DC 85 86                            call  c, read_lineno
    4023/    95F7 : 2A A1 0C                            ld    hl, (renum_new)  ; new lineno to set
    4024/    95FA : ED 52                               sbc   hl, de           ; subtract the line where to start
    4025/    95FC : DA 6D 81                            jp    c, syntax_error  ; error if start > new
    4026/    95FF : ED 53 AC 0C         loc_18FF:       ld    (renum_start), de ; save line to start
    4027/    9603 : B7                                  or    a                ; more arguments follow?
    4028/    9604 : C2 6D 81                            jp    nz, syntax_error ; yes, error
    4029/    9607 : CD 92 82                            call  find_line        ; find starting line
    4030/    960A : D2 E1 87                            jp    nc, undef_stmt_error ; not found, error
    4031/    960D : (MACRO)                             LDHL_BC                ; ptr to start of line into HL
    4031/    960D : 60                                  ld    h, b
    4031/    960E : 69                                  ld    l, c
    4032/    960F : D9                                  exx                    ; alt set
    4033/    9610 : 11 01 00                            ld    de, 1            ; initialize cntr of lines
    4034/    9613 :                                                            ; DE' is increment
    4035/    9613 : 21 00 00                            ld    hl, 0            ; HL' is initial count
    4036/    9616 : D9                                  exx
    4037/    9617 : 11 FF FF                            ld    de, 0FFFFh       ; search for highest line
    4038/    961A : CD 95 82                            call  find_line_from_current ; and count number of lines to renumber
    4039/    961D : D9                                  exx                    ; from now on, ignore reg set, only HL = count of
    4040/    961E :                                                            ; lines is interesting
    4041/    961E : 2B                                  dec   hl               ; one less
    4042/    961F : EB                                  ex    de, hl           ; put nmber of lines in DE
    4043/    9620 : ED 4B 9F 0C                         ld    bc, (renum_incr) ; get increment
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 75 - 8/15/2019 11:33:6


    4044/    9624 : 78                                  ld    a, b             ; increment is zero?
    4045/    9625 : B1                                  or    c
    4046/    9626 : CA 6D 81                            jp    z, syntax_error  ; yes error
    4047/    9629 : CD C6 A0                            call  umultiply16      ; HL is increment * number of lines
    4048/    962C : ED 5B A1 0C                         ld    de, (renum_new)  ; get start of renumbering
    4049/    9630 : 19                                  add   hl, de           ; add, to find the highest number to expect
    4050/    9631 : DA 6B 8E                            jp    c, subscript_range_error ; overflow? error
    4051/    9634 : 2A 5C 0C                            ld    hl, (start_memory) ; start of program
    4052/    9637 : 23                  renum_doline:   inc   hl               ; skip over nextlink
    4053/    9638 : 23                                  inc   hl
    4054/    9639 : (MACRO)                             LDBC_M                 ; get current lineno in BC
    4054/    9639 : 4E                                  ld    c, (hl)
    4054/    963A : 23                                  inc   hl
    4054/    963B : 46                                  ld    b, (hl)
    4055/    963C : EB                                  ex    de, hl           ; save curlineptr
    4056/    963D : 2A AC 0C                            ld    hl, (renum_start) ; check if renumbering starts?
    4057/    9640 : ED 42                               sbc   hl, bc           ; is above the lower margin?
    4058/    9642 : 38 06                               jr    c, loc_194A      ; yes, skip
    4059/    9644 : 28 0E                               jr    z, loc_1954      ; is exactly the starting position
    4060/    9646 : (MACRO)                             LDHL_BC                ; no, put lineno in HL
    4060/    9646 : 60                                  ld    h, b
    4060/    9647 : 69                                  ld    l, c
    4061/    9648 : 18 0D                               jr    loc_1957         ; skip
    4062/    964A : ED 4B 9F 0C         loc_194A:       ld    bc, (renum_incr) ; get increment
    4063/    964E : 2A 9A 0C                            ld    hl, (curlineno)  ; get current line cntr
    4064/    9651 : 09                                  add   hl, bc           ; and add, to get the new lineno to set
    4065/    9652 : 18 03                               jr    loc_1957
    4066/    9654 : 2A A1 0C            loc_1954:       ld    hl, (renum_new)  ; set base of new line
    4067/    9657 : 22 9A 0C            loc_1957:       ld    (curlineno), hl  ; store as the current line handled
    4068/    965A : EB                                  ex    de, hl           ; reload curlineptr
    4069/    965B : CD 47 86            renum_search:   call  nextchar         ;<+ advance to next char in line
    4070/    965E : B7                  renum_search1:  or    a                ; | end of line?
    4071/    965F : CA 68 97                            jp    z, renum_eoln    ; | yes, skip
    4072/    9662 : FE 88                               cp    TOKEN_GOTO       ; | is GOTO?
    4073/    9664 : 28 14                               jr    z, renum_target  ; | yes, handle jump target
    4074/    9666 : FE 8C                               cp    TOKEN_GOSUB      ; | is GOSUB?
    4075/    9668 : 28 10                               jr    z, renum_target  ; | yes, handle
    4076/    966A : FE A2                               cp    TOKEN_THEN       ; | is THEN?
    4077/    966C : 28 0C                               jr    z, renum_target  ; | yes, handle
    4078/    966E : FE C9                               cp    TOKEN_ELSE       ; | is ELSE?
    4079/    9670 : 28 08                               jr    z, renum_target  ; | yes handle
    4080/    9672 : FE 9D                               cp    TOKEN_USING      ; | is USING?
    4081/    9674 : 28 04                               jr    z, renum_target  ; | yes handle
    4082/    9676 : FE 8B                               cp    TOKEN_RESTORE    ; | is RESTORE?
    4083/    9678 : 20 E1                               jr    nz, renum_search ;-+ no, continue searching
    4084/    967A : CD 47 86            renum_target:   call  nextchar         ; found token with a lineno following?
    4085/    967D : 30 DF                               jr    nc, renum_search1 ; no, none following, continue searching
    4086/    967F : 22 9C 0C                            ld    (auto_increment), hl ; save curlineptr
    4087/    9682 : 2B                                  dec   hl               ; to first char of line
    4088/    9683 : 11 00 00                            ld    de, 0            ; initialize number store
    4089/    9686 : 0E 00                               ld    c, 0             ; number of chars in number
    4090/    9688 : CD 47 86            loop1988:       call  nextchar         ;<--+ get char
    4091/    968B : 30 2B                               jr    nc, loc_19B8     ;   | no digit
    4092/    968D : E5                                  push  hl               ;   | save curlineptr
    4093/    968E : B7                                  or    a                ;   | clear CY
    4094/    968F : 21 98 96                            ld    hl, 38552        ;   | maximum lineno before adding last digit
    4095/    9692 : ED 52                               sbc   hl, de           ;   | would result in too large number?
    4096/    9694 : 30 11                               jr    nc, loc_19A7     ;   | no, skip
    4097/    9696 : 21 89 AB            loc_1996:       ld    hl, e_subscr_range ; | print error message
    4098/    9699 : CD BD 84                            call  print_string     ;   |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 76 - 8/15/2019 11:33:6


    4099/    969C : CD 9A 97                            call  trace_curlineno  ;   | print lineno currently handled
    4100/    969F : E1                                  pop   hl               ;   | restore curlineno
    4101/    96A0 : CD 47 86            loop19A0:       call  nextchar         ;<+ | advance to next
    4102/    96A3 : 38 FB                               jr    c, loop19A0      ;-+ | still a number? advance
    4103/    96A5 : 18 B7                               jr    renum_search1    ;   | continue
    4104/    96A7 : (MACRO)             loc_19A7:       LDHL_DE                ;   | save current number value in HL
    4104/    96A7 : 62                                  ld    h, d
    4104/    96A8 : 6B                                  ld    l, e
    4105/    96A9 : 29                                  add   hl, hl           ;   | multiply with 10
    4106/    96AA : 29                                  add   hl, hl           ;   |
    4107/    96AB : 19                                  add   hl, de           ;   |
    4108/    96AC : 29                                  add   hl, hl           ;   |
    4109/    96AD : D6 30                               sub   CHAR_ZERO        ;   | subtract '0' from digit
    4110/    96AF : 5F                                  ld    e, a             ;   | make 16 bit
    4111/    96B0 : 16 00                               ld    d, 0             ;   |
    4112/    96B2 : 19                                  add   hl, de           ;   | add to number store
    4113/    96B3 : EB                                  ex    de, hl           ;   | put number back into DE
    4114/    96B4 : E1                                  pop   hl               ;   | restore curlineptr
    4115/    96B5 : 0C                                  inc   c                ;   | increment digit count
    4116/    96B6 : 18 D0                               jr    loop1988         ;---+ loop
    4117/    96B8 : 79                  loc_19B8:       ld    a, c             ; save the length of number
    4118/    96B9 : 32 9E 0C                            ld    (renum_size), a
    4119/    96BC : E5                                  push  hl               ; save curlineptr
    4120/    96BD : 2A AC 0C                            ld    hl, (renum_start) ; get starting position to renumber
    4121/    96C0 : EB                                  ex    de, hl           ; DE is starting line to renumber
    4122/    96C1 :                                                            ; HL is lineno found in text
    4123/    96C1 : E5                                  push  hl               ; save found number
    4124/    96C2 : ED 52                               sbc   hl, de           ; subtract
    4125/    96C4 : 38 2A                               jr    c, loc_19F0      ; is below the range to renumber
    4126/    96C6 : CD 92 82                            call  find_line        ; find the line where to start renumbering
    4127/    96C9 : (MACRO)                             LDHL_BC                ; ptr to nextlink in HL
    4127/    96C9 : 60                                  ld    h, b
    4127/    96CA : 69                                  ld    l, c
    4128/    96CB : D1                                  pop   de               ; restore GOTO etc. target
    4129/    96CC : D9                                  exx
    4130/    96CD : 2A A1 0C                            ld    hl, (renum_new)  ; initialize cntr for renumbered lines
    4131/    96D0 :                                                            ; HL' is starting count
    4132/    96D0 :                                                            ; DE' is increment
    4133/    96D0 : ED 5B 9F 0C                         ld    de, (renum_incr)
    4134/    96D4 : D9                                  exx
    4135/    96D5 : CD 95 82                            call  find_line_from_current ; find the target
    4136/    96D8 : 38 13                               jr    c, loc_19ED      ; got it
    4137/    96DA : 21 75 AB                            ld    hl, e_undef_stmt ; otherwise, notify undefined statement error
    4138/    96DD : D5                                  push  de               ; save target
    4139/    96DE : CD BD 84                            call  print_string
    4140/    96E1 : E1                                  pop   hl
    4141/    96E2 : CD C9 A1                            call  print_HL         ; print target
    4142/    96E5 : CD 9A 97                            call  trace_curlineno  ; print lineno where found
    4143/    96E8 : E1                                  pop   hl               ; restore curlineptr
    4144/    96E9 : 7E                                  ld    a, (hl)          ; load current char
    4145/    96EA : C3 5E 96                            jp    renum_search1    ; continue searching
    4146/    96ED : D9                  loc_19ED:       exx                    ; get the calculated new target lineno
    4147/    96EE :                                                            ; out of alt set
    4148/    96EE : E5                                  push  hl
    4149/    96EF : D9                                  exx
    4150/    96F0 : D1                  loc_19F0:       pop   de               ; into DE
    4151/    96F1 : E1                                  pop   hl               ; restore old target number
    4152/    96F2 : AF                                  xor    a               ; positive sign
    4153/    96F3 : 06 98                               ld    b, 98h           ; convert into a FP number
    4154/    96F5 : CD AB 9F                            call  s24_to_fp
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 77 - 8/15/2019 11:33:6


    4155/    96F8 : CD DD A1                            call  format_number    ; format it
    4156/    96FB : 06 00                               ld    b, 0             ; initialize digit cntr
    4157/    96FD : 23                                  inc   hl               ; point to next char in number buf
    4158/    96FE : E5                                  push  hl               ; save start of number buf
    4159/    96FF : 7E                  loop19FF:       ld    a, (hl)          ;<+ get char
    4160/    9700 : B7                                  or    a                ; | 
    4161/    9701 : 28 04                               jr    z, loc_1A07      ; | end of number? yes exit loop
    4162/    9703 : 04                                  inc   b                ; | incr digit count
    4163/    9704 : 23                                  inc   hl               ; | advance
    4164/    9705 : 18 F8                               jr    loop19FF         ;-+ loop
    4165/    9707 : 3A 9E 0C            loc_1A07:       ld    a, (renum_size)  ; get size of old target
    4166/    970A : 90                                  sub   b                ; compare with size of new target
    4167/    970B : 28 3C                               jr    z, loc_1A49      ; same? great, skip
    4168/    970D : 38 1C                               jr    c, loc_1A2B      ; new target is larger
    4169/    970F : 4F                                  ld    c, a             ; new target is smaller
    4170/    9710 : 06 00                               ld    b, 0             ; make 16 bit
    4171/    9712 : 2A 9C 0C                            ld    hl, (auto_increment) ; get position of old target
    4172/    9715 : (MACRO)                             LDDE_HL                ; into DE
    4172/    9715 : 54                                  ld    d, h
    4172/    9716 : 5D                                  ld    e, l
    4173/    9717 : 09                                  add   hl, bc           ; addsize of new target
    4174/    9718 : E5                                  push  hl               ; save end position
    4175/    9719 : 2A 5E 0C                            ld    hl, (prog_end)   ; end of program
    4176/    971C : ED 52                               sbc   hl, de           ; subtract old target pos
    4177/    971E : ED 42                               sbc   hl, bc           ; subtract size of new target
    4178/    9720 : (MACRO)                             LDBC_HL                ; count of bytes to move
    4178/    9720 : 44                                  ld    b, h
    4178/    9721 : 4D                                  ld    c, l
    4179/    9722 : E1                                  pop   hl               ; restore end position
    4180/    9723 : ED B0                               ldir                   ; move data
    4181/    9725 : ED 53 5E 0C                         ld    (prog_end), de   ; adjust new end of program
    4182/    9729 : 18 1E                               jr    loc_1A49         ; now has correct space for new target
    4183/    972B : ED 44               loc_1A2B:       neg                    ; difference was negative, negate
    4184/    972D : 4F                                  ld    c, a             ; make 16 bit, number of bytes to expand
    4185/    972E : 06 00                               ld    b, 0
    4186/    9730 : 2A 5E 0C                            ld    hl, (prog_end)   ; get end of program
    4187/    9733 : (MACRO)                             LDDE_HL                ; into DE
    4187/    9733 : 54                                  ld    d, h
    4187/    9734 : 5D                                  ld    e, l
    4188/    9735 : 09                                  add   hl, bc           ; calculate new end
    4189/    9736 : CD 3E 81                            call  check_memfree    ; validate enough free space
    4190/    9739 : 22 5E 0C                            ld    (prog_end), hl   ; store as new end
    4191/    973C : EB                                  ex    de, hl           ; put into DE
    4192/    973D : E5                                  push  hl               ; save old end of program
    4193/    973E : ED 4B 9C 0C                         ld    bc, (auto_increment) ; get position of old target
    4194/    9742 : ED 42                               sbc   hl, bc           ; subtract -> number of bytes to move
    4195/    9744 : (MACRO)                             LDBC_HL                ; into BC
    4195/    9744 : 44                                  ld    b, h
    4195/    9745 : 4D                                  ld    c, l
    4196/    9746 : E1                                  pop   hl
    4197/    9747 : ED B8                               lddr                   ; move bytes to open gap
    4198/    9749 :                     ; now gap is exactly as large to fit the new target number
    4199/    9749 : D1                  loc_1A49:       pop   de               ; start of number buf
    4200/    974A : 2A 9C 0C                            ld    hl, (auto_increment) ; position of old target
    4201/    974D : 1A                  loop1A4D:       ld    a, (de)          ;<+ get digit from number buf
    4202/    974E : B7                                  or    a                ; | 
    4203/    974F : 28 05                               jr    z, loc_1A56      ; | at end? yes leave loop
    4204/    9751 : 77                                  ld    (hl), a          ; | put into gap
    4205/    9752 : 23                                  inc   hl               ; | advance ptrs
    4206/    9753 : 13                                  inc   de               ; |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 78 - 8/15/2019 11:33:6


    4207/    9754 : 18 F7                               jr    loop1A4D         ;-+ loop
    4208/    9756 : E5                  loc_1A56:       push  hl               ; save next position
    4209/    9757 : 2A 5C 0C                            ld    hl, (start_memory) ; get start of program into DE
    4210/    975A : EB                                  ex    de, hl
    4211/    975B : CD 5F 82                            call  rebuild_nextchain1 ; fix next chain
    4212/    975E : E1                                  pop   hl               ; restore curlineptr
    4213/    975F : 7E                                  ld    a, (hl)          ; get next char
    4214/    9760 : FE 2C                               cp    CHAR_COMMA       ; is it a comma? ON GOTO case
    4215/    9762 : CA 7A 96                            jp    z, renum_target  ; yes, stay in loop to fix a potential target
    4216/    9765 : C3 5E 96                            jp    renum_search1    ; continue line processing
    4217/    9768 : 23                  renum_eoln:     inc   hl               ; at end of line, skip over 0 byte
    4218/    9769 : B6                                  or    (hl)             ; check  nextlink (A is 0)
    4219/    976A : 23                                  inc   hl
    4220/    976B : B6                                  or    (hl)
    4221/    976C : 2B                                  dec   hl
    4222/    976D : C2 37 96                            jp    nz, renum_doline ; not at end of program yet, continue
    4223/    9770 : ED 5B AC 0C                         ld    de, (renum_start) ; find start line to renumber
    4224/    9774 : CD 92 82                            call  find_line
    4225/    9777 : (MACRO)                             LDHL_BC                ; put ptr to nextlink in HL
    4225/    9777 : 60                                  ld    h, b
    4225/    9778 : 69                                  ld    l, c
    4226/    9779 : ED 4B 9F 0C                         ld    bc, (renum_incr) ; get increment
    4227/    977D : ED 5B A1 0C                         ld    de, (renum_new)  ; get new value
    4228/    9781 : 23                                  inc   hl               ; skip over nextlink
    4229/    9782 : 23                  loop1A82:       inc   hl               ;<--+
    4230/    9783 : (MACRO)                             LDM_DE                 ;   | put new lineno into line
    4230/    9783 : 73                                  ld    (hl), e
    4230/    9784 : 23                                  inc   hl
    4230/    9785 : 72                                  ld    (hl), d
    4231/    9786 : 23                  loop1A86:       inc   hl               ;<+ | advance
    4232/    9787 : 7E                                  ld    a, (hl)          ; | | advance to end of line
    4233/    9788 : B7                                  or    a                ; | | 
    4234/    9789 : 20 FB                               jr    nz, loop1A86     ;-+ | 
    4235/    978B : EB                                  ex    de, hl           ;   | save curlineptr
    4236/    978C : 09                                  add   hl, bc           ;   | increment the new lineno
    4237/    978D : EB                                  ex    de, hl           ;   | restore curlineptr
    4238/    978E : 23                                  inc   hl               ;   | check if end of program
    4239/    978F : B6                                  or    (hl)             ;   | 
    4240/    9790 : 23                                  inc   hl               ;   | 
    4241/    9791 : B6                                  or    (hl)             ;   | 
    4242/    9792 : 20 EE                               jr    nz, loop1A82     ;---+ no, loop, setting next lineno
    4243/    9794 : CD C6 82                            call  init_from_current ; clear all variables
    4244/    9797 : C3 A0 81                            jp    print_prompt     ; return to interpreter loop
    4245/    979A :                     
    4246/    979A :                     trace_curlineno:
    4247/    979A : 2A 9A 0C                            ld    hl, (curlineno)
    4248/    979D : CD C1 A1            trace_lineno:   call  print_at_lineno
    4249/    97A0 : C3 EE 89                            jp    print_crlf
    4250/    97A3 :                     
    4251/    97A3 :                     ; process DELETE
    4252/    97A3 : CD 73 82            exec_delete:    call  get_lineno_range ; obtain lineno range
    4253/    97A6 :                                                            ; HL is address of nextlink
    4254/    97A6 :                                                            ; BC is address of previous nextlink
    4255/    97A6 : D1                                  pop   de               ; restore ending lineno
    4256/    97A7 : C5                                  push  bc               ; save starting position
    4257/    97A8 : CD 92 82                            call  find_line        ; find the ending line from current position
    4258/    97AB : D2 44 87                            jp    nc, illfunc_error ; not matched, error
    4259/    97AE : (MACRO)                             LDDE_HL                ; DE = start of lines to delete
    4259/    97AE : 54                                  ld    d, h
    4259/    97AF : 5D                                  ld    e, l
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 79 - 8/15/2019 11:33:6


    4260/    97B0 : E3                                  ex    (sp), hl         ; insert it in stack
    4261/    97B1 : E5                                  push  hl
    4262/    97B2 : (MACRO)                             CPHL_DE                ; subtract address range
    4262/    97B2 : 7C                                  ld    a, h
    4262/    97B3 : 92                                  sub   d
    4262/    97B4 : 20 02                               jr    nz, m1
    4262/    97B6 : 7D                                  ld    a, l
    4262/    97B7 : 93                                  sub   e
    4262/    97B8 :                     m1:
    4263/    97B8 : D2 44 87                            jp    nc, illfunc_error ; negative? yes error
    4264/    97BB : CD DB 89                            call  print_ready_prompt ; print READY
    4265/    97BE : C1                                  pop   bc               ; restore starting position
    4266/    97BF : 21 56 82                            ld    hl, rebuild_nextchain ; return via rebuild_nextchain
    4267/    97C2 : E3                                  ex    (sp), hl
    4268/    97C3 : EB                                  ex    de, hl           ; DE = end to delete
    4269/    97C4 : 2A 5E 0C                            ld    hl, (prog_end)   ; HL = prog_end
    4270/    97C7 :                                                            ; BC = start to delete
    4271/    97C7 : 1A                  loop1AC7:       ld    a, (de)          ;<+ get byte from range end
    4272/    97C8 : 02                                  ld    (bc), a          ; | move to range start
    4273/    97C9 : 03                                  inc   bc               ; | advance ptrs
    4274/    97CA : 13                                  inc   de               ; | 
    4275/    97CB : (MACRO)                             CPHL_DE                ; | loop until end of program
    4275/    97CB : 7C                                  ld    a, h
    4275/    97CC : 92                                  sub   d
    4275/    97CD : 20 02                               jr    nz, m1
    4275/    97CF : 7D                                  ld    a, l
    4275/    97D0 : 93                                  sub   e
    4275/    97D1 :                     m1:
    4276/    97D1 : 20 F4                               jr    nz, loop1AC7     ;-+
    4277/    97D3 : ED 43 5E 0C                         ld    (prog_end), bc   ; save new end of program
    4278/    97D7 : C9                                  ret
    4279/    97D8 :                     
    4280/    97D8 : 3E 7F               exec_ltrace:    ld    a, 7Fh           ; load flag for LTRACE
    4281/    97DA : 01                                  db    1                ; LD BC, xxxx to skip next instruction
    4282/    97DB :                     
    4283/    97DB :                     ; process TRACE/LTRACE
    4284/    97DB : 3E BF               exec_trace:     ld    a, 0BFh          ;** load flag for TRACE
    4285/    97DD : F5                                  push  af               ; save LTRACE/TRACE flag
    4286/    97DE : CD 9A 8B                            call  expression1      ; evaluate an expression
    4287/    97E1 : CD 48 86                            call  skipspace        ; continue
    4288/    97E4 : 20 14                               jr    nz, loc_1AFA     ; if not EOLN, error
    4289/    97E6 : CD BF 9F                            call  fpaccu_sgn       ; get value (0,1)
    4290/    97E9 : 3D                                  dec   a                ; convert to 0/FF
    4291/    97EA : 2F                                  cpl
    4292/    97EB : 47                                  ld    b, a             ; save
    4293/    97EC : F1                                  pop   af               ; restore flag
    4294/    97ED : 4F                                  ld    c, a             ; save
    4295/    97EE : 2F                                  cpl                    ; complement: LTRACE = 0x80, TRACE = 0x40
    4296/    97EF : A0                                  and   b                ; mask bit
    4297/    97F0 : 47                                  ld    b, a             ; result into B
    4298/    97F1 : 3A A3 0C                            ld    a, (trace_mode)  ; get trace mode
    4299/    97F4 : A1                                  and   c                ; mask out relevant bit
    4300/    97F5 : B0                                  or    b                ; inject trace flag
    4301/    97F6 : 32 A3 0C                            ld    (trace_mode), a  ; save it
    4302/    97F9 : C9                                  ret
    4303/    97FA : F1                  loc_1AFA:       pop   af
    4304/    97FB : C3 6D 81                            jp    syntax_error
    4305/    97FE :                     
    4306/    97FE : CD 85 86            exec_edit:      call  read_lineno      ; read the line number
    4307/    9801 : C0                                  ret   nz               ; exit if more arguments follow
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 80 - 8/15/2019 11:33:6


    4308/    9802 : E1                                  pop   hl               ; drop return address
    4309/    9803 : CD 92 82            loc_1B03:       call  find_line        ; find the line to be edited
    4310/    9806 : D2 44 87                            jp    nc, illfunc_error ; not found, error
    4311/    9809 : (MACRO)                             LDHL_BC                ; put start of line into HL
    4311/    9809 : 60                                  ld    h, b
    4311/    980A : 69                                  ld    l, c
    4312/    980B : 23                                  inc   hl               ; skip over next link
    4313/    980C : 23                                  inc   hl
    4314/    980D : (MACRO)                             LDBC_M                 ; get lineno into BC
    4314/    980D : 4E                                  ld    c, (hl)
    4314/    980E : 23                                  inc   hl
    4314/    980F : 46                                  ld    b, (hl)
    4315/    9810 : 23                                  inc   hl
    4316/    9811 : C5                                  push  bc               ; save lineno
    4317/    9812 : CD 37 85                            call  detokenize       ; move line into inputbuf
    4318/    9815 : E1                  loc_1B15:       pop   hl               ; restore lineno
    4319/    9816 : E5                                  push  hl               ; save again
    4320/    9817 : CD C9 A1                            call  print_HL         ; print lineno
    4321/    981A : CD 64 84                            call  print_space      ; print blank
    4322/    981D : 21 B1 0C                            ld    hl, inputbuf     ; ptr to inputbuf
    4323/    9820 : E5                                  push  hl
    4324/    9821 : 1E FF                               ld    e, 0FFh          ; E = -1
    4325/    9823 : 1C                  loop1B23:       inc   e                ;<+ increment
    4326/    9824 : 7E                                  ld    a, (hl)          ; | get char
    4327/    9825 : E6 7F                               and   MASK_7BIT        ; | discard parity bit
    4328/    9827 : 77                                  ld    (hl), a          ; | 
    4329/    9828 : 23                                  inc   hl               ; | advance
    4330/    9829 : 20 F8                               jr    nz, loop1B23     ;-+ loop until end of buf
    4331/    982B :                                                            ; E is length of line
    4332/    982B : E1                                  pop   hl               ; restore start of buf
    4333/    982C : 57                                  ld    d, a             ; clear D (A is 0)
    4334/    982D : 06 00               edit_loop:      ld    b, 0             ; clear count
    4335/    982F : CD C9 84            loop1B2F:       call  read_conchar     ;<+ get char from console
    4336/    9832 : FE 3A                               cp    ':'              ; | between 0-9?
    4337/    9834 : 30 10                               jr    nc, loc_1B46     ; | 
    4338/    9836 : FE 30                               cp    CHAR_ZERO        ; | 
    4339/    9838 : 38 0C                               jr    c, loc_1B46      ; | no, skip
    4340/    983A : D6 30                               sub   CHAR_ZERO        ; | make digit
    4341/    983C : 4F                                  ld    c, a             ; | into C
    4342/    983D : 78                                  ld    a, b             ; | get count
    4343/    983E : 07                                  rlca                   ; | multiply with 10
    4344/    983F : 07                                  rlca                   ; | 
    4345/    9840 : 80                                  add   a, b             ; | 
    4346/    9841 : 07                                  rlca                   ; | 
    4347/    9842 : 81                                  add   a, c             ; | add digit
    4348/    9843 : 47                                  ld    b, a             ; | new count
    4349/    9844 : 18 E9                               jr    loop1B2F         ;-+ loop
    4350/    9846 : E5                  loc_1B46:       push  hl               ; save bufptr
    4351/    9847 : 21 2D 98                            ld    hl, edit_loop
    4352/    984A : E3                                  ex    (sp), hl         ; put edit_loop on stack
    4353/    984B :                                                            ; HL is bufptr
    4354/    984B : 05                                  dec   b                ; check if count is 0
    4355/    984C : 04                                  inc   b
    4356/    984D : 20 01                               jr    nz, loc_1B50
    4357/    984F : 04                                  inc   b                ; yes, set to 1
    4358/    9850 : D9                  loc_1B50:       exx                    ; alt register set
    4359/    9851 : 21 71 98            loop1B51:       ld    hl, edit_tbl     ;<--+ HL' is edit_tbl
    4360/    9854 : BE                  loop1B54:       cp    (hl)             ;<+ | compare entered character with table entry
    4361/    9855 : 23                                  inc   hl               ; | | advance
    4362/    9856 : (MACRO)                             LDBC_M                 ; | | get handler address into BC'
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 81 - 8/15/2019 11:33:6


    4362/    9856 : 4E                                  ld    c, (hl)
    4362/    9857 : 23                                  inc   hl
    4362/    9858 : 46                                  ld    b, (hl)
    4363/    9859 : 23                                  inc   hl               ; | | 
    4364/    985A : C5                                  push  bc               ; | | save on stack
    4365/    985B : D9                                  exx                    ; | | std set
    4366/    985C : C8                                  ret   z                ; | | if command found, return to handler routine
    4367/    985D : D9                                  exx                    ; | | to alt set
    4368/    985E :                     ;;                pop   bc               ; | | drop handler address
    4369/    985E :                     ;;                inc   (hl)             ; | | check for terminating 0 byte
    4370/    985E :                     ;;                dec   (hl)             ; | | 
    4371/    985E : C3 F8 AD            		jp	loc_ADF8
    4372/    9861 : 20 F1               loc_9861:       jr    nz, loop1B54     ;-+ | no loop
    4373/    9863 : FE 60                               cp    60h              ;   | is it a lower case letter?
    4374/    9865 : 38 04                               jr    c, loc_1B6B      ;   | no, ring bell for error
    4375/    9867 : E6 5F                               and   5Fh              ;   | make it upper case
    4376/    9869 : 18 E6                               jr    loop1B51         ;---+ and try again
    4377/    986B : D9                  loc_1B6B:       exx                    ; return to std set
    4378/    986C : 3E 07                               ld    a, 7             ; ring BEL
    4379/    986E : C3 72 84                            jp    write_char       ; and return to edit_loop
    4380/    9871 : 20                  edit_tbl:       db    CHAR_SPACE
    4381/    9872 : A4 98                               dw    edit_right
    4382/    9874 : 51                                  db    'Q'
    4383/    9875 : C7 86                               dw    break_entry
    4384/    9877 : 4C                                  db    'L'
    4385/    9878 : DC 98                               dw    edit_list
    4386/    987A : 46                                  db    'F'
    4387/    987B : B5 98                               dw    edit_find
    4388/    987D : 49                                  db    'I'
    4389/    987E : 16 99                               dw    edit_insert
    4390/    9880 : 44                                  db    'D'
    4391/    9881 : E6 98                               dw    edit_delete
    4392/    9883 : 0D                                  db    CHAR_CR
    4393/    9884 : 65 99                               dw    edit_end
    4394/    9886 : 52                                  db    'R'
    4395/    9887 : FF 98                               dw    edit_replace
    4396/    9889 : 45                                  db    'E'
    4397/    988A : 68 99                               dw    edit_save
    4398/    988C : 58                                  db    'X'
    4399/    988D : 11 99                               dw    edit_append
    4400/    988F : 4B                                  db    'K'
    4401/    9890 : AF 98                               dw    edit_kill
    4402/    9892 : 48                                  db    'H'
    4403/    9893 : 0E 99                               dw    edit_deleoln
    4404/    9895 : 7F                                  db    CHAR_RUBOUT
    4405/    9896 : 59 99                               dw    edit_left
    4406/    9898 : 41                                  db    'A'
    4407/    9899 : 9C 98                               dw    edit_reload
    4408/    989B : 00                                  db    0
    4409/    989C :                     
    4410/    989C : C1                  edit_reload:    pop   bc               ; drop argument
    4411/    989D : D1                                  pop   de               ; restore current line to edit
    4412/    989E : CD EE 89                            call  print_crlf       ; print CRLF
    4413/    98A1 : C3 03 98                            jp    loc_1B03         ; find and reload line in DE
    4414/    98A4 :                     
    4415/    98A4 : 7E                  edit_right:     ld    a, (hl)          ;<+ get current char
    4416/    98A5 : B7                                  or    a                ; | at end of line?
    4417/    98A6 : C8                                  ret   z                ; | yes, exit to edit_loop
    4418/    98A7 : 14                                  inc   d                ; | increment pos
    4419/    98A8 : CD 66 84                            call  print_char       ; | print character
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 82 - 8/15/2019 11:33:6


    4420/    98AB : 23                                  inc   hl               ; | advance ptr
    4421/    98AC : 10 F6                               djnz    edit_right     ;-+ loop N times
    4422/    98AE : C9                                  ret                    ; exit to edit_loop
    4423/    98AF :                     
    4424/    98AF : E5                  edit_kill:      push  hl               ; save position
    4425/    98B0 : 21 FA 98                            ld    hl, print_backslash1 ; print a backslash
    4426/    98B3 : E3                                  ex    (sp), hl         ; put on stack, HL is position
    4427/    98B4 : 37                                  scf                    ; set CY
    4428/    98B5 : F5                  edit_find:      push  af               ; save flags
    4429/    98B6 : CD C9 84                            call  read_conchar     ; get character
    4430/    98B9 : 4F                                  ld    c, a             ; save in C
    4431/    98BA : F1                                  pop   af               ; restore flags
    4432/    98BB : 35                                  dec   (hl)             ; at end of line?
    4433/    98BC : 34                                  inc   (hl)
    4434/    98BD : C8                                  ret   z                ; yes, exit to print_backslash1
    4435/    98BE : F5                                  push  af               ; save flags
    4436/    98BF : DC FA 98                            call  c, print_backslash1 ; if in kill mode, print char X as "\X"
    4437/    98C2 : 7E                                  ld    a, (hl)
    4438/    98C3 : CD 66 84            loop1BC3:       call  print_char       ;<+
    4439/    98C6 : F1                                  pop   af               ; | restore flags
    4440/    98C7 : F5                                  push  af               ; | save again
    4441/    98C8 : 30 05                               jr    nc, loc_1BCF     ; | if not in kill mode, skip
    4442/    98CA : CD 75 99                            call  del_char_from_buf ;| delete char from buf
    4443/    98CD : 18 02                               jr    loc_1BD1         ; | 
    4444/    98CF : 23                  loc_1BCF:       inc   hl               ; | advance to next position
    4445/    98D0 : 14                                  inc   d                ; | advance char cntr
    4446/    98D1 : 7E                  loc_1BD1:       ld    a, (hl)          ; | get character
    4447/    98D2 : B7                                  or    a                ; | 
    4448/    98D3 : 28 05                               jr    z, loc_1BDA      ; | end of line? yes skip
    4449/    98D5 : B9                                  cp    c                ; | is it the char to find
    4450/    98D6 : 20 EB                               jr    nz, loop1BC3     ;>+ no loop
    4451/    98D8 : 10 E9                               djnz  loop1BC3         ;-+ loop N times
    4452/    98DA : F1                  loc_1BDA:       pop   af               ; drop flags
    4453/    98DB : C9                                  ret                    ; return to edit_loop
    4454/    98DC :                     
    4455/    98DC : CD 2A 85            edit_list:      call  sub_82A          ; print buf
    4456/    98DF : CD EE 89                            call  print_crlf       ; do CRLF
    4457/    98E2 : C1                                  pop   bc               ; cleanup stack
    4458/    98E3 : C3 15 98                            jp    loc_1B15         ; loop to EDIT print line
    4459/    98E6 :                     
    4460/    98E6 : 7E                  edit_delete:    ld    a, (hl)          ; get char
    4461/    98E7 : B7                                  or    a                ; is it end of line?
    4462/    98E8 : C8                                  ret   z                ; yes, exit to edit_loop
    4463/    98E9 : 3E 5C                               ld    a, CHAR_BSLASH   ; print a backslash
    4464/    98EB : CD 72 84                            call  write_char       ;<+
    4465/    98EE : 7E                  loop1BEE:       ld    a, (hl)          ; | print char
    4466/    98EF : B7                                  or    a                ; | 
    4467/    98F0 : 28 08                               jr    z, print_backslash1 ; unless it is end of line
    4468/    98F2 : CD 66 84                            call  print_char       ; | 
    4469/    98F5 : CD 75 99                            call  del_char_from_buf ;| delete char from buf
    4470/    98F8 : 10 F4                               djnz    loop1BEE       ;-+ loop N times
    4471/    98FA :                     
    4472/    98FA :                     print_backslash1:
    4473/    98FA : 3E 5C                               ld    a, CHAR_BSLASH
    4474/    98FC : C3 72 84                            jp    write_char
    4475/    98FF :                     
    4476/    98FF : 7E                  edit_replace:   ld    a, (hl)          ;<+ get char
    4477/    9900 : B7                                  or    a                ; | 
    4478/    9901 : C8                                  ret   z                ; | if end of line, exit to edit_loop
    4479/    9902 : CD C9 84                            call  read_conchar     ; | get character
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 83 - 8/15/2019 11:33:6


    4480/    9905 : CD 66 84                            call  print_char       ; | print it
    4481/    9908 : 77                                  ld    (hl), a          ; | put into buf
    4482/    9909 : 23                                  inc   hl               ; | advance bufptr
    4483/    990A : 14                                  inc   d                ; | advance buf count
    4484/    990B : 10 F2                               djnz    edit_replace   ;-+ loop N times
    4485/    990D : C9                                  ret
    4486/    990E :                     
    4487/    990E : 36 00               edit_deleoln:   ld    (hl), 0          ; set end of buf here
    4488/    9910 : 5A                                  ld    e, d             ; store buf count
    4489/    9911 : 06 FF               edit_append:    ld    b, 0FFh          ; go as much right as possible
    4490/    9913 : CD A4 98                            call  edit_right
    4491/    9916 : CD C9 84            edit_insert:    call  read_conchar     ;<+ get char from console
    4492/    9919 : FE 0D                               cp    CHAR_CR          ; | is it CR?
    4493/    991B : 28 48                               jr    z, edit_end      ; | yes, done
    4494/    991D : FE 1B                               cp    CHAR_ESC         ; | is it ESCAPE?
    4495/    991F : C8                                  ret   z                ; | yes, leave edit mode
    4496/    9920 : FE 7F                               cp    CHAR_RUBOUT      ; | is it RUBOUT?
    4497/    9922 : 20 0F                               jr    nz, loc_1C33     ; | no, skip
    4498/    9924 : 15                                  dec   d                ; | check position
    4499/    9925 : 14                                  inc   d                ; | 
    4500/    9926 : 28 12                               jr    z, loc_1C3A      ; | at the start of buf
    4501/    9928 : 2B                                  dec   hl               ; | no, decrement bufptr
    4502/    9929 : 15                                  dec   d                ; | and cntr
    4503/    992A : 7E                                  ld    a, (hl)          ; | get the char
    4504/    992B : CD 66 84                            call  print_char       ; | print it
    4505/    992E : CD 75 99                            call  del_char_from_buf ;| and delete it from buf
    4506/    9931 : 18 E3                               jr    edit_insert      ;-+ loop
    4507/    9933 : F5                  loc_1C33:       push  af               ; save character
    4508/    9934 : 7B                                  ld    a, e             ; get edit count
    4509/    9935 : FE FF                               cp    0FFh             ; is it 255?
    4510/    9937 : 38 08                               jr    c, loc_1C41      ; no, not yet, go insert the char
    4511/    9939 : F1                                  pop   af               ; drop character
    4512/    993A : 3E 07               loc_1C3A:       ld    a, 7             ; ring bell (end of buf)
    4513/    993C : CD 72 84                            call  write_char
    4514/    993F : 18 D5                               jr    edit_insert      ; loop
    4515/    9941 : 92                  loc_1C41:       sub   d                ; edit count - buf position
    4516/    9942 : 1C                                  inc   e                ; increment both
    4517/    9943 : 14                                  inc   d
    4518/    9944 : D5                                  push  de               ; save DE
    4519/    9945 : EB                                  ex    de, hl           ; bufptr
    4520/    9946 : 6F                                  ld    l, a             ; make 16 bit
    4521/    9947 : 26 00                               ld    h, 0
    4522/    9949 : 19                                  add   hl, de           ; bufptr + insertion length
    4523/    994A : (MACRO)                             LDBC_HL                ; into BC
    4523/    994A : 44                                  ld    b, h
    4523/    994B : 4D                                  ld    c, l
    4524/    994C : 03                                  inc   bc               ; add 1
    4525/    994D : CD 1F 81                            call  loc_41F          ; reserve space
    4526/    9950 : D1                                  pop   de               ; restore DE
    4527/    9951 : F1                                  pop   af               ; restore char inserted
    4528/    9952 : CD 66 84                            call  print_char       ; print it
    4529/    9955 : 77                                  ld    (hl), a          ; put into buf
    4530/    9956 : 23                                  inc   hl
    4531/    9957 : 18 BD                               jr    edit_insert      ; loop
    4532/    9959 :                     
    4533/    9959 : 7A                  edit_left:      ld    a, d             ;<+ get buf pos
    4534/    995A : B7                                  or    a                ; | already at the beginning?
    4535/    995B : C8                                  ret   z                ; | yes ignore
    4536/    995C : 15                                  dec   d                ; | move pos andptr to left
    4537/    995D : 2B                                  dec   hl               ; | 
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 84 - 8/15/2019 11:33:6


    4538/    995E : 7E                                  ld    a, (hl)          ; | print char
    4539/    995F : CD 66 84                            call  print_char       ; | 
    4540/    9962 : 10 F5                               djnz  edit_left        ;-+ loop N times
    4541/    9964 : C9                                  ret
    4542/    9965 :                     
    4543/    9965 : CD 2A 85            edit_end:       call  sub_82A          ; print the whole line
    4544/    9968 : CD EE 89            edit_save:      call  print_crlf       ; print a CRLF
    4545/    996B : C1                                  pop   bc               ; cleanup stack
    4546/    996C : D1                                  pop   de               ; restore lineno
    4547/    996D : 37                                  scf                    ; set CY
    4548/    996E : F5                                  push  af               ; save it
    4549/    996F : 21 B1 0C                            ld    hl, inputbuf     ; load inputbuf
    4550/    9972 : C3 F9 81                            jp    loc_4F9          ; enter into line insertion routine
    4551/    9975 :                     
    4552/    9975 :                     del_char_from_buf:
    4553/    9975 : E5                                  push  hl               ; save buf position
    4554/    9976 : 1D                                  dec   e                ; decrement count
    4555/    9977 : 7E                  loop1C77:       ld    a, (hl)          ;<+ get character
    4556/    9978 : B7                                  or    a                ; | end of buf reached
    4557/    9979 : 28 07                               jr    z, loc_1C82      ; | 
    4558/    997B : 23                                  inc   hl               ; | advance to next position
    4559/    997C : 7E                                  ld    a, (hl)          ; | delete char from buf
    4560/    997D : 2B                                  dec   hl               ; | 
    4561/    997E : 77                                  ld    (hl), a          ; | 
    4562/    997F : 23                                  inc   hl               ; | 
    4563/    9980 : 18 F5                               jr    loop1C77         ;-+ loop
    4564/    9982 : E1                  loc_1C82:       pop   hl               ; restore position
    4565/    9983 : C9                                  ret
    4566/    9984 :                     
    4567/    9984 :                     ; get a random init value from refresh register
    4568/    9984 :                     ; BAD code: this only gets 256 different random values
    4569/    9984 : C0                  exec_randomize: ret   nz               ; exit if argument follows
    4570/    9985 : EB                                  ex    de, hl           ; save HL
    4571/    9986 : 21 87 0C                            ld    hl, rnd_mant23
    4572/    9989 : ED 5F                               ld    a, r             ; get refresh register (256 values)
    4573/    998B : 77                                  ld    (hl), a          ; save mant2
    4574/    998C : 23                                  inc   hl
    4575/    998D : 77                                  ld    (hl), a          ; save mant3
    4576/    998E : 23                                  inc   hl
    4577/    998F : 77                                  ld    (hl), a          ; save mant4
    4578/    9990 : 23                                  inc   hl
    4579/    9991 : 77                                  ld    (hl), a          ; save mant5
    4580/    9992 : 23                                  inc   hl
    4581/    9993 : E6 7F                               and   7Fh              ; make positive (suppressed MSB)
    4582/    9995 : 77                                  ld    (hl), a          ; save mant6
    4583/    9996 : 23                                  inc   hl
    4584/    9997 : 36 80                               ld    (hl), 80h        ; make expenent
    4585/    9999 : EB                                  ex    de, hl
    4586/    999A : C9                                  ret
    4587/    999B :                     
    4588/    999B :                     ; handle LVAR/LLVAR
    4589/    999B :                     ; anachronism: does not print arrays
    4590/    999B : CD 9F 95            exec_llvar:     call  temporary_select_printer ; select printer for output
    4591/    999E : C0                  exec_lvar:      ret   nz               ; exit, if arguments follow
    4592/    999F : E5                                  push  hl               ; save curlineptr
    4593/    99A0 : 2A 5E 0C                            ld    hl, (prog_end)   ; get start of variables
    4594/    99A3 : CC EE 89            loop1CA3:       call  z, print_crlf       ;<+ print a CRLF
    4595/    99A6 : CD 93 86                            call  check_break      ; | check for break
    4596/    99A9 : ED 5B 60 0C                         ld    de, (end_of_vars) ;| load end of variables
    4597/    99AD : (MACRO)                             CPHL_DE                ; | 
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 85 - 8/15/2019 11:33:6


    4597/    99AD : 7C                                  ld    a, h
    4597/    99AE : 92                                  sub   d
    4597/    99AF : 20 02                               jr    nz, m1
    4597/    99B1 : 7D                                  ld    a, l
    4597/    99B2 : 93                                  sub   e
    4597/    99B3 :                     m1:
    4598/    99B3 : 28 3B                               jr    z, loc_1CF0      ; | is end of vars already reached? yes exit
    4599/    99B5 : 4E                                  ld    c, (hl)          ; | get variable name in C
    4600/    99B6 : 23                                  inc   hl               ; | 
    4601/    99B7 : 7E                                  ld    a, (hl)          ; | and A
    4602/    99B8 : 23                                  inc   hl               ; | 
    4603/    99B9 : CB 7F                               bit   7, a             ; | test bit 7
    4604/    99BB : 20 2B                               jr    nz, loc_1CE8     ; | advance to next, is a function
    4605/    99BD : CD 72 84                            call  write_char       ; | write 1st character
    4606/    99C0 : 79                                  ld    a, c             ; | get second character
    4607/    99C1 : E6 7F                               and   MASK_7BIT        ; | mask high bit
    4608/    99C3 : C4 72 84                            call  nz, write_char   ; | print if character is not 0
    4609/    99C6 : 3E 24                               ld    a, CHAR_DOLLAR   ; | preload $
    4610/    99C8 : CB 79                               bit    7, c            ; | check bit 7 if 2nd char
    4611/    99CA : C4 72 84                            call  nz, write_char   ; | print $ (string) if bit 7 set
    4612/    99CD : 3E 3D                               ld    a, '='           ; | print a '='
    4613/    99CF : CD 72 84                            call  write_char       ; | 
    4614/    99D2 : 79                                  ld    a, c             ; | get 2nd char
    4615/    99D3 : 17                                  rla                    ; | put bit 7 into CY
    4616/    99D4 : 9F                                  sbc   a, a             ; | set flag = FF if string
    4617/    99D5 : 22 66 0C                            ld    (fpaccu_mant32), hl ; save address of string descriptor in fpaccu
    4618/    99D8 : E5                                  push  hl               ; | save var ptr
    4619/    99D9 : 20 09                               jr    nz, loc_1CE4     ; | was a string? yes, skip
    4620/    99DB : CD EC 9F                            call  mem_to_fpaccu    ; | load numeric value info FPaccu
    4621/    99DE : CD DD A1                            call  format_number    ; | format as number
    4622/    99E1 : CD ED 90                            call  straccu_copy     ; | copy formatted number to straccu
    4623/    99E4 : CD 34 91            loc_1CE4:       call  straccu_print    ; | print the string
    4624/    99E7 : E1                                  pop   hl               ; | restore ptr to variable
    4625/    99E8 : 23                  loc_1CE8:       inc   hl               ; | advance to next position
    4626/    99E9 : 23                                  inc   hl               ; | 
    4627/    99EA : 23                                  inc   hl               ; | 
    4628/    99EB : 23                                  inc   hl               ; | 
    4629/    99EC : 23                                  inc   hl               ; | 
    4630/    99ED : 23                                  inc   hl               ; | 
    4631/    99EE : 18 B3                               jr    loop1CA3         ;-+ loop
    4632/    99F0 : E1                  loc_1CF0:       pop   hl               ; done
    4633/    99F1 : C9                                  ret
    4634/    99F2 :                     				
    4635/    99F2 : CD B4 82            exec_aload:     call  new_memory       ; clear memory
    4636/    99F5 : 2A 5E 0C            exec_amerge:    ld    hl, (prog_end)   ; load current end of program
    4637/    99F8 : 2B                                  dec   hl
    4638/    99F9 : CD 64 9A            loop1CF9:       call  get_RDR          ;<+ get char from reader
    4639/    99FC : 38 27                               jr    c, loc_1D25      ; | CY set?, end of file, skip
    4640/    99FE : 28 F9               loc_1CFE:       jr    z, loop1CF9      ;>+ zero byte, ignore
    4641/    9A00 : FE 7F                               cp    CHAR_RUBOUT      ; | is RUBOUT marker?
    4642/    9A02 : 28 F5                               jr    z, loop1CF9      ;-+ yes ignore
    4643/    9A04 : 23                                  inc   hl               ; advance ptr
    4644/    9A05 : 77                                  ld    (hl), a          ; save it
    4645/    9A06 : CD 3E 81                            call  check_memfree    ; validate still memory available
    4646/    9A09 : 7E                                  ld    a, (hl)          ; load char
    4647/    9A0A : D6 0D                               sub   CHAR_CR          ; is it a CR?
    4648/    9A0C : 20 13                               jr    nz, loc_1D21     ; no continue
    4649/    9A0E : 77                                  ld    (hl), a          ; save 0 byte at line end
    4650/    9A0F : 23                                  inc   hl               ; leave space for following nextlink andlineno
    4651/    9A10 : 77                                  ld    (hl), a
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 86 - 8/15/2019 11:33:6


    4652/    9A11 : 23                                  inc   hl
    4653/    9A12 : 77                                  ld    (hl), a
    4654/    9A13 : 23                                  inc   hl
    4655/    9A14 : 77                                  ld    (hl), a
    4656/    9A15 : CD 64 9A                            call  get_RDR          ; get char from reader
    4657/    9A18 : 38 0B                               jr    c, loc_1D25      ; end of file? skip
    4658/    9A1A : FE 0A                               cp    CHAR_LF          ; is it a following LF?
    4659/    9A1C : 28 DB                               jr    z, loop1CF9      ; yes, ignore
    4660/    9A1E : B7                                  or    a                ; set flags
    4661/    9A1F : 18 DD                               jr    loc_1CFE         ; and process normally
    4662/    9A21 : FE 0D               loc_1D21:       cp    CHAR_CR          ; is it 0d+0d == 1a == CTRL-Z?
    4663/    9A23 : 20 D4                               jr    nz, loop1CF9     ; no process normally
    4664/    9A25 :                     ; end of file encntred
    4665/    9A25 : 36 00               loc_1D25:       ld    (hl), NULL       ; store terminating 0
    4666/    9A27 : 23                                  inc   hl
    4667/    9A28 : 36 1A                               ld    (hl), CHAR_CTRLZ ; store terminating CTRL-Z
    4668/    9A2A : 2A 5E 0C                            ld    hl, (prog_end)   ; begin at program end again
    4669/    9A2D : E5                  loc_1D2D:       push  hl               ; save current line ptr
    4670/    9A2E : 7E                                  ld    a, (hl)          ; get current char
    4671/    9A2F : D6 1A                               sub   CHAR_CTRLZ       ; is it CTRL-Z?
    4672/    9A31 : 20 09                               jr    nz, loop1D3C     ; no, skip
    4673/    9A33 : 32 AB 0C                            ld    (prompt_flag), a ; yes, finished
    4674/    9A36 : CD C2 82                            call  init_from_start  ; reinitialize
    4675/    9A39 : C3 A0 81                            jp    print_prompt     ; return to interpreter    loop
    4676/    9A3C : 7E                  loop1D3C:       ld    a, (hl)          ;<+ get current char
    4677/    9A3D : 23                                  inc   hl               ; | advance
    4678/    9A3E : B7                                  or    a                ; | set flags
    4679/    9A3F : 20 FB                               jr    nz, loop1D3C     ;-+ loop until end of line
    4680/    9A41 :                     ; has found a 0 byte                     
    4681/    9A41 : 7E                  loop1D41:       ld    a, (hl)          ;<+ get current char
    4682/    9A42 : 23                                  inc   hl               ; |
    4683/    9A43 : B7                                  or    a                ; |
    4684/    9A44 : 28 FB                               jr    z, loop1D41      ;-+ loop until non-null byte
    4685/    9A46 : 2B                                  dec   hl               ; point to next line
    4686/    9A47 : 22 9A 0C                            ld    (curlineno), hl  ; save position in curlineno
    4687/    9A4A : E1                                  pop   hl               ; restore start of line
    4688/    9A4B : 3E FF                               ld    a, 0FFh          ; set prompt flag = FF
    4689/    9A4D : 32 AB 0C                            ld    (prompt_flag), a
    4690/    9A50 : CD 48 86                            call  skipspace        ; advance in buf to non-empty
    4691/    9A53 : 3C                                  inc   a                ; check char read
    4692/    9A54 : 3D                                  dec   a
    4693/    9A55 : CA A9 81                            jp    z, loop4A9       ; char is zero?, clear line
    4694/    9A58 :                     amerge_enter_line:            
    4695/    9A58 : 30 05                               jr    nc, loc_1D5F     ; no lineno found from skipspace?
    4696/    9A5A : F5                                  push  af               ; save char
    4697/    9A5B : AF                                  xor    a               ; clear char
    4698/    9A5C : C3 F1 81                            jp    loc_4F1          ; jump into line parser to insert the
    4699/    9A5F :                                                            ; line HL points to.
    4700/    9A5F :                                                            ; Note: this, in theory, could overwrite
    4701/    9A5F :                                                            ; the text that AMERGE read in, but this won't
    4702/    9A5F :                                                            ; happen, because a tokenized line is always
    4703/    9A5F :                                                            ; shorter than the plain text line. So it will
    4704/    9A5F :                                                            ; enter a line and then continue with
    4705/    9A5F :                                                            ; the next line of RDR.
    4706/    9A5F : 1E 18               loc_1D5F:       ld    e, 24            ; error code "missing statement number"
    4707/    9A61 : C3 7E 81                            jp    print_error
    4708/    9A64 :                     
    4709/    9A64 : CD 0C 80            get_RDR:        call  READERIN         ; get char from reader
    4710/    9A67 : D8                                  ret   c                ; return if end of file
    4711/    9A68 : E6 7F                               and   MASK_7BIT        ; discard parity bit
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 87 - 8/15/2019 11:33:6


    4712/    9A6A : C9                                  ret
    4713/    9A6B :                     
    4714/    9A6B : CD B4 82            exec_aloadc:    call  new_memory       ; clear memory
    4715/    9A6E : 21 B0 0C            exec_amergec:   ld    hl, inputbuf-1   ; point to inputbuf
    4716/    9A71 : 06 00                               ld    b, 0             ; init char per line cntr
    4717/    9A73 : CD 64 9A            loop1D73:       call  get_RDR          ;<+ get char from reader
    4718/    9A76 : 38 32                               jr    c, loc_1DAA      ; | end of file?, exit done
    4719/    9A78 : 28 F9                               jr    z, loop1D73      ;>+ ignore zero bytes
    4720/    9A7A : FE 7F                               cp    CHAR_RUBOUT      ; | is it a RUBOUT?
    4721/    9A7C : 28 F5                               jr    z, loop1D73      ;-+ yes ignore
    4722/    9A7E : FE 1A                               cp    CHAR_CTRLZ       ; is it CTRL-Z?
    4723/    9A80 : 28 28                               jr    z, loc_1DAA      ; yes end of file, done
    4724/    9A82 : FE 0A                               cp    CHAR_LF          ; is it an LF?
    4725/    9A84 : 20 04                               jr    nz, loc_1D8A     ; no, skip
    4726/    9A86 : 04                                  inc   b                ; test char count
    4727/    9A87 : 05                                  dec   b                
    4728/    9A88 : 28 E9                               jr    z, loop1D73      ; was empty, ignore
    4729/    9A8A : 4F                  loc_1D8A:       ld    c, a             ; save char
    4730/    9A8B : 78                                  ld    a, b             ; get char cntr
    4731/    9A8C : FE FF                               cp    0FFh             ; is it 255?
    4732/    9A8E : 79                                  ld    a, c             ; restore char
    4733/    9A8F : 28 02                               jr    z, loc_1D93      ; yes, ignore more characters
    4734/    9A91 : 23                                  inc   hl               ; advance bufptr
    4735/    9A92 : 04                                  inc   b                ; advance char cnt
    4736/    9A93 : 77                  loc_1D93:       ld    (hl), a          ; put char into buf
    4737/    9A94 : D6 0D                               sub   CHAR_CR          ; check if CR
    4738/    9A96 : 20 DB                               jr    nz, loop1D73     ; no loop
    4739/    9A98 : 77                                  ld    (hl), a          ; store 9 byte in buf
    4740/    9A99 : 3E FE                               ld    a, 0FEh          ; set prompt flag = FE
    4741/    9A9B : 32 AB 0C                            ld    (prompt_flag), a
    4742/    9A9E : 21 B0 0C                            ld    hl, inputbuf-1   ; point to inputbuf
    4743/    9AA1 : CD 47 86                            call  nextchar         ; get next char
    4744/    9AA4 : 3C                                  inc   a                ; end of line?
    4745/    9AA5 : 3D                                  dec   a
    4746/    9AA6 : 28 C6                               jr    z, exec_amergec  ; yes, loop
    4747/    9AA8 : 18 AE                               jr    amerge_enter_line ; jump into AMERGE to process line
    4748/    9AAA : CD C2 82            loc_1DAA:       call  init_from_start  ; clear variables
    4749/    9AAD : C3 A0 81                            jp    print_prompt     ; and return to interpreter loop
    4750/    9AB0 :                     
    4751/    9AB0 :                     ; process LOADGO
    4752/    9AB0 : 32 66 0C            exec_loadgo:    ld    (fpaccu_mant32), a ; save program name
    4753/    9AB3 : CD 47 86                            call  nextchar         ; get next char
    4754/    9AB6 : 11 FF FF                            ld    de, 0FFFFh       ; DE = ffff
    4755/    9AB9 : 28 0E                               jr    z, loc_1DC9      ; end of command, no start lineno given
    4756/    9ABB : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    4756/    9ABB : 3E 2C                               ld    a, CHAR_COMMA
    4756/    9ABD : CD 51 81                            call  expect_char
    4757/    9AC0 : D2 6D 81                            jp    nc, syntax_error
    4758/    9AC3 : CD 85 86                            call  read_lineno      ; get a lineno,
    4759/    9AC6 :                                                            ; not using expression here!
    4760/    9AC6 :                                                            ; only accept a numeric value.
    4761/    9AC6 : C2 6D 81                            jp    nz, syntax_error ; invalid, error
    4762/    9AC9 :                     loc_1DC9:                
    4763/    9AC9 : ED 53 9A 0C                         ld    (curlineno), de  ; store into next line to execute
    4764/    9ACD : 3E FD                               ld    a, 0FDh          ; set prompt flag to -3
    4765/    9ACF : 32 AB 0C                            ld    (prompt_flag), a
    4766/    9AD2 : C3 07 95                            jp    loc_1807         ; load program
    4767/    9AD5 :                     
    4768/    9AD5 : 3C                  sub_1DD5:       inc   a                ; prompting flag in A
    4769/    9AD6 : CA 2D 9A                            jp    z, loc_1D2D      ; was it FF?, yes skip
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 88 - 8/15/2019 11:33:6


    4770/    9AD9 : 3C                                  inc   a                ; was it FE?
    4771/    9ADA : 28 92                               jr    z, exec_amergec  ; yes, continue with AMERGEC
    4772/    9ADC : CD C2 82                            call  init_from_start  ; clear variables
    4773/    9ADF : AF                                  xor    a
    4774/    9AE0 : 32 AB 0C                            ld    (prompt_flag), a ; clear prompt flag
    4775/    9AE3 : ED 5B 9A 0C                         ld    de, (curlineno)  ; is lineno FFFF?
    4776/    9AE7 : 7A                                  ld    a, d
    4777/    9AE8 : A3                                  and   e
    4778/    9AE9 : 3C                                  inc   a
    4779/    9AEA : 01 CC 85                            ld    bc, command_done
    4780/    9AED : C5                                  push  bc
    4781/    9AEE : C8                                  ret   z                ; yes, go back into command_done loop
    4782/    9AEF : C3 DA 87                            jp    loc_ADA
    4783/    9AF2 :                     
    4784/    9AF2 :                     ; COPY newstart,increment=startrange-endrange
    4785/    9AF2 : C8                  exec_copy:      ret   z                ; exit if end of statement
    4786/    9AF3 : D2 44 87                            jp    nc, illfunc_error ; no number follows? error
    4787/    9AF6 : CD 85 86                            call  read_lineno      ; get lineno
    4788/    9AF9 : ED 53 9A 0C                         ld    (curlineno), de  ; save as newstart
    4789/    9AFD : 11 0A 00                            ld    de, 10           ; preload increment of 10
    4790/    9B00 : FE 2C                               cp    CHAR_COMMA       ; does a comma follow?
    4791/    9B02 : 20 06                               jr    nz, loc_1E0A     ; no, skip
    4792/    9B04 : CD 47 86                            call  nextchar         ; get an increment
    4793/    9B07 : DC 85 86                            call  c, read_lineno
    4794/    9B0A : ED 53 9C 0C         loc_1E0A:       ld    (auto_increment), de ; store in autoincrement
    4795/    9B0E : (MACRO)                             EXPECT TOKEN_EQUAL     ; expect a '='
    4795/    9B0E : 3E AD                               ld    a, TOKEN_EQUAL
    4795/    9B10 : CD 51 81                            call  expect_char
    4796/    9B13 : CD 73 82                            call  get_lineno_range ; get a range (endrange on stack),
    4797/    9B16 :                                                            ; BC = nextlink of startrange
    4798/    9B16 : D1                                  pop   de               ; DE = endrange lineno (passed through stack)
    4799/    9B17 : C5                                  push  bc               ; save nextlink of startrange
    4800/    9B18 : (MACRO)                             LDHL_BC                ; put as startrange lineno to search for
    4800/    9B18 : 60                                  ld    h, b
    4800/    9B19 : 69                                  ld    l, c
    4801/    9B1A :                                                            ; endrange lineno into HL
    4802/    9B1A : D9                                  exx                    ; alt set
    4803/    9B1B : 11 01 00                            ld    de, 1            ; preload cntr for counting the lines to move
    4804/    9B1E :                                                            ; DE' = 1 (increment)
    4805/    9B1E : 21 00 00                            ld    hl, 0            ; HL' = 0 (initial value)
    4806/    9B21 : D9                                  exx                    ; std set
    4807/    9B22 : CD 95 82                            call  find_line_from_current ; find nextlink of endrange
    4808/    9B25 :                                                            ; and count the number of lines to move in HL'
    4809/    9B25 : D2 44 87                            jp    nc, illfunc_error ; not found, error
    4810/    9B28 : E5                                  push  hl               ; save nextlink of endrange
    4811/    9B29 : D9                                  exx                    ; alt set
    4812/    9B2A : EB                                  ex    de, hl           ; DE' is count of lines between current position
    4813/    9B2B :                                                            ; and line to copy
    4814/    9B2B :                                                            ; ** from here we are no longer interested
    4815/    9B2B :                                                            ; in data in other set, so no longer marking
    4816/    9B2B :                                                            ; alt registers and no bothering to switch
    4817/    9B2B :                                                            ; back set
    4818/    9B2B : ED 4B 9C 0C                         ld    bc, (auto_increment) ; BC = increment
    4819/    9B2F : 78                                  ld    a, b             ; if zero, error
    4820/    9B30 : B1                                  or    c
    4821/    9B31 : CA 6D 81                            jp    z, syntax_error
    4822/    9B34 : CD C6 A0                            call  umultiply16      ; HL = increment * DE
    4823/    9B37 :                                                            ; = numbering span to expect
    4824/    9B37 : ED 5B 9A 0C                         ld    de, (curlineno)  ; add newstart lineno
    4825/    9B3B : 19                                  add   hl, de           ; to find the highest new number to expect
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 89 - 8/15/2019 11:33:6


    4826/    9B3C : DA 6B 8E                            jp    c, subscript_range_error ; overflow, error
    4827/    9B3F : E5                                  push  hl               ; save as newend lineno
    4828/    9B40 : ED 5B 9A 0C                         ld    de, (curlineno)  ; find nextlink of newstart
    4829/    9B44 : CD 92 82                            call  find_line
    4830/    9B47 : DA 44 87                            jp    c, illfunc_error ; does the newend lineno exist?
    4831/    9B4A :                                                            ; yes error
    4832/    9B4A : D1                                  pop   de               ; DE = newend lineno
    4833/    9B4B : C5                                  push  bc               ; newstart was not there, but we have
    4834/    9B4C :                                                            ; a nextlink position where it would go to
    4835/    9B4C : (MACRO)                             LDHL_BC                ; put into HL
    4835/    9B4C : 60                                  ld    h, b
    4835/    9B4D : 69                                  ld    l, c
    4836/    9B4E : 7E                                  ld    a, (hl)          ; get nextlink of position where to put
    4837/    9B4F :                                                            ; newstart to
    4838/    9B4F : 23                                  inc   hl
    4839/    9B50 : B6                                  or    (hl)
    4840/    9B51 : 28 0A                               jr    z, loc_1E5D      ; if zero, skip (we are at end)
    4841/    9B53 : 23                                  inc   hl               ; get the lineno of this line into HL
    4842/    9B54 : (MACRO)                             LDHL_M A
    4842/    9B54 : 7E                                  ld    A, (hl)
    4842/    9B55 : 23                                  inc   hl
    4842/    9B56 : 66                                  ld    h, (hl)
    4842/    9B57 : 6F                                  ld    l, A
    4843/    9B58 : ED 52                               sbc   hl, de           ; subtract newend lineno
    4844/    9B5A : DA 6B 8E                            jp    c, subscript_range_error ; overlapping? error
    4845/    9B5D : C1                  loc_1E5D:       pop   bc               ; restore ptr of newstart
    4846/    9B5E : E1                                  pop   hl               ; restore ptr of endrange
    4847/    9B5F : D1                                  pop   de               ; restore ptr of startrange
    4848/    9B60 : E5                                  push  hl               ; save ptr of endrange
    4849/    9B61 : ED 52                               sbc   hl, de           ; subtract ptr of startrange
    4850/    9B63 : E3                                  ex    (sp), hl         ; stack is bytes between endrange andstartrange
    4851/    9B64 :                                                            ; HL is endrange ptr
    4852/    9B64 : 2B                                  dec   hl               ; decrement
    4853/    9B65 : ED 42                               sbc   hl, bc           ; layout:
    4854/    9B67 :                                                            ; ....
    4855/    9B67 :                                                            ; startrange---+--+
    4856/    9B67 :                                                            ; ...          |  |stack (bytes in range)
    4857/    9B67 :                                                            ; endrange+-------+
    4858/    9B67 :                                                            ; ...     |    |
    4859/    9B67 :                                                            ; ...     |DE  |HL
    4860/    9B67 :                                                            ; newstart+----+
    4861/    9B67 :                                                            ; ...
    4862/    9B67 :                                                            ;
    4863/    9B67 :                                                            ; HL = bytes from endrange to newstart
    4864/    9B67 : EB                                  ex    de, hl           ; DE is bytes between endrange andnewstart
    4865/    9B68 :                                                            ; HL is startrange ptr
    4866/    9B68 : 38 0A                               jr    c, loc_1E74      ; newstart is above endrange, i.e.
    4867/    9B6A :                                                            ; append behind range
    4868/    9B6A :                                                            ; (as in diagram above)
    4869/    9B6A : ED 42                               sbc   hl, bc           ; bytes from startrange to newstart
    4870/    9B6C : DA 44 87                            jp    c, illfunc_error ; negative result?
    4871/    9B6F : 09                                  add   hl, bc           ; undo
    4872/    9B70 : EB                                  ex    de, hl           ; DE is startrange ptr
    4873/    9B71 : E1                                  pop   hl               ; restore bytes in range
    4874/    9B72 : E5                                  push  hl               ; save bytes in range
    4875/    9B73 : 19                                  add   hl, de           ; HL is startrange+bytes in range
    4876/    9B74 : E3                  loc_1E74:       ex    (sp), hl         ; insert on stack
    4877/    9B75 : E5                                  push  hl               ; HL is bytes in range
    4878/    9B76 : 50                                  ld    d, b             ; DE is newstart ptr
    4879/    9B77 : 59                                  ld    e, c
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 90 - 8/15/2019 11:33:6


    4880/    9B78 : ED 4B 5E 0C                         ld    bc, (prog_end)   ; end of program ptr
    4881/    9B7C : 09                                  add   hl, bc           ; add bytes in range
    4882/    9B7D : E5                                  push  hl               ; save
    4883/    9B7E : CD 19 81                            call  make_space       ; DE=start, BC=old end, HL=new end
    4884/    9B81 :                                                            ; reserve space
    4885/    9B81 : E1                                  pop   hl               ; set new end of range
    4886/    9B82 : 22 5E 0C                            ld    (prog_end), hl
    4887/    9B85 : (MACRO)                             LDHL_BC                ; HL is old end of program
    4887/    9B85 : 60                                  ld    h, b
    4887/    9B86 : 69                                  ld    l, c
    4888/    9B87 : C1                                  pop   bc               ; BC is bytes to copy
    4889/    9B88 : E3                                  ex    (sp), hl         ; HL is ptr to start of range to copy
    4890/    9B89 : D5                                  push  de               ; DE is newstart save it
    4891/    9B8A : ED B0                               ldir                   ; copy the lines
    4892/    9B8C : E1                                  pop   hl               ; restore ptr to nextlink of newstart
    4893/    9B8D : ED 4B 9A 0C                         ld    bc, (curlineno)  ; get the newstart lineno
    4894/    9B91 : 23                  loop1E91:       inc   hl               ;<--+ skip over nextlink
    4895/    9B92 : 23                                  inc   hl               ;   | 
    4896/    9B93 : (MACRO)                             LDM_BC                 ;   | put new lineno in line
    4896/    9B93 : 71                                  ld    (hl), c
    4896/    9B94 : 23                                  inc   hl
    4896/    9B95 : 70                                  ld    (hl), b
    4897/    9B96 : 23                  loop1E96:       inc   hl               ;<+ | advance to end of line
    4898/    9B97 : 7E                                  ld    a, (hl)          ; | | 
    4899/    9B98 : B7                                  or    a                ; | | 
    4900/    9B99 : 20 FB                               jr    nz, loop1E96     ;-+ | loop
    4901/    9B9B : 23                                  inc   hl               ;   | skip over 0 byte, pointing to 
    4902/    9B9C :                                                            ;   | nextlink of following line
    4903/    9B9C : D1                                  pop   de               ;   | restore endrange ptr
    4904/    9B9D : (MACRO)                             CPHL_DE                ;   | end reached?
    4904/    9B9D : 7C                                  ld    a, h
    4904/    9B9E : 92                                  sub   d
    4904/    9B9F : 20 02                               jr    nz, m1
    4904/    9BA1 : 7D                                  ld    a, l
    4904/    9BA2 : 93                                  sub   e
    4904/    9BA3 :                     m1:
    4905/    9BA3 : 28 0B                               jr    z, loc_1EB0      ;   | yes, we're finished, cleanup
    4906/    9BA5 : D5                                  push  de               ;   | save endrange ptr
    4907/    9BA6 : EB                                  ex    de, hl           ;   | save ptr to line
    4908/    9BA7 : 2A 9C 0C                            ld    hl, (auto_increment) ; get increment
    4909/    9BAA : 09                                  add   hl, bc           ;   | add current lineno
    4910/    9BAB : (MACRO)                             LDBC_HL                ;   | put into BC for next round
    4910/    9BAB : 44                                  ld    b, h
    4910/    9BAC : 4D                                  ld    c, l
    4911/    9BAD : EB                                  ex    de, hl           ;   | restore ptr to line
    4912/    9BAE : 18 E1                               jr    loop1E91         ;---+ process next line
    4913/    9BB0 : CD DB 89            loc_1EB0:       call  print_ready_prompt ; print OK
    4914/    9BB3 : C3 56 82                            jp    rebuild_nextchain ; fixup the nextlink chain
    4915/    9BB6 :                     
    4916/    9BB6 :                     exec_exchange:
    4917/    9BB6 : CD 6A 8D                            call  find_var         ; find first variable
    4918/    9BB9 : D5                                  push  de               ; save addr of 1st var
    4919/    9BBA : E5                                  push  hl               ; save curlineptr
    4920/    9BBB : 21 6D 0C                            ld    hl, numberbuf0   ; move first var into a temporary save
    4921/    9BBE : CD 19 A0                            call  move_to_var
    4922/    9BC1 : 2A 60 0C                            ld    hl, (end_of_vars) ; get variable end
    4923/    9BC4 : E3                                  ex    (sp), hl         ; stack is end_of_vars
    4924/    9BC5 :                                         ; HL is    curlineptr
    4925/    9BC5 : 3A 02 0C                            ld    a, (expr_type)   ; save type of variable
    4926/    9BC8 : F5                                  push  af
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 91 - 8/15/2019 11:33:6


    4927/    9BC9 : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    4927/    9BC9 : 3E 2C                               ld    a, CHAR_COMMA
    4927/    9BCB : CD 51 81                            call  expect_char
    4928/    9BCE : CD 6A 8D                            call  find_var         ; get second var
    4929/    9BD1 : C1                                  pop   bc               ; DE is addr of 2nd var
    4930/    9BD2 :                                                            ; restore type into B
    4931/    9BD2 : 3A 02 0C                            ld    a, (expr_type)   ; get type of variable
    4932/    9BD5 : A8                                  xor    b               ; compare with type of 1st var
    4933/    9BD6 : 1F                                  rra                    ; result into CY
    4934/    9BD7 : DA 90 8B                            jp    c, type_mismatch_error ; error if types don't match
    4935/    9BDA : E3                                  ex    (sp), hl         ; stack = curlineptr
    4936/    9BDB :                                                            ; HL = end_of_vars
    4937/    9BDB : EB                                  ex    de, hl           ; DE = end_of_vars
    4938/    9BDC :                                                            ; HL = address of 2nd var
    4939/    9BDC : E5                                  push  hl               ; save it
    4940/    9BDD : 2A 60 0C                            ld    hl, (end_of_vars) ; compare end_of_vars with old value
    4941/    9BE0 : (MACRO)                             CPHL_DE                 was second variable newly declared?
    4941/    9BE0 : 7C                                  ld    a, h
    4941/    9BE1 : 92                                  sub   d
    4941/    9BE2 : 20 02                               jr    nz, m1
    4941/    9BE4 : 7D                                  ld    a, l
    4941/    9BE5 : 93                                  sub   e
    4941/    9BE6 :                     m1:
    4942/    9BE6 : C2 44 87                            jp    nz, illfunc_error ; yes, error
    4943/    9BE9 : D1                                  pop   de               ; DE = addr of 2nd var
    4944/    9BEA : E1                                  pop   hl               ; HL = curlineptr
    4945/    9BEB : E3                                  ex    (sp), hl         ; stack is curlineptr
    4946/    9BEC :                                                            ; HL is addr of 1st var
    4947/    9BEC : D5                                  push  de               ; save 2nd var
    4948/    9BED : CD 19 A0                            call  move_to_var      ; move 1st var -> 2nd var
    4949/    9BF0 : E1                                  pop   hl               ; restore 2nd var
    4950/    9BF1 : 11 6D 0C                            ld    de, numberbuf0   ; move scratchpad to 2nd var
    4951/    9BF4 : CD 19 A0                            call  move_to_var
    4952/    9BF7 : E1                                  pop   hl               ; restore curlineptr
    4953/    9BF8 : C9                                  ret
    4954/    9BF9 :                     
    4955/    9BF9 : 3E 01               exec_kill:      ld    a, 1             ; set subscript flag to 1, i.e. 
    4956/    9BFB :                                                            ; to search for arrays without subscript
    4957/    9BFB : 32 4E 0C                            ld    (subscript_flag), a
    4958/    9BFE : C3 6A 8D                            jp    find_var
    4959/    9C01 :                     
    4960/    9C01 :                     kill_array:                            ; HL points to #indices in array
    4961/    9C01 : E5                                  push  hl               ; DE is total size of array
    4962/    9C02 : 19                                  add   hl, de           ; calculate end of array
    4963/    9C03 : EB                                  ex    de, hl           ; save it in DE
    4964/    9C04 : 2A 62 0C                            ld    hl, (end_arrays) ; get end_array ptr
    4965/    9C07 : B7                                  or    a                ; set CY
    4966/    9C08 : ED 52                               sbc   hl, de           ; calculate size of range to move
    4967/    9C0A : E3                                  ex    (sp), hl         ; stack = size to move
    4968/    9C0B :                                                            ; HL = ptr to indices
    4969/    9C0B : C1                                  pop   bc               ; BC = move size
    4970/    9C0C : EB                                  ex    de, hl           ; HL = ptr to new end of arrays
    4971/    9C0D :                                                            ; DE = ptr to start of array
    4972/    9C0D : 1B                                  dec   de               ; adjust (total size and variable name)
    4973/    9C0E : 1B                                  dec   de
    4974/    9C0F : 1B                                  dec   de
    4975/    9C10 : 1B                                  dec   de
    4976/    9C11 : 28 02                               jr    z, loc_1F15      ; unless empty, move data
    4977/    9C13 : ED B0                               ldir
    4978/    9C15 : ED 53 62 0C         loc_1F15:       ld    (end_arrays), de ; store new end of array
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 92 - 8/15/2019 11:33:6


    4979/    9C19 : 32 4E 0C            loc_1F19:       ld    (subscript_flag), a ; (A was 0) clear subscript flag
    4980/    9C1C : E1                                  pop   hl               ; restore curlineptr
    4981/    9C1D : 7E                                  ld    a, (hl)          ; get next char
    4982/    9C1E : FE 2C                               cp    CHAR_COMMA       ; was comma?
    4983/    9C20 : C0                                  ret   nz               ; no, exit
    4984/    9C21 : CD 47 86                            call  nextchar         ; yes, get next char
    4985/    9C24 : 18 D3                               jr    exec_kill        ; and continue in kill
    4986/    9C26 : C8                  exec_call:      ret   z                ; no arguments follow? exit
    4987/    9C27 : ED 73 9A 0C                         ld    (curlineno), sp  ; save stack to curlineno
    4988/    9C2B : E5                                  push  hl               ; save curlineptr
    4989/    9C2C : 11 57 9C                            ld    de, hlrestore    ; push HL restore to return stack
    4990/    9C2F : D5                                  push  de
    4991/    9C30 : CD 24 87                            call  expression_u16   ; get address expression
    4992/    9C33 : 0E 00                               ld    c, 0             ; count number of arguments
    4993/    9C35 : D5                  loop1F35:       push  de               ;<+ push call address on stack
    4994/    9C36 : CD 48 86                            call  skipspace        ; | advance
    4995/    9C39 : 28 11                               jr    z, call2b        ; | end of statement? done with arguments
    4996/    9C3B : (MACRO)                             EXPECT CHAR_COMMA      ; | expect a comma
    4996/    9C3B : 3E 2C                               ld    a, CHAR_COMMA
    4996/    9C3D : CD 51 81                            call  expect_char
    4997/    9C40 : 0C                                  inc   c                ; | increment argument count
    4998/    9C41 : C5                                  push  bc               ; | save argument count
    4999/    9C42 : CD 24 87                            call  expression_u16   ; | get argument
    5000/    9C45 : C1                                  pop   bc               ; | 
    5001/    9C46 : EB                                  ex    de, hl           ; | DE is curlineptr
    5002/    9C47 :                                                            ; | HL is argument
    5003/    9C47 : E3                                  ex    (sp), hl         ; | stack is argument
    5004/    9C48 :                                                            ; | HL is call address
    5005/    9C48 : EB                                  ex    de, hl           ; | DE is call address
    5006/    9C49 :                                                            ; | HL is curlineptr
    5007/    9C49 : 18 EA                               jr    loop1F35         ;-+ loop over all arguments
    5008/    9C4B :                     
    5009/    9C4B : D5                  call2:          push  de               ; push caller address
    5010/    9C4C : EB                  call2b:         ex    de, hl           ; DE is curlineptr
    5011/    9C4D :                                                            ; HL is caller address
    5012/    9C4D : 2A 9A 0C                            ld    hl, (curlineno)  ; get initial stack ptr
    5013/    9C50 :                                                            ; is location where call address
    5014/    9C50 :                                                            ; was pushed initially
    5015/    9C50 : 2B                                  dec   hl               ; put curlineptr in it
    5016/    9C51 : 72                                  ld    (hl), d
    5017/    9C52 : 2B                                  dec   hl
    5018/    9C53 : 73                                  ld    (hl), e
    5019/    9C54 : 2B                                  dec   hl               ; point to HL restore routine
    5020/    9C55 : 2B                                  dec   hl
    5021/    9C56 : C9                                  ret                    ; return to call address
    5022/    9C57 :                     
    5023/    9C57 :                     ; calling convention:
    5024/    9C57 :                                         ; C contains number of 16bit arguments
    5025/    9C57 :                                         ; Stack    -> argumentN
    5026/    9C57 :                                         ;       argumentN-1
    5027/    9C57 :                                         ;       ...
    5028/    9C57 :                                         ;       argument1
    5029/    9C57 :                                         ; HL contains return address
    5030/    9C57 :                                         ; return from caller via JP (HL)
    5031/    9C57 :                                         ;
    5032/    9C57 :                                         ; will jump on HLrestore which will
    5033/    9C57 :                                         ; restore the curlineptr andthen exit
    5034/    9C57 :                                         ; int interpreter loop
    5035/    9C57 :                                         ;
    5036/    9C57 : E1                  hlrestore:      pop   hl               ; pop pending HL value (curlineptr?) from stack
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 93 - 8/15/2019 11:33:6


    5037/    9C58 : C9                                  ret
    5038/    9C59 :                     
    5039/    9C59 :                     ; process PRECISION
    5040/    9C59 : 3E 00               exec_precision: ld    a, 0             ; get precision 0
    5041/    9C5B : C4 1B 94                            call  nz, expression_u8_ae ; if argument, get expression
    5042/    9C5E : C0                                  ret   nz               ; exit if more arguments
    5043/    9C5F : FE 0B                               cp    0Bh              ; is it exactly 11?, then set precision  0
    5044/    9C61 : 28 F6                               jr    z, exec_precision
    5045/    9C63 : D2 44 87                            jp    nc, illfunc_error ; is it larger? error
    5046/    9C66 : 32 AF 0C                            ld    (precision), a   ; save precision value
    5047/    9C69 : C9                                  ret
    5048/    9C6A :                     
    5049/    9C6A :                     ; process PEEK()
    5050/    9C6A : CD 27 87            math_peek:      call  fpaccu_to_u16    ; get 16 bit argument in DE
    5051/    9C6D : 1A                                  ld    a, (de)          ; get value from memory at DE
    5052/    9C6E : C3 32 8F                            jp    uA_to_fpaccu     ; put result
    5053/    9C71 :                     
    5054/    9C71 :                     ; process POKE command
    5055/    9C71 : CD 24 87            exec_poke:      call  expression_u16   ; get a 16 bit expression in DE
    5056/    9C74 : D5                                  push  de               ; save address
    5057/    9C75 : (MACRO)                             EXPECT CHAR_COMMA      ; expect a comma
    5057/    9C75 : 3E 2C                               ld    a, CHAR_COMMA
    5057/    9C77 : CD 51 81                            call  expect_char
    5058/    9C7A : CD 1B 94                            call  expression_u8_ae ; get 8 bit expression
    5059/    9C7D : D1                                  pop   de               ; restore address
    5060/    9C7E : 12                                  ld    (de), a          ; save data
    5061/    9C7F : C9                                  ret
    5062/    9C80 :                     
    5063/    9C80 :                     ; addconstant 0.5
    5064/    9C80 : 21 08 A7            add_0_5:        ld    hl, const0_5     ; constant 0.5
    5065/    9C83 :                     load_and_add_fpaccu:
    5066/    9C83 : CD 05 A0                            call  load_fpreg
    5067/    9C86 : 18 0C                               jr    add_fpreg_fpaccu
    5068/    9C88 :                     
    5069/    9C88 :                     load_fpreg_and_subtr:
    5070/    9C88 : CD 05 A0                            call  load_fpreg
    5071/    9C8B : 18 04                               jr    subtr_fpreg_fpaccu
    5072/    9C8D :                     
    5073/    9C8D :                     pop_fpreg_and_sub:
    5074/    9C8D : (MACRO)                             POP_FPREG
    5074/    9C8D : C1                                  pop   bc
    5074/    9C8E : DD E1                               pop   ix
    5074/    9C90 : D1                                  pop   de
    5075/    9C91 :                     
    5076/    9C91 :                     ; subtract fpreg - fpaccu => fpaccu
    5077/    9C91 :                     subtr_fpreg_fpaccu:
    5078/    9C91 : CD D2 9F                            call  fpaccu_changesign ; change sign of fpaccu
    5079/    9C94 :                     
    5080/    9C94 :                     ; add fpaccu andFPreg, result in fpaccu
    5081/    9C94 :                     add_fpreg_fpaccu:
    5082/    9C94 : 78                                  ld    a, b             ; get fpreg exponent
    5083/    9C95 : B7                                  or    a
    5084/    9C96 : C8                                  ret   z                ; if zero, then done
    5085/    9C97 : 3A 6B 0C                            ld    a, (fpaccu_exp)  ; get fpaccu exponent
    5086/    9C9A : B7                                  or    a                ; is zero?
    5087/    9C9B : CA F5 9F                            jp    z, store_fpaccu  ; yes, just store FPreg into fpaccu
    5088/    9C9E : 90                                  sub   b                ; subtract fpreg exp from fpaccu exp
    5089/    9C9F : 30 11                               jr    nc, loc_1FB2
    5090/    9CA1 : ED 44                               neg
    5091/    9CA3 : D9                                  exx                    ; save fpreg temporarily
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 94 - 8/15/2019 11:33:6


    5092/    9CA4 :                                                            ; FPREG in alternative regs
    5093/    9CA4 : DD E5                               push  ix               ; including ix
    5094/    9CA6 : CD 02 A0                            call  fpaccu_to_fpreg  ; copy fpaccu to fpreg
    5095/    9CA9 : D9                                  exx                    ; restore fpreg
    5096/    9CAA :                                                            ; fpaccu in alternative regs
    5097/    9CAA : DD E3                               ex    (sp), ix         ; including ix
    5098/    9CAC : CD F5 9F                            call  store_fpaccu     ; store in fpaccu
    5099/    9CAF : D9                                  exx                    ; fpaccu in these registers
    5100/    9CB0 : DD E1                               pop   ix
    5101/    9CB2 : FE 29               loc_1FB2:       cp    29h              ; do exponents differ too much?
    5102/    9CB4 : D0                                  ret   nc               ; yes, ignore (adding a large number
    5103/    9CB5 :                                                            ; and a very small one) and exit
    5104/    9CB5 : F5                                  push  af               ; save difference of exponent
    5105/    9CB6 : CD 21 A0                            call  fpaccu_restoresign ; restore the sign of mantissa
    5106/    9CB9 : 67                                  ld    h, a             ; save sign in H
    5107/    9CBA : F1                                  pop   af               ; restore shift count
    5108/    9CBB : CD 8F 9D                            call  fpreg_shiftmant  ; adjust fpreg to same exponent as fpaccu
    5109/    9CBE : B4                                  or    h                ; was positive sign?
    5110/    9CBF : 21 66 0C                            ld    hl, fpaccu_mant32 ; load address of fpaccu
    5111/    9CC2 : F2 D6 9C                            jp    p, subtr_mantissa ; go subtract mantissas
    5112/    9CC5 : CD 5A 9D                            call  add_mantissas    ; add mantissas
    5113/    9CC8 : 30 69                               jr    nc, round_store_fpreg ; overflow?
    5114/    9CCA : 23                                  inc   hl               ; yes
    5115/    9CCB : 34                                  inc   (hl)             ; increment exponent
    5116/    9CCC : CA 55 9D                            jp    z, e_overflow    ; too bad, exponent overflow, error
    5117/    9CCF : 2E 01                               ld    l, 1
    5118/    9CD1 : CD AC 9D                            call  mant_shiftright1 ; shift mantissa 1 bit
    5119/    9CD4 :                                                            ; (because exponent was incremented)
    5120/    9CD4 : 18 5D                               jr    round_store_fpreg ; round fpreg and store in fpaccu
    5121/    9CD6 : AF                  subtr_mantissa: xor   a                ; subtract adjusted mantissas
    5122/    9CD7 : 90                                  sub   b
    5123/    9CD8 : 47                                  ld    b, a
    5124/    9CD9 : 7E                                  ld    a, (hl)
    5125/    9CDA : 9B                                  sbc   a, e
    5126/    9CDB : 5F                                  ld    e, a
    5127/    9CDC : 23                                  inc   hl
    5128/    9CDD : 7E                                  ld    a, (hl)
    5129/    9CDE : 9A                                  sbc   a, d
    5130/    9CDF : 57                                  ld    d, a
    5131/    9CE0 : 23                                  inc   hl
    5132/    9CE1 : 7E                                  ld    a, (hl)
    5133/    9CE2 : DD 9D                               sbc   a, ixl
    5134/    9CE4 : DD 6F                               ld    ixl, a
    5135/    9CE6 : 23                                  inc   hl
    5136/    9CE7 : 7E                                  ld    a, (hl)
    5137/    9CE8 : DD 9C                               sbc   a, ixh
    5138/    9CEA : DD 67                               ld    ixh, a
    5139/    9CEC : 23                                  inc   hl
    5140/    9CED : 7E                                  ld    a, (hl)
    5141/    9CEE : 99                                  sbc   a, c
    5142/    9CEF : 4F                                  ld    c, a
    5143/    9CF0 :                     				
    5144/    9CF0 :                     ; normalize and round a number in FPreg, and store in fpaccu
    5145/    9CF0 :                     ; if CY, complement mantissa
    5146/    9CF0 :                     ; mant6-mant1 = C,ixh,ixl,D,H,L
    5147/    9CF0 :                     ; exponent = B
    5148/    9CF0 :                     
    5149/    9CF0 :                     fpreg_normalize:            
    5150/    9CF0 : DC 72 9D                            call  c, fpreg_complement ; complement FPaccu in registers
    5151/    9CF3 : 68                  loc_1FF3:       ld    l, b             ; copy BE -> HL
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 95 - 8/15/2019 11:33:6


    5152/    9CF4 : 63                                  ld    h, e
    5153/    9CF5 : AF                                  xor   a                ; clear lower mantissa
    5154/    9CF6 : 47                  loop1FF6:       ld    b, a
    5155/    9CF7 : 79                         		ld    a, c             ; get highest mantissa
    5156/    9CF8 : B7                                  or    a
    5157/    9CF9 : 20 27                     		jr    nz, loc_2022     ;<+ not zero, shift single
    5158/    9CFB : DD 4C               		ld    c, ixh            ; | high mantissa is 0, shift mantissa a byte
    5159/    9CFD :                                                            ; | ixh -> C
    5160/    9CFD : DD 7D                               ld    a, ixl            ; | ixl -> ixh
    5161/    9CFF : DD 67                               ld    ixh, a            ; | 
    5162/    9D01 : DD 6A                               ld    ixl, d            ; | D -> ixl
    5163/    9D03 : AF                                  xor    a               ; | 
    5164/    9D04 : 54                                  ld    d, h             ; | H -> D
    5165/    9D05 : 65                                  ld    h, l             ; | L -> H
    5166/    9D06 : 6F                                  ld    l, a             ; | 0 -> L
    5167/    9D07 : 78                                  ld    a, b             ; | get exponent
    5168/    9D08 : D6 08                               sub   8                ; | subtract 8
    5169/    9D0A : FE D0                               cp    0D0h             ; | 
    5170/    9D0C : 20 E8                               jr    nz, loop1FF6     ;-+ not yet zero? loop
    5171/    9D0E :                     
    5172/    9D0E :                     ; load zero in fpaccu
    5173/    9D0E : AF                  fpaccu_zero:    xor   a                ; accu is zero
    5174/    9D0F : 32 6B 0C            loc_200F:       ld    (fpaccu_exp), a
    5175/    9D12 : C9                                  ret
    5176/    9D13 :                     
    5177/    9D13 :                     ; part of normalizing FPreg:
    5178/    9D13 :                     ; B = binary exponent
    5179/    9D13 :                     ; C = high mantissa (6)
    5180/    9D13 :                     ; IXH =    mantissa (5)
    5181/    9D13 :                     ; IXL =    mantissa (4)
    5182/    9D13 :                     ; D = mantissa (3)
    5183/    9D13 :                     ; H = mantissa (2)
    5184/    9D13 :                     ; L = lowest mantissa (1)
    5185/    9D13 : 05                  loop2013:       dec   b                ;<+ decrement exponent
    5186/    9D14 : 29                                  add   hl, hl           ; | shift HL left
    5187/    9D15 : CB 12                               rl    d                ; | rotate into D
    5188/    9D17 : 08                                  ex    af, af'          ; | save flags
    5189/    9D18 : DD 29                               add   ix, ix           ; | shift IX left
    5190/    9D1A : 08                                  ex    af, af'          ; | restore flags, CY from IX is in AF'
    5191/    9D1B : 30 02                               jr    nc, loc_201F     ; | no CY from D? skip
    5192/    9D1D : DD 23                               inc   ix               ; | move CY from D into IX
    5193/    9D1F : 08                  loc_201F:       ex    af, af'          ; | get CY from IX
    5194/    9D20 : CB 11                               rl    c                ; | rotate into C
    5195/    9D22 : F2 13 9D            loc_2022:       jp    p, loop2013      ;-+ highest mantissa still positive?, yes skip
    5196/    9D25 : 78                                  ld    a, b             ; get exponent
    5197/    9D26 : 5C                                  ld    e, h             ; save HL -> EB
    5198/    9D27 : 45                                  ld    b, l
    5199/    9D28 : B7                                  or    a                ; exponent zero?
    5200/    9D29 : 28 08                               jr    z, round_store_fpreg ; yes, skip
    5201/    9D2B : 21 6B 0C                            ld    hl, fpaccu_exp   ; get binary shift
    5202/    9D2E : 86                                  add   a, (hl)          ; addit to exponent
    5203/    9D2F : 77                                  ld    (hl), a          ; store it
    5204/    9D30 : 30 DC                               jr    nc, fpaccu_zero  ; underflow?, mark as zero
    5205/    9D32 : C8                                  ret   z                ; exit zero
    5206/    9D33 :                     round_store_fpreg:                     ; get lowest mantissa
    5207/    9D33 : 78                                  ld    a, b
    5208/    9D34 : 21 6B 0C            loc_2034:       ld    hl, fpaccu_exp   ; get shift
    5209/    9D37 : B7                                  or	a
    5210/    9D38 : FC 45 9D                            call  m, mant_inc_r    ; if negative, round FPreg up
    5211/    9D3B : 46                                  ld    b, (hl)          ; B = adjustment
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 96 - 8/15/2019 11:33:6


    5212/    9D3C : 23                                  inc   hl               ; point to sign mantissa
    5213/    9D3D : 7E                                  ld    a, (hl)          ; mask out sign bit
    5214/    9D3E : E6 80                               and   80h
    5215/    9D40 : A9                                  xor    c               ; merge into high mantissa (suppressed MSB)
    5216/    9D41 : 4F                                  ld    c, a
    5217/    9D42 : C3 F5 9F                            jp    store_fpaccu     ; store it in accu1
    5218/    9D45 :                     
    5219/    9D45 : 1C                  mant_inc_r:     inc   e                ; increment mantissa 2
    5220/    9D46 : C0                                  ret   nz               ; exit unless carry
    5221/    9D47 : 14                                  inc   d                ; increment mantissa 3
    5222/    9D48 : C0                                  ret   nz
    5223/    9D49 : DD 2C                               inc   ixl               ; increment mantissa 4
    5224/    9D4B : C0                                  ret   nz
    5225/    9D4C : DD 24                               inc   ixh
    5226/    9D4E : C0                                  ret   nz               ; exit unless carry
    5227/    9D4F : 0C                                  inc   c                ; increment mantissa 6
    5228/    9D50 : C0                                  ret   nz
    5229/    9D51 : 0E 80                               ld    c, 80h           ; highest mantissa became 0
    5230/    9D53 :                                                            ; make 0x80 again
    5231/    9D53 : 34                                  inc   (hl)             ; needs adjustment again
    5232/    9D54 : C0                                  ret   nz               ; oops, this also overflowed?
    5233/    9D55 : 1E 06               e_overflow:     ld    e, 6             ; error code "arithmetic overflow"
    5234/    9D57 : C3 7E 81                            jp    print_error
    5235/    9D5A :                     
    5236/    9D5A : 7E                  add_mantissas:  ld    a, (hl)          ; add adjusted mantissas
    5237/    9D5B : 83                                  add   a, e
    5238/    9D5C : 5F                                  ld    e, a
    5239/    9D5D : 23                                  inc   hl
    5240/    9D5E : 7E                                  ld    a, (hl)
    5241/    9D5F : 8A                                  adc   a, d
    5242/    9D60 : 57                                  ld    d, a
    5243/    9D61 : 23                                  inc   hl
    5244/    9D62 : 7E                                  ld    a, (hl)
    5245/    9D63 : DD 8D                               adc   a, ixl
    5246/    9D65 : DD 6F                               ld    ixl, a
    5247/    9D67 : 23                                  inc   hl
    5248/    9D68 : 7E                                  ld    a, (hl)
    5249/    9D69 : DD 8C                               adc   a, ixh
    5250/    9D6B : DD 67                               ld    ixh, a
    5251/    9D6D : 23                                  inc   hl
    5252/    9D6E : 7E                                  ld    a, (hl)
    5253/    9D6F : 89                                  adc   a, c
    5254/    9D70 : 4F                                  ld    c, a
    5255/    9D71 : C9                                  ret
    5256/    9D72 :                     
    5257/    9D72 :                     fpreg_complement:
    5258/    9D72 : 21 6C 0C                            ld    hl, fpaccu_mantsign
    5259/    9D75 : 7E                                  ld    a, (hl)          ; complement sign of mantissa
    5260/    9D76 : 2F                                  cpl
    5261/    9D77 : 77                                  ld    (hl), a
    5262/    9D78 : AF                                  xor    a
    5263/    9D79 : 6F                                  ld    l, a             ; clear HL
    5264/    9D7A : 67                                  ld    h, a
    5265/    9D7B : 90                                  sub   b                ; complement B
    5266/    9D7C : 47                                  ld    b, a
    5267/    9D7D : 7D                                  ld    a, l             ; A = 0
    5268/    9D7E : ED 52                               sbc   hl, de           ; complement DE
    5269/    9D80 : EB                                  ex    de, hl
    5270/    9D81 : 6F                                  ld    l, a             ; L = 0
    5271/    9D82 : DD 9D                               sbc   a, ixl            ; complement ixl
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 97 - 8/15/2019 11:33:6


    5272/    9D84 : DD 6F                               ld    ixl, a
    5273/    9D86 : 7D                                  ld    a, l             ; A = 0
    5274/    9D87 : DD 9C                               sbc   a, ixh            ; complement ixh
    5275/    9D89 : DD 67                               ld    ixh, a
    5276/    9D8B : 7D                                  ld    a, l             ; A = 0
    5277/    9D8C : 99                                  sbc   a, c             ; complement C
    5278/    9D8D : 4F                                  ld    c, a
    5279/    9D8E : C9                                  ret
    5280/    9D8F :                     
    5281/    9D8F :                     fpreg_shiftmant:
    5282/    9D8F : 06 00                               ld    b, 0             ; load zero
    5283/    9D91 : D6 08               mant_shift8:    sub   8                ; subtract 8 from exponent
    5284/    9D93 : 38 10                               jr    c, loc_20A5      ; borrow, skip
    5285/    9D95 : 43                                  ld    b, e             ; E -> B
    5286/    9D96 : 5A                                  ld    e, d             ; D -> E
    5287/    9D97 : DD 55                               ld    d, ixl            ; ixl -> D
    5288/    9D99 : 08                                  ex    af, af'
    5289/    9D9A : DD 7C                               ld    a, ixh
    5290/    9D9C : DD 6F                               ld    ixl, a            ; ixh -> ixl
    5291/    9D9E : 08                                  ex    af, af'
    5292/    9D9F : DD 61                               ld    ixh, c            ; C -> ixh
    5293/    9DA1 : 0E 00                               ld    c, 0             ; 0 -> C
    5294/    9DA3 : 18 EC                               jr    mant_shift8      ; loop
    5295/    9DA5 : C6 09               loc_20A5:       add   a, 9             ; correct exponent again
    5296/    9DA7 : 6F                                  ld    l, a             ; save exp in l
    5297/    9DA8 : AF                  mant_shift1:    xor   a                ; clear    a
    5298/    9DA9 : 2D                                  dec   l                ; decrement exp
    5299/    9DAA : C8                                  ret   z                ; exit if zero
    5300/    9DAB : 79                  				ld    a, c             ; get mant6
    5301/    9DAC :                     mant_shiftright1:            
    5302/    9DAC : 1F                                  rra
    5303/    9DAD : 4F                  				ld    c,a              ; shift right C
    5304/    9DAE : DD 7C                               ld    a, ixh            ; shift right ixh
    5305/    9DB0 : 1F                                  rra
    5306/    9DB1 : DD 67                               ld    ixh, a            ; A -> ixh
    5307/    9DB3 : DD 7D               loc_20B3:       ld    a, ixl            ; shift right ixl
    5308/    9DB5 : 1F                                  rra
    5309/    9DB6 : DD 6F                               ld    ixl, a
    5310/    9DB8 : CB 1A                               rr    d                ; shift right D
    5311/    9DBA : CB 1B                               rr    e                ; shift right E
    5312/    9DBC : CB 18                               rr    b                ; shift right B
    5313/    9DBE : 18 E8                               jr    mant_shift1      ; loop
    5314/    9DC0 :                     
    5315/    9DC0 : 00 00 00 00 00 81   const1:         db    0, 0, 0, 0, 0, 81h ; 1.0
    5316/    9DC6 : 06                  LOG_poly_tbl:   db    6
    5317/    9DC7 : 23 85 AC C3 11 7F                   db    23h, 85h, 0ACh, 0C3h, 11h, 7Fh ; 0.28469600
    5318/    9DCD : 53 CB 9E B7 23 7F                   db    53h, 0CBh, 9Eh, 0B7h, 23h, 7Fh ; 0.31976029
    5319/    9DD3 : CC FE A6 0D 53 7F                   db    0CCh, 0FEh, 0A6h, 0Dh, 53h, 7Fh ; 0.41221353
    5320/    9DD9 : CB 5C 60 BB 13 80                   db    0CBh, 5Ch, 60h, 0BBh, 13h, 80h ; 0.57634547
    5321/    9DDF : DD E3 4E 38 76 80                   db    0DDh, 0E3h, 4Eh, 38h, 76h, 80h ; 0.96179669
    5322/    9DE5 : 5C 29 3B AA 38 82                   db    5Ch, 29h, 3Bh, 0AAh, 38h, 82h ; 2.88539008
    5323/    9DEB :                     
    5324/    9DEB : CD BF 9F            math_log:       call  fpaccu_sgn       ; get sign
    5325/    9DEE : B7                                  or    a
    5326/    9DEF : EA 44 87                            jp    pe, illfunc_error ; negative? yes error
    5327/    9DF2 : 21 6B 0C                            ld    hl, fpaccu_exp
    5328/    9DF5 : 7E                                  ld    a, (hl)          ; get exponent
    5329/    9DF6 : (MACRO)                             FPREG_CONST 8035h, 4F3h, 33FAh ; constant 1/SQR(2)
    5329/    9DF6 : 01 35 80                            ld    bc, 8035H
    5329/    9DF9 : DD 21 F3 04                         ld    ix, 4F3H
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 98 - 8/15/2019 11:33:6


    5329/    9DFD : 11 FA 33                            ld    de, 33FAH
    5330/    9E00 : 90                                  sub   b                ; normalize exponent
    5331/    9E01 :                                                            ; reuse 0x80 from constant
    5332/    9E01 : F5                                  push  af               ; save it for later
    5333/    9E02 : 70                                  ld    (hl), b          ; put it into fpaccu
    5334/    9E03 : (MACRO)                             PUSH_FPREG             ; save constant
    5334/    9E03 : D5                                  push  de
    5334/    9E04 : DD E5                               push  ix
    5334/    9E06 : C5                                  push  bc
    5335/    9E07 : CD 94 9C                            call  add_fpreg_fpaccu ; add constant
    5336/    9E0A : (MACRO)                             POP_FPREG
    5336/    9E0A : C1                                  pop   bc
    5336/    9E0B : DD E1                               pop   ix
    5336/    9E0D : D1                                  pop   de
    5337/    9E0E : 04                                  inc   b                ; convert constant to SQR(2)
    5338/    9E0F :                                                            ; 2*(1/SQR(2)) == SQR(2)
    5339/    9E0F : CD C3 9E                            call  div_fpreg_fpaccu ; divide SQR(2) / argument
    5340/    9E12 : 21 C0 9D                            ld    hl, const1
    5341/    9E15 : CD 88 9C                            call  load_fpreg_and_subtr ; subtract 1.0 - argument
    5342/    9E18 : 21 C6 9D                            ld    hl, LOG_poly_tbl ; load coefficient table
    5343/    9E1B : CD DB A7                            call  fpaccu_polyeval_sqr ; evaluate polynomial
    5344/    9E1E : (MACRO)                             FPREG_CONST 8080h,0,0  ; add -0.5
    5344/    9E1E : 01 80 80                            ld    bc, 8080H
    5344/    9E21 : DD 21 00 00                         ld    ix, 0
    5344/    9E25 : 11 00 00                            ld    de, 0
    5345/    9E28 : CD 94 9C                            call  add_fpreg_fpaccu
    5346/    9E2B : F1                                  pop   af
    5347/    9E2C : CD A1 A1                            call  fpaccu_add_u8    ; adjust exponent
    5348/    9E2F : (MACRO)                             FPREG_CONST 8031h,7217h,0F7D2h ; constant LOG(2)
    5348/    9E2F : 01 31 80                            ld    bc, 8031H
    5348/    9E32 : DD 21 17 72                         ld    ix, 7217H
    5348/    9E36 : 11 D2 F7                            ld    de, 0F7D2H
    5349/    9E39 : 18 04                               jr    multiply_fpreg_fpaccu ; multiply with it
    5350/    9E3B :                     
    5351/    9E3B :                     ; pop fpreg from stack and multiply with fpaccu
    5352/    9E3B :                     pop_fpreg_and_mult:
    5353/    9E3B : (MACRO)                             POP_FPREG              ; pop fpreg from stack
    5353/    9E3B : C1                                  pop   bc
    5353/    9E3C : DD E1                               pop   ix
    5353/    9E3E : D1                                  pop   de
    5354/    9E3F :                     ; multiply fpreg * fpaccu => fpaccu
    5355/    9E3F :                     multiply_fpreg_fpaccu:
    5356/    9E3F : CD BF 9F                            call  fpaccu_sgn       ; get sign of fpaccu
    5357/    9E42 : C8                                  ret   z                ; is zero?, exit (result is zero)
    5358/    9E43 : 2E 00                               ld    l, 0
    5359/    9E45 : CD 63 9F                            call  mult_div_calcexponent ; calculate new exponent
    5360/    9E48 : 79                                  ld    a, c             ; get mantissa6
    5361/    9E49 : D5                                  push  de               ; push mant32 fpreg
    5362/    9E4A : D9                                  exx                    ; alternative registers
    5363/    9E4B : 4F                                  ld    c, a             ; mant6 -> C'
    5364/    9E4C : D1                                  pop   de               ; mant32 -> DE'
    5365/    9E4D : DD E5                               push  ix               ; mant54 -> HL'
    5366/    9E4F : E1                                  pop   hl
    5367/    9E50 : D9                                  exx                    ; back to std set
    5368/    9E51 : 01 00 00                            ld    bc, 0            ; clear BC (mant61)
    5369/    9E54 : 50                                  ld    d, b             ; clear DE (mant32)
    5370/    9E55 : 58                                  ld    e, b
    5371/    9E56 : DD 21 00 00                         ld    ix, 0            ; clear IX (mant54)
    5372/    9E5A : 21 F3 9C                            ld    hl, loc_1FF3     ; call normalize on return
    5373/    9E5D : E5                                  push  hl
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 99 - 8/15/2019 11:33:6


    5374/    9E5E : 21 68 9E                            ld    hl, loc_2168     ; call restore altregs on return
    5375/    9E61 : E5                                  push  hl               ; four times
    5376/    9E62 : E5                                  push  hl               ; will calculate partial
    5377/    9E63 :                                                            ; multiplication for 8 bits
    5378/    9E63 : E5                                  push  hl
    5379/    9E64 : E5                                  push  hl
    5380/    9E65 : 21 66 0C                            ld    hl, fpaccu_mant32 ; get fpaccu
    5381/    9E68 : 7E                  loc_2168:       ld    a, (hl)          ; get factor byte
    5382/    9E69 : 23                                  inc   hl               ; advance
    5383/    9E6A : B7                                  or    a                ; is zero?
    5384/    9E6B : 20 0E                               jr    nz, loc_217B     ; no, must do bitwise partial multiply
    5385/    9E6D : 43                                  ld    b, e             ; shift 8 bits
    5386/    9E6E :                                                            ; mant2 -> mant1
    5387/    9E6E : 5A                                  ld    e, d             ; mant3 -> mant2
    5388/    9E6F : DD 55                               ld    d, ixl            ; mant4 -> mant3
    5389/    9E71 : 08                                  ex    af, af'
    5390/    9E72 : DD 7C                               ld    a, ixh            ; mant5 -> mant4
    5391/    9E74 : DD 6F                               ld    ixl, a
    5392/    9E76 : 08                                  ex    af, af'
    5393/    9E77 : DD 61                               ld    ixh, c            ; mant6 -> mant5
    5394/    9E79 : 4F                                  ld    c, a             ; 0 -> mant6
    5395/    9E7A : C9                                  ret
    5396/    9E7B : E5                  loc_217B:       push  hl               ; save ptr to fpaccu
    5397/    9E7C : EB                                  ex    de, hl           ; mant32 -> HL
    5398/    9E7D : 1E 08                               ld    e, 8             ; cntr for 8 bits
    5399/    9E7F : 1F                  loop217F:       rra                    ;<+ next bit of factor
    5400/    9E80 : 57                                  ld    d, a             ; | save factor
    5401/    9E81 : 79                                  ld    a, c             ; | mant6 -> C
    5402/    9E82 : 30 12                               jr    nc, loc_2196     ; | bit is zero, only shift
    5403/    9E84 : E5                                  push  hl               ; | push mant32
    5404/    9E85 : D9                                  exx                    ; | alternative set
    5405/    9E86 : E3                                  ex    (sp), hl         ; | stack is mant54', HL' is mant32
    5406/    9E87 : 19                                  add   hl, de           ; | DE is mant32'
    5407/    9E88 :                                                            ; | mant32 + mant32' -> HL'
    5408/    9E88 : E3                                  ex    (sp), hl         ; | HL' is mant54', stack is mant32
    5409/    9E89 : EB                                  ex    de, hl           ; | HL' is mant32', DE' is mant54'
    5410/    9E8A : DD E5                               push  ix               ; | push mant54
    5411/    9E8C : E3                                  ex    (sp), hl         ; | stack is mant32', HL' is mant54
    5412/    9E8D : ED 5A                               adc   hl, de           ; | CY + mant54' + mant54 -> HL'
    5413/    9E8F : E3                                  ex    (sp), hl         ; | stack is mant54, HL is mant32'
    5414/    9E90 : DD E1                               pop   ix               ; | restore mant54
    5415/    9E92 : EB                                  ex    de, hl           ; | HL' is mant54', DE is mant32'
    5416/    9E93 : 89                                  adc   a, c             ; | CY + mant6' + mant6 -> A
    5417/    9E94 : D9                                  exx                    ; | std set
    5418/    9E95 : E1                                  pop   hl               ; | restore mant32
    5419/    9E96 : 1F                  loc_2196:       rra                    ; | shift right mant6
    5420/    9E97 : 4F                                  ld    c, a             ; | 
    5421/    9E98 : DD 7C                               ld    a, ixh            ; | shift right mant5
    5422/    9E9A : 1F                                  rra                    ; | 
    5423/    9E9B : DD 67                               ld    ixh, a            ; | 
    5424/    9E9D : DD 7D                               ld    a, ixl            ; | shift right mant4
    5425/    9E9F : 1F                                  rra                    ; | 
    5426/    9EA0 : DD 6F                               ld    ixl, a            ; | 
    5427/    9EA2 : CB 1C                               rr    h                ; | shift right mant3
    5428/    9EA4 : CB 1D                               rr    l                ; | shift right mant2
    5429/    9EA6 : CB 18                               rr    b                ; | shift right mant1
    5430/    9EA8 : 1D                                  dec   e                ; | decrement bit count
    5431/    9EA9 : 7A                                  ld    a, d             ; | restore factor
    5432/    9EAA : 20 D3                               jr    nz, loop217F     ;-+ not yet done? loop
    5433/    9EAC : EB                                  ex    de, hl           ; mant32 -> DE
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 100 - 8/15/2019 11:33:6


    5434/    9EAD : E1                  loc_21AD:       pop   hl               ; restore ptr to fpaccu
    5435/    9EAE : C9                                  ret
    5436/    9EAF :                     
    5437/    9EAF :                     ; divide fpaccu by 10
    5438/    9EAF : CD DA 9F            fpaccu_div10:   call  push_fpaccu      ; push fpaccu
    5439/    9EB2 : (MACRO)                             FPREG_CONST 8420h,0,0  ; constant 10.0
    5439/    9EB2 : 01 20 84                            ld    bc, 8420H
    5439/    9EB5 : DD 21 00 00                         ld    ix, 0
    5439/    9EB9 : 11 00 00                            ld    de, 0
    5440/    9EBC : CD F5 9F                            call  store_fpaccu     ; put in fpaccu
    5441/    9EBF :                     
    5442/    9EBF :                     ; popfpreg from stack anddivide by fpaccu
    5443/    9EBF :                     pop_fpreg_and_div:
    5444/    9EBF : (MACRO)                             POP_FPREG
    5444/    9EBF : C1                                  pop   bc
    5444/    9EC0 : DD E1                               pop   ix
    5444/    9EC2 : D1                                  pop   de
    5445/    9EC3 :                     ; divide fpreg / fpaccu => fpaccu
    5446/    9EC3 :                     div_fpreg_fpaccu:
    5447/    9EC3 : CD BF 9F                            call  fpaccu_sgn       ; check fpaccu is 0?
    5448/    9EC6 : CA 70 81                            jp    z, div_by_zero_error ; yes division by zero error
    5449/    9EC9 : 2E FF                               ld    l, 0FFh          ; for complement of exponent
    5450/    9ECB : CD 63 9F                            call  mult_div_calcexponent ; calculate exponent
    5451/    9ECE : FD E5                               push  iy               ; save IY
    5452/    9ED0 : 34                                  inc   (hl)             ; adjust exponent (2's complement)
    5453/    9ED1 : 34                                  inc   (hl)
    5454/    9ED2 : 2B                                  dec   hl
    5455/    9ED3 : E5                                  push  hl               ; ptr to fpaccu mant6
    5456/    9ED4 : D9                                  exx                    ; alt set
    5457/    9ED5 : E1                                  pop   hl               ; get ptr
    5458/    9ED6 : 4E                                  ld    c, (hl)          ; mant6' -> C'
    5459/    9ED7 : 2B                                  dec   hl
    5460/    9ED8 : 56                                  ld    d, (hl)          ; mant54' -> DE'
    5461/    9ED9 : 2B                                  dec   hl
    5462/    9EDA : 5E                                  ld    e, (hl)
    5463/    9EDB : 2B                                  dec   hl
    5464/    9EDC : 7E                                  ld    a, (hl)          ; mant32' -> HL'
    5465/    9EDD : 2B                                  dec   hl
    5466/    9EDE : 6E                                  ld    l, (hl)
    5467/    9EDF : 67                                  ld    h, a
    5468/    9EE0 : EB                                  ex    de, hl           ; mant54' -> HL'
    5469/    9EE1 :                                                            ; mant32' -> DE'
    5470/    9EE1 : D9                                  exx                    ; std set
    5471/    9EE2 : 41                                  ld    b, c             ; mant6 -> B
    5472/    9EE3 : EB                                  ex    de, hl           ; mant32 -> HL
    5473/    9EE4 : DD E5                               push  ix               ; mant54 -> IY
    5474/    9EE6 : FD E1                               pop   iy
    5475/    9EE8 : AF                                  xor    a               ; extent registers
    5476/    9EE9 : 4F                                  ld    c, a
    5477/    9EEA : 57                                  ld    d, a
    5478/    9EEB : 5F                                  ld    e, a
    5479/    9EEC : DD 21 00 00                         ld    ix, 0
    5480/    9EF0 : 32 AE 0C                            ld    (div_ovf), a
    5481/    9EF3 : E5                  loop21F3:       push  hl               ;<+ push mant6...mant2
    5482/    9EF4 : FD E5                               push  iy               ; | 
    5483/    9EF6 : C5                                  push  bc               ; | 
    5484/    9EF7 : E5                                  push  hl               ; | push mant32
    5485/    9EF8 : 78                                  ld    a, b             ; | mant6 -> A
    5486/    9EF9 : D9                                  exx                    ; | alt set
    5487/    9EFA : E3                                  ex    (sp), hl         ; | stack is mant54', HL' is mant32
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 101 - 8/15/2019 11:33:6


    5488/    9EFB : B7                                  or    a                ; | set CY
    5489/    9EFC : ED 52                               sbc   hl, de           ; | mant32 - mant32' -> HL'
    5490/    9EFE : E3                                  ex    (sp), hl         ; | stack is mant32, HL' is mant54'
    5491/    9EFF : EB                                  ex    de, hl           ; | DE' is mant54', HL' is mant32'
    5492/    9F00 : FD E5                               push  iy               ; | push mant54
    5493/    9F02 : E3                                  ex    (sp), hl         ; | stack is mant32', HL' is mant54
    5494/    9F03 : ED 52                               sbc   hl, de           ; | mant54 - mant54' -> HL'
    5495/    9F05 : E3                                  ex    (sp), hl         ; | stack is mant54, HL' is mant32'
    5496/    9F06 : FD E1                               pop   iy               ; | restore mant54
    5497/    9F08 : EB                                  ex    de, hl           ; | DE' is mant32', HL' is mant54'
    5498/    9F09 : 99                                  sbc   a, c             ; | C' is mant6
    5499/    9F0A :                                                            ; | mant6 - mant6' -> A
    5500/    9F0A : D9                                  exx                    ; | std set
    5501/    9F0B : E1                                  pop   hl               ; | restore mant32
    5502/    9F0C : 47                                  ld    b, a             ; | store mant6
    5503/    9F0D : 3A AE 0C                            ld    a, (div_ovf)     ; | get overflow?
    5504/    9F10 : DE 00                               sbc   a, 0             ; | subtract remainying CY
    5505/    9F12 : 3F                                  ccf                    ; | complement it
    5506/    9F13 : 30 09                               jr    nc, loc_221E     ; | this failed, undo subtract
    5507/    9F15 : 32 AE 0C                            ld    (div_ovf), a     ; | store overflow
    5508/    9F18 : F1                                  pop   af               ; | discard mant6...2
    5509/    9F19 : F1                                  pop   af               ; | 
    5510/    9F1A : F1                                  pop   af               ; | 
    5511/    9F1B : 37                                  scf                    ; | set CY
    5512/    9F1C : 18 04                               jr    loc_2222         ; | skip
    5513/    9F1E : C1                  loc_221E:       pop   bc               ; | restore old mantissa
    5514/    9F1F : FD E1                               pop   iy               ; | 
    5515/    9F21 : E1                                  pop   hl               ; | CY is 0, coming from here
    5516/    9F22 : 0C                  loc_2222:       inc   c                ; | get sign of mant6
    5517/    9F23 : 0D                                  dec   c                ; | 
    5518/    9F24 : 1F                                  rra                    ; | set CY into bit7
    5519/    9F25 : FA 5E 9F                            jp    m, loc_225E      ; | are we done?, yes, skip
    5520/    9F28 : 17                                  rla                    ; | shift in the CY bit
    5521/    9F29 : CB 13                               rl    e                ; | shift mant32 left
    5522/    9F2B : CB 12                               rl    d                ; | 
    5523/    9F2D : 08                                  ex    af, af'          ; | save flags
    5524/    9F2E : DD 29                               add   ix, ix           ; | shift mant54 left
    5525/    9F30 : 08                                  ex    af, af'          ; | save flags
    5526/    9F31 : 30 02                               jr    nc, loc_2235     ; | adjust for CY in
    5527/    9F33 : DD 23                               inc   ix               ; | 
    5528/    9F35 : 08                  loc_2235:       ex    af, af'          ; | save flags
    5529/    9F36 : CB 11                               rl    c                ; | shift left mant6
    5530/    9F38 : 29                                  add   hl, hl           ; | shift left extent HL
    5531/    9F39 : 08                                  ex    af, af'          ; | 
    5532/    9F3A : FD 29                               add   iy, iy           ; | shift left extent IY
    5533/    9F3C : 08                                  ex    af, af'          ; | restore flags
    5534/    9F3D : 30 02                               jr    nc, loc_2241     ; | adjust for CY
    5535/    9F3F : FD 23                               inc   iy               ; | 
    5536/    9F41 : 08                  loc_2241:       ex    af, af'          ; | 
    5537/    9F42 : CB 10                               rl    b                ; | shift left B
    5538/    9F44 : 3A AE 0C                            ld    a, (div_ovf)     ; | shift left extent
    5539/    9F47 : 17                                  rla                    ; |
    5540/    9F48 : 32 AE 0C                            ld    (div_ovf), a     ; |
    5541/    9F4B : 79                                  ld    a, c             ; | still bits left to shift?
    5542/    9F4C : B2                                  or    d                ; | 
    5543/    9F4D : B3                                  or    e                ; | 
    5544/    9F4E : DD B4                               or    ixh               ; | 
    5545/    9F50 : DD B5                               or    ixl               ; | 
    5546/    9F52 : 20 9F                               jr    nz, loop21F3     ;-+ yes, loop
    5547/    9F54 : E5                                  push  hl               ; save HL
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 102 - 8/15/2019 11:33:6


    5548/    9F55 : 21 6B 0C                            ld    hl, fpaccu_exp   ; get exponent
    5549/    9F58 : 35                                  dec   (hl)             ; decrement (left shift == exp-1)
    5550/    9F59 : E1                                  pop   hl               ; restore HL
    5551/    9F5A : 20 97                               jr    nz, loop21F3     ; not zero?
    5552/    9F5C : 18 2D                               jr    e_overflow1      ; exponent overflow
    5553/    9F5E : FD E1               loc_225E:       pop   iy               ; restore IY
    5554/    9F60 : C3 34 9D                            jp    loc_2034         ; round and store result
    5555/    9F63 :                     
    5556/    9F63 :                     mult_div_calcexponent:
    5557/    9F63 : 78                                  ld    a, b             ; get fpreg exponent
    5558/    9F64 : B7                                  or    a
    5559/    9F65 : 28 20                               jr    z, loc_2287      ; is zero? yes, result is zero
    5560/    9F67 : 7D                                  ld    a, l             ; multiply: l=0, divide: l=ff
    5561/    9F68 : 21 6B 0C                            ld    hl, fpaccu_exp   ; get exponent
    5562/    9F6B : AE                                  xor    (hl)            ; do 1's complement for division
    5563/    9F6C : 80                                  add   a, b             ; add exponents
    5564/    9F6D : 47                                  ld    b, a             ; resulting exponent in fpreg
    5565/    9F6E : 1F                                  rra                    ; test overflow (bit 6 shift into bit 7)
    5566/    9F6F : A8                                  xor    b               ; check overflow
    5567/    9F70 : 78                                  ld    a, b             ; get resulting exponent
    5568/    9F71 : F2 86 9F                            jp    p, loc_2286      ; if positive, skip
    5569/    9F74 : C6 80                               add   a, 80h           ; adjust exponent again
    5570/    9F76 : 77                                  ld    (hl), a          ; store as new exponent in fpaccu
    5571/    9F77 : CA AD 9E                            jp    z, loc_21AD      ; exponent is 0, exit
    5572/    9F7A : CD 21 A0                            call  fpaccu_restoresign ; restore sign of mantissa
    5573/    9F7D : 77                                  ld    (hl), a          ; store sign
    5574/    9F7E : 2B                                  dec   hl
    5575/    9F7F : C9                                  ret
    5576/    9F80 : CD BF 9F            loc_2280:       call  fpaccu_sgn       ; get sign of fpaccu
    5577/    9F83 : 2F                                  cpl                    ; complement
    5578/    9F84 : B7                                  or    a                ; set flags (redundant, because CPL
    5579/    9F85 :                                                            ; already sets sign)
    5580/    9F85 : 21                                  db    21h              ; LD HL, xxxx to skip next 2 instructions
    5581/    9F86 : B7                  loc_2286:       or    a                ;** set flags
    5582/    9F87 : E1                  loc_2287:       pop   hl               ;** discard caller
    5583/    9F88 : F2 0E 9D                            jp    p, fpaccu_zero   ; if positive, return zero
    5584/    9F8B : C3 55 9D            e_overflow1:    jp    e_overflow       ; overflow error
    5585/    9F8E :                     
    5586/    9F8E : CD 02 A0            fpaccu_mult10:  call  fpaccu_to_fpreg  ; copy fpaccu into registers
    5587/    9F91 : 78                                  ld     a, b            ; get exponent
    5588/    9F92 : B7                                  or    a
    5589/    9F93 : C8                                  ret   z                ; is zero? yes exit
    5590/    9F94 : C6 02                               add   a, 2             ; multiply fpreg with 4
    5591/    9F96 : 38 F3                               jr    c, e_overflow1   ; check for overflow
    5592/    9F98 : 47                                  ld    b, a             ; store fpreg exponent
    5593/    9F99 : CD 94 9C                            call  add_fpreg_fpaccu ; add 4*X + X -> 5*X
    5594/    9F9C : 21 6B 0C                            ld    hl, fpaccu_exp   ; get fpaccu exponent
    5595/    9F9F : 34                                  inc   (hl)             ; multiply with 2
    5596/    9FA0 : C0                                  ret   nz               ; not zero? okay
    5597/    9FA1 : 18 E8                               jr    e_overflow1      ; overflow error
    5598/    9FA3 :                     
    5599/    9FA3 :                     ; process SGN()
    5600/    9FA3 : CD BF 9F            math_sgn:       call  fpaccu_sgn       ; get sign of FPACCU in    A
    5601/    9FA6 :                     
    5602/    9FA6 :                     ; convert signed byte in A into fpaccu
    5603/    9FA6 : 06 88               s8_to_fp:       ld    b, 88h           ; preload exponent with 8
    5604/    9FA8 : 11 00 00                            ld    de, 0            ; low mantissa = 0
    5605/    9FAB :                     
    5606/    9FAB :                     ; entry point used to also convert signed 16 bit
    5607/    9FAB :                     ; and unsigned 16 bit numbers in A,D,E
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 103 - 8/15/2019 11:33:6


    5608/    9FAB : 21 6B 0C            s24_to_fp:      ld    hl, fpaccu_exp   ; address of FPaccu
    5609/    9FAE : 4F                                  ld    c, a             ; put sign into C
    5610/    9FAF : D5                                  push  de               ; put upper mantissa in IX
    5611/    9FB0 : DD E1                               pop   ix
    5612/    9FB2 : 11 00 00                            ld    de, 0            ; lower mantissa = 0
    5613/    9FB5 : 70                                  ld    (hl), b          ; store exponent
    5614/    9FB6 : 06 00                               ld    b, 0             ; clear B
    5615/    9FB8 : 23                                  inc   hl
    5616/    9FB9 : 36 80                               ld    (hl), 80h
    5617/    9FBB : 17                                  rla
    5618/    9FBC : C3 F0 9C                            jp    fpreg_normalize
    5619/    9FBF :                     
    5620/    9FBF :                     ; return SGN(fpaccu) in A (ff,0,1)
    5621/    9FBF : 3A 6B 0C            fpaccu_sgn:     ld    a, (fpaccu_exp)  ; is exponent 0?
    5622/    9FC2 : B7                                  or    a
    5623/    9FC3 : C8                                  ret   z                ; yes, return A = 0
    5624/    9FC4 : 3A 6A 0C                            ld    a, (fpaccu_mant6) ; get highest mantissa
    5625/    9FC7 : FE                                  db    0FEh             ; CP xx to skip following instruction
    5626/    9FC8 : 2F                  loc_22C8:       cpl                    ;** skipped
    5627/    9FC9 : 17                                  rla                    ; sign of mantissa into CY
    5628/    9FCA : 9F                  loc_22CA:       sbc   a, a             ; A = FF if negative
    5629/    9FCB : C0                                  ret   nz               ;  exit
    5630/    9FCC : 3C                                  inc   a                ; A = 1, if positive
    5631/    9FCD : C9                                  ret
    5632/    9FCE :                     
    5633/    9FCE :                     ; process ABS()
    5634/    9FCE : CD BF 9F            math_abs:       call  fpaccu_sgn       ; get sign of fpaccu
    5635/    9FD1 : F0                                  ret   p                ; is already positive? yes exit
    5636/    9FD2 :                     
    5637/    9FD2 :                     ; toggle sign in fpaccu
    5638/    9FD2 :                     fpaccu_changesign:
    5639/    9FD2 : 21 6A 0C                            ld    hl, fpaccu_mant6 ; get sign bit of mantissa
    5640/    9FD5 : 7E                                  ld    a, (hl)
    5641/    9FD6 : EE 80                               xor    80h             ; complement
    5642/    9FD8 : 77                                  ld    (hl), a
    5643/    9FD9 : C9                                  ret
    5644/    9FDA :                     
    5645/    9FDA :                     ; push fpaccu on stack
    5646/    9FDA : EB                  push_fpaccu:    ex    de, hl           ; save old HL
    5647/    9FDB :                     
    5648/    9FDB :                     ; push fpaccu on stack, exchange DE,HL
    5649/    9FDB : 2A 66 0C            push_fpaccu_ex: ld    hl, (fpaccu_mant32)
    5650/    9FDE : E3                                  ex    (sp), hl
    5651/    9FDF : E5                                  push  hl
    5652/    9FE0 : 2A 68 0C                            ld    hl, (fpaccu_mant54)
    5653/    9FE3 : E3                                  ex    (sp), hl
    5654/    9FE4 : E5                                  push  hl
    5655/    9FE5 : 2A 6A 0C                            ld    hl, (fpaccu_mant6)
    5656/    9FE8 : E3                                  ex    (sp), hl
    5657/    9FE9 : E5                                  push  hl
    5658/    9FEA : EB                                  ex    de, hl        ; restore old HL
    5659/    9FEB : C9                                  ret
    5660/    9FEC :                     
    5661/    9FEC :                     ; copy value in memory at HL into fpaccu
    5662/    9FEC : 11 66 0C            mem_to_fpaccu:  ld    de, fpaccu_mant32
    5663/    9FEF : 01 06 00                            ld    bc, 6
    5664/    9FF2 : ED B0                               ldir
    5665/    9FF4 : C9                                  ret
    5666/    9FF5 :                     
    5667/    9FF5 : ED 53 66 0C         store_fpaccu:   ld    (fpaccu_mant32), de
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 104 - 8/15/2019 11:33:6


    5668/    9FF9 : DD 22 68 0C                         ld    (fpaccu_mant54), ix
    5669/    9FFD : ED 43 6A 0C                         ld    (fpaccu_mant6), bc
    5670/    A001 : C9                                  ret
    5671/    A002 :                     
    5672/    A002 :                     fpaccu_to_fpreg:
    5673/    A002 : 21 66 0C                            ld    hl, fpaccu_mant32 ; get mantissa32
    5674/    A005 : (MACRO)             load_fpreg:     LDDE_M                 ; load mant32 into DE
    5674/    A005 : 5E                                  ld    e, (hl)
    5674/    A006 : 23                                  inc   hl
    5674/    A007 : 56                                  ld    d, (hl)
    5675/    A008 : 23                                  inc   hl
    5676/    A009 : 4E                                  ld    c, (hl)          ; load mant4 into IXL
    5677/    A00A : DD 69                               ld    ixl, c
    5678/    A00C : 23                                  inc   hl
    5679/    A00D : 4E                                  ld    c, (hl)          ; load mant5 into IXH
    5680/    A00E : DD 61                               ld    ixh, c
    5681/    A010 : 23                                  inc   hl
    5682/    A011 : (MACRO)                             LDBC_M                 ; load mant6 into C
    5682/    A011 : 4E                                  ld    c, (hl)
    5682/    A012 : 23                                  inc   hl
    5682/    A013 : 46                                  ld    b, (hl)
    5683/    A014 :                                                            ; load exp into B
    5684/    A014 : 23                                  inc   hl
    5685/    A015 : C9                                  ret
    5686/    A016 :                     
    5687/    A016 :                     ; store fpaccu into memory, pointed to by HL
    5688/    A016 : 11 66 0C            fpaccu_to_mem:  ld    de, fpaccu_mant32
    5689/    A019 :                     
    5690/    A019 :                     ; move 6 byte value at addr in DE to  addr in HL
    5691/    A019 : 01 06 00            move_to_var:    ld    bc, 6
    5692/    A01C : EB                                  ex    de, hl
    5693/    A01D : ED B0                               ldir
    5694/    A01F : EB                                  ex    de, hl
    5695/    A020 : C9                                  ret
    5696/    A021 :                     
    5697/    A021 :                     ; restore sign of mantissa, return sign    in A
    5698/    A021 :                     fpaccu_restoresign:
    5699/    A021 : 21 6A 0C                            ld    hl, fpaccu_mant6 ; get mantissa with suppressed leading 1
    5700/    A024 : 7E                                  ld    a, (hl)          ; A = S6543210
    5701/    A025 : 07                                  rlca                   ; A = 6543210S, CY=S
    5702/    A026 : 37                                  scf                    ; CY=H
    5703/    A027 : 1F                                  rra                    ; A = H6543210, CY=S
    5704/    A028 : 77                                  ld    (hl), a          ; store correct mantissa in fpaccu_mant6
    5705/    A029 : 3F                                  ccf                    ; CY=-S
    5706/    A02A : 1F                                  rra                    ; A = -S7654321, CY=0
    5707/    A02B : 23                                  inc   hl
    5708/    A02C : 23                                  inc   hl               ; point to separate sign bit
    5709/    A02D : 77                                  ld    (hl), a          ; save A=-S6543210
    5710/    A02E : 79                                  ld    a, c             ; A=S6543210
    5711/    A02F : 07                                  rlca                   ; A = 6543210S, CY=S
    5712/    A030 : 37                                  scf                    ; CY=H
    5713/    A031 : 1F                                  rra                    ; A = H6543210, CY=S
    5714/    A032 : 4F                                  ld    c, a             ; store correct mant6 in C
    5715/    A033 : 1F                                  rra                    ; A = SH654321, CY=0
    5716/    A034 : AE                                  xor   (hl)             ; A = Sxxxxxxx
    5717/    A035 : C9                                  ret
    5718/    A036 :                     
    5719/    A036 :                     ; compare a number in fpaccu with B,C,IXH,IXL,D,E
    5720/    A036 :                     ; return ff,0,1  n A
    5721/    A036 : 78                  fpaccu_compare: ld    a, b             ; get exponent of number in regs
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 105 - 8/15/2019 11:33:6


    5722/    A037 : B7                                  or    a
    5723/    A038 : 28 85                               jr    z, fpaccu_sgn    ; if zero, return zero in A
    5724/    A03A : CD BF 9F                            call  fpaccu_sgn       ; set sign of fpaccu in Z
    5725/    A03D : 79                                  ld    a, c             ; get high mantissa
    5726/    A03E : 28 88                               jr    z, loc_22C8      ; if zero, go complement
    5727/    A040 : 21 6A 0C                            ld    hl, fpaccu_mant6 ; get fpaccu mantissa
    5728/    A043 : AE                                  xor   (hl)             ; complement with number in regs
    5729/    A044 : 79                                  ld    a, c             ; get high mantissa again
    5730/    A045 : FA C8 9F                            jp    m, loc_22C8      ; return result sign
    5731/    A048 : CD 50 A0                            call  fp_compare1      ; compare fpaccu
    5732/    A04B : 1F                                  rra                    ; build correct compare sign
    5733/    A04C : A9                                  xor   c
    5734/    A04D : C3 C8 9F                            jp    loc_22C8         ; exit compare status
    5735/    A050 :                     
    5736/    A050 : 23                  fp_compare1:    inc   hl               ; point to fpexp
    5737/    A051 : 78                                  ld    a, b             ; get exponent
    5738/    A052 : BE                                  cp    (hl)             ; compare exponents
    5739/    A053 : C0                                  ret   nz               ; exit if not same
    5740/    A054 : 2B                                  dec   hl               ; point to mant6
    5741/    A055 : 79                                  ld    a, c             ; compare mantissa
    5742/    A056 : BE                                  cp    (hl)
    5743/    A057 : C0                                  ret   nz               ; exit not same
    5744/    A058 : 2B                                  dec   hl               ; compare mant5
    5745/    A059 : DD 7C                               ld    a, ixh
    5746/    A05B : BE                                  cp    (hl)
    5747/    A05C : C0                                  ret   nz               ; exit not same
    5748/    A05D : 2B                                  dec   hl               ; compare mant4
    5749/    A05E : DD 7D                               ld    a, ixl
    5750/    A060 : BE                                  cp    (hl)
    5751/    A061 : C0                                  ret   nz               ; exit not same
    5752/    A062 : 2B                                  dec   hl
    5753/    A063 : 7A                                  ld    a, d
    5754/    A064 : BE                                  cp    (hl)             ; compare mant3
    5755/    A065 : C0                                  ret   nz               ; exit not same
    5756/    A066 : 2B                                  dec   hl
    5757/    A067 : 7B                                  ld    a, e
    5758/    A068 : 96                                  sub   (hl)             ; compare mant2
    5759/    A069 : C0                                  ret   nz               ; exit not same
    5760/    A06A : E1                                  pop   hl               ; leave subroutine level of fpaccu_compare
    5761/    A06B :                                                            ; directly
    5762/    A06B : C9                                  ret                    ; return to fpaccu_compare
    5763/    A06C :                     
    5764/    A06C :                     ; load next 4 bytes at HL into DE,BC
    5765/    A06C : (MACRO)             restore_de_bc:  LDDE_M                 ; load 4 bytes into DE, BC
    5765/    A06C : 5E                                  ld    e, (hl)
    5765/    A06D : 23                                  inc   hl
    5765/    A06E : 56                                  ld    d, (hl)
    5766/    A06F : 23                                  inc   hl
    5767/    A070 : (MACRO)                             LDBC_M
    5767/    A070 : 4E                                  ld    c, (hl)
    5767/    A071 : 23                                  inc   hl
    5767/    A072 : 46                                  ld    b, (hl)
    5768/    A073 : 23                                  inc   hl
    5769/    A074 : C9                                  ret
    5770/    A075 :                     
    5771/    A075 : 47                  fpreg_fix:      ld    b, a             ; store A into FPreg
    5772/    A076 : 4F                                  ld    c, a
    5773/    A077 : 57                                  ld    d, a
    5774/    A078 : 5F                                  ld    e, a
    5775/    A079 : DD 67                               ld    ixh, a
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 106 - 8/15/2019 11:33:6


    5776/    A07B : DD 6F                               ld    ixl, a
    5777/    A07D : B7                                  or    a                ; was it zero?, yes, exit
    5778/    A07E : C8                                  ret   z
    5779/    A07F : E5                                  push  hl               ; save HL
    5780/    A080 : CD 02 A0                            call  fpaccu_to_fpreg  ; load current fpaccu
    5781/    A083 : CD 21 A0                            call  fpaccu_restoresign
    5782/    A086 : AE                                  xor    (hl)            ; complement sign
    5783/    A087 : 67                                  ld    h, a             ; save in H
    5784/    A088 : F2 9B A0                            jp    p, loc_239B      ; positive? skip, else decrement for
    5785/    A08B :                                                            ; 2's complement
    5786/    A08B : 1B                                  dec   de               ; decrement mantissa
    5787/    A08C : 7A                                  ld    a, d             ; is borrow?
    5788/    A08D : A3                                  and   e
    5789/    A08E : 3C                                  inc   a
    5790/    A08F : 20 0A                               jr    nz, loc_239B     ; no skip
    5791/    A091 : DD 2B                               dec   ix               ; decrement next part of mantissa
    5792/    A093 : DD 7C                               ld    a, ixh
    5793/    A095 : DD A5                               and   ixl               ; more borrow?
    5794/    A097 : 3C                                  inc   a
    5795/    A098 : 20 01                               jr    nz, loc_239B
    5796/    A09A : 0D                                  dec   c                ; decrement highest mantissa part
    5797/    A09B : 3E A8               loc_239B:       ld    a, 0A8h          ; exponent for overflow
    5798/    A09D : 90                                  sub   b
    5799/    A09E : CD 8F 9D                            call  fpreg_shiftmant  ; do 8 bit shifts
    5800/    A0A1 : 7C                                  ld    a, h             ; restore mantissa sign
    5801/    A0A2 : 17                                  rla                    ; move into CY
    5802/    A0A3 : DC 45 9D                            call  c, mant_inc_r    ; increment for 2s complement
    5803/    A0A6 : 06 00                               ld    b, 0             ; mant1
    5804/    A0A8 : DC 72 9D                            call  c, fpreg_complement ; complement mantissa
    5805/    A0AB : E1                                  pop   hl               ; restore HL
    5806/    A0AC : C9                                  ret
    5807/    A0AD :                     
    5808/    A0AD :                     ; process INT()
    5809/    A0AD : 21 6B 0C            math_int:       ld    hl, fpaccu_exp   ; load exponent
    5810/    A0B0 : 7E                                  ld    a, (hl)
    5811/    A0B1 : FE A8                               cp    0A8h             ; exponent more than 2^40?
    5812/    A0B3 :                                                            ; no fractional bits available
    5813/    A0B3 : 3A 66 0C                            ld    a, (fpaccu_mant32)
    5814/    A0B6 : D0                                  ret   nc               ; exit
    5815/    A0B7 : 7E                                  ld    a, (hl)          ; clip fractional bits
    5816/    A0B8 : CD 75 A0                            call  fpreg_fix
    5817/    A0BB : 36 A8                               ld    (hl), 0A8h
    5818/    A0BD : 7B                                  ld    a, e
    5819/    A0BE : F5                                  push  af
    5820/    A0BF : 79                                  ld    a, c
    5821/    A0C0 : 17                                  rla
    5822/    A0C1 : CD F0 9C                            call  fpreg_normalize  ; normalize number again
    5823/    A0C4 : F1                                  pop   af
    5824/    A0C5 : C9                                  ret
    5825/    A0C6 :                     
    5826/    A0C6 :                     ; HL = BC * DE
    5827/    A0C6 : 21 00 00            umultiply16:    ld    hl, 0            ; clear HL
    5828/    A0C9 : 78                                  ld    a, b             ; is index 0?
    5829/    A0CA : B1                                  or    c
    5830/    A0CB : C8                                  ret   z                ; return
    5831/    A0CC : 3E 11                               ld    a, 11h           ; 17 rounds
    5832/    A0CE : 3D                  loop23CE:       dec   a                ;<+
    5833/    A0CF : C8                                  ret   z                ; | 
    5834/    A0D0 : 29                                  add   hl, hl           ; | HL * 2
    5835/    A0D1 : 38 08                               jr    c, loc_23DB      ; | overflow?, error
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 107 - 8/15/2019 11:33:6


    5836/    A0D3 : EB                                  ex    de, hl           ; | get sizeof element
    5837/    A0D4 : 29                                  add   hl, hl           ; | DE * 2
    5838/    A0D5 : EB                                  ex    de, hl           ; | 
    5839/    A0D6 : 30 F6                               jr    nc, loop23CE     ;>+ overflow?
    5840/    A0D8 : 09                                  add   hl, bc           ; | add index
    5841/    A0D9 : 30 F3                               jr    nc, loop23CE     ;-+
    5842/    A0DB : C3 6B 8E            loc_23DB:       jp    subscript_range_error
    5843/    A0DE :                     
    5844/    A0DE :                     ; HL=buf, read a 16 bit number
    5845/    A0DE :                     ; A= current char read
    5846/    A0DE :                     ; returns packed number    in fpaccu
    5847/    A0DE :                     parse_number_fpaccu:
    5848/    A0DE : FE 26                               cp    CHAR_AMP         ; potentially a hex number?
    5849/    A0E0 : CA 71 A1                            jp    z, expr_hex
    5850/    A0E3 : FE 2D               expr_numeric:   cp    CHAR_MINUS       ; negative sign?
    5851/    A0E5 : F5                                  push  af               ; save it
    5852/    A0E6 : 28 05                               jr    z, loc_23ED      ; skip
    5853/    A0E8 : FE 2B                               cp    CHAR_PLUS        ; positive sign?
    5854/    A0EA : 28 01                               jr    z, loc_23ED      ; yes
    5855/    A0EC : 2B                                  dec   hl               ; go back to current char, should be a digit
    5856/    A0ED : CD 0E 9D            loc_23ED:       call  fpaccu_zero      ; A = 0
    5857/    A0F0 : 47                                  ld    b, a             ; B = 0
    5858/    A0F1 : 57                                  ld    d, a             ; D = 0
    5859/    A0F2 : 5F                                  ld    e, a             ; E = 0
    5860/    A0F3 : 2F                                  cpl
    5861/    A0F4 : 4F                                  ld    c, a             ; C = FF
    5862/    A0F5 : CD 47 86            loop23F5:       call  nextchar         ;<+ get next from buf
    5863/    A0F8 : 38 56                               jr    c, do_mantissapart ; is number? process
    5864/    A0FA : FE 2E                               cp    CHAR_PERIOD      ; | is a period?
    5865/    A0FC : 28 26                               jr    z, do_period     ; | yes, process period
    5866/    A0FE : FE 45                               cp    'E'              ; | is exponent?
    5867/    A100 : 20 25                               jr    nz, number_done  ; | no skip
    5868/    A102 : CD 47 86                            call  nextchar         ; | get next char
    5869/    A105 : 15                                  dec   d                ; | D = exponent sign
    5870/    A106 : FE A6                               cp    TOKEN_MINUS      ; | is '-' as token?
    5871/    A108 : 28 0E                               jr    z, do_exponent   ; | yes, advance
    5872/    A10A : FE 2D                               cp    CHAR_MINUS       ; | is '-' as ASCII?
    5873/    A10C : 28 0A                               jr    z, do_exponent   ; | yes advance
    5874/    A10E : 14                                  inc   d                ; | positive exponent sign
    5875/    A10F : FE 2B                               cp    CHAR_PLUS        ; | is positive?
    5876/    A111 : 28 05                               jr    z, do_exponent   ; | yes advance
    5877/    A113 : FE A5                               cp    TOKEN_PLUS       ; | '+' sign as token?
    5878/    A115 : 28 01                               jr    z, do_exponent   ; | yes, advance
    5879/    A117 : 2B                                  dec   hl               ; | no sign found, reread this char
    5880/    A118 :                     ; process exponent                       | 
    5881/    A118 : CD 47 86            do_exponent:    call  nextchar         ; | get char of exponent
    5882/    A11B : 38 49                               jr    c, add_expdigit  ; | is number?, process
    5883/    A11D : 14                                  inc   d                ; | exponent sign: was negative?
    5884/    A11E : 20 07                               jr    nz, number_done  ; | no, done with number
    5885/    A120 : AF                                  xor    a               ; | complement exponent
    5886/    A121 : 93                                  sub   e                ; | 
    5887/    A122 : 5F                                  ld    e, a             ; | E = exponent
    5888/    A123 : 0C                                  inc   c                ; | disable processing part after decimal point
    5889/    A124 :                     ; process mantissa after decimal point   |
    5890/    A124 :                     ; now count each fractional digit (C = 0) in B
    5891/    A124 :                     ; this is the decrement    value for exponent
    5892/    A124 : 0C                  do_period:      inc   c                ; | was there already a decimal point?
    5893/    A125 : 28 CE                               jr    z, loop23F5      ;>+ no, loop to read more digits
    5894/    A127 :                     ; has complete number                  ; |
    5895/    A127 : E5                  number_done:    push  hl               ; | save curlineptr
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 108 - 8/15/2019 11:33:6


    5896/    A128 : 7B                                  ld    a, e             ; | get exponent
    5897/    A129 : 90                                  sub   b                ; | subtract fractional digits
    5898/    A12A : F2 39 A1                            jp    p, loc_2439      ; | positive? skip
    5899/    A12D : CD DA 9F                            call  push_fpaccu      ; | push fpaccu
    5900/    A130 : ED 44                               neg                    ; | make positive
    5901/    A132 : 21 C0 9D                            ld    hl, const1       ; | load constant 1 into fpaccu
    5902/    A135 : CD EC 9F                            call  mem_to_fpaccu    ; | 
    5903/    A138 : 37                                  scf                    ; | set CY
    5904/    A139 : F5                  loc_2439:       push  af               ; | save CY and exponent
    5905/    A13A : CD AE A1            loop243A:       call  mult10_and_dec   ;<|-+ multiply by 10 and decrement exponent cntr
    5906/    A13D : 20 FB                               jr    nz, loop243A     ;---+ loop until count is zero
    5907/    A13F : F1                                  pop   af               ; | restore C flag (negative)
    5908/    A140 : 30 07                               jr    nc, loc_2449     ; | was positive
    5909/    A142 : (MACRO)                             POP_FPREG              ; | pop FPaccu
    5909/    A142 : C1                                  pop   bc
    5909/    A143 : DD E1                               pop   ix
    5909/    A145 : D1                                  pop   de
    5910/    A146 : CD C3 9E                            call  div_fpreg_fpaccu ; | divide (10*exponent) / mantissa
    5911/    A149 : D1                  loc_2449:       pop   de               ; | restore registers
    5912/    A14A : F1                                  pop   af               ; | restore sign of mantissa
    5913/    A14B : CC D2 9F                            call  z, fpaccu_changesign ; change sign if negative
    5914/    A14E : EB                                  ex    de, hl           ; | restore curlineptr
    5915/    A14F : C9                                  ret                    ; | exit
    5916/    A150 :                     ; process mantissa before decimal point  | 
    5917/    A150 :                     do_mantissapart:                       ; | 
    5918/    A150 : D5                                  push  de               ; | save DE
    5919/    A151 : 57                                  ld    d, a             ; | put char in D
    5920/    A152 : 78                                  ld    a, b             ; | add C to B
    5921/    A153 : 89                                  adc   a, c             ; | CY is set
    5922/    A154 :                                                            ; | will add 0 to B for each  digit
    5923/    A154 :                                                            ; | before decimal point, and add 1 for each
    5924/    A154 :                                                            ; | in fractional part
    5925/    A154 : 47                                  ld    b, a             ; | 
    5926/    A155 : C5                                  push  bc               ; | save registers
    5927/    A156 : E5                                  push  hl               ; | 
    5928/    A157 : D5                                  push  de               ; | save character in D
    5929/    A158 : CD 8E 9F                            call  fpaccu_mult10    ; | 
    5930/    A15B : F1                                  pop   af               ; | restore character in A
    5931/    A15C : D6 30                               sub   CHAR_ZERO        ; | convert to digit 0-9
    5932/    A15E : CD A1 A1                            call  fpaccu_add_u8    ; | add the digit
    5933/    A161 : E1                                  pop   hl               ; | restore registers
    5934/    A162 : C1                                  pop   bc               ; | 
    5935/    A163 : D1                                  pop   de               ; | restore DE
    5936/    A164 : 18 8F                               jr    loop23F5         ;-+ loop next digit
    5937/    A166 :                     ; process exponent digit
    5938/    A166 :                     add_expdigit:                          ; get exponent
    5939/    A166 : 7B                                  ld    a, e
    5940/    A167 : 87                                  add   a, a             ; multiply with 10
    5941/    A168 : 87                                  add   a, a
    5942/    A169 : 83                                  add   a, e
    5943/    A16A : 87                                  add   a, a
    5944/    A16B : 86                                  add   a, (hl)          ; addexponent digit
    5945/    A16C : D6 30                               sub   CHAR_ZERO        ; convert to digit
    5946/    A16E : 5F                                  ld    e, a             ; store exponent
    5947/    A16F : 18 A7                               jr    do_exponent      ; loop
    5948/    A171 :                     
    5949/    A171 : 11 00 00            expr_hex:       ld    de, 0            ; initialize number buf
    5950/    A174 : CD 47 86            loop2474:       call  nextchar         ;<+ get char
    5951/    A177 : 28 22                               jr    z, loc_249B      ; | end of buf?, exit
    5952/    A179 : 38 0C                               jr    c, loc_2487      ; | is a digit? yes, skip
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 109 - 8/15/2019 11:33:6


    5953/    A17B : D6 41                               sub   'A'              ; | no digit andless than 'A'?
    5954/    A17D : 38 1C                               jr    c, loc_249B      ; | yes, exit
    5955/    A17F : FE 06                               cp    6                ; | more than 'F'?
    5956/    A181 : 30 18                               jr    nc, loc_249B     ; | yes, exit
    5957/    A183 : C6 0A                               add   a, 10            ; | adjust to hex digit 0a...0f
    5958/    A185 : 18 02                               jr    loc_2489         ; | input into number buf
    5959/    A187 : D6 30               loc_2487:       sub   CHAR_ZERO        ; | was digit, convert to 0...9
    5960/    A189 : 08                  loc_2489:       ex    af, af'          ; | save digit
    5961/    A18A : 7A                                  ld    a, d             ; | get overflow word
    5962/    A18B : FE 10                               cp    16               ; | is DE already>0xfff? yes reject another digit
    5963/    A18D : D2 55 9D                            jp    nc, e_overflow   ; | yes, arithmetic overflow
    5964/    A190 : 08                                  ex    af, af'          ; | restore digit
    5965/    A191 : EB                                  ex    de, hl           ; | save HL
    5966/    A192 : 29                                  add   hl, hl           ; | shift HL 4 bit left
    5967/    A193 : 29                                  add   hl, hl           ; | 
    5968/    A194 : 29                                  add   hl, hl           ; | 
    5969/    A195 : 29                                  add   hl, hl           ; | 
    5970/    A196 : B5                                  or    l                ; | mask in digit at lowest position
    5971/    A197 : 6F                                  ld    l, a             ; | back into L
    5972/    A198 : EB                                  ex    de, hl           ; | number back into DE
    5973/    A199 : 18 D9                               jr    loop2474         ;-+ loop
    5974/    A19B : E5                  loc_249B:       push  hl               ; save HL
    5975/    A19C : CD 18 8F                            call  uDE_to_fpaccu    ; convert DE to    floating point
    5976/    A19F : E1                                  pop   hl        ; restore HL
    5977/    A1A0 : C9                                  ret
    5978/    A1A1 :                     
    5979/    A1A1 : CD DA 9F            fpaccu_add_u8:  call  push_fpaccu      ; push fpaccu
    5980/    A1A4 : CD A6 9F                            call  s8_to_fp         ; convert 8 bit into FP
    5981/    A1A7 :                     pop_fpreg_and_add:
    5982/    A1A7 : (MACRO)                             POP_FPREG
    5982/    A1A7 : C1                                  pop   bc
    5982/    A1A8 : DD E1                               pop   ix
    5982/    A1AA : D1                                  pop   de
    5983/    A1AB : C3 94 9C                            jp    add_fpreg_fpaccu
    5984/    A1AE :                     
    5985/    A1AE : C8                  mult10_and_dec: ret   z
    5986/    A1AF :                     
    5987/    A1AF :                     fpaccu_mult10_and_dec1:
    5988/    A1AF : F5                                  push  af
    5989/    A1B0 : CD 8E 9F                            call  fpaccu_mult10
    5990/    A1B3 : F1                                  pop   af
    5991/    A1B4 : 3D                                  dec   a                ; decrement exponent count
    5992/    A1B5 : C9                                  ret
    5993/    A1B6 :                     
    5994/    A1B6 :                     fpaccu_div10_and_inc:
    5995/    A1B6 : D5                                  push  de               ; save registers
    5996/    A1B7 : E5                                  push  hl
    5997/    A1B8 : F5                                  push  af
    5998/    A1B9 : CD AF 9E                            call  fpaccu_div10     ; divide fpaccu by 10
    5999/    A1BC : F1                                  pop   af               ; restore registers
    6000/    A1BD : E1                                  pop   hl
    6001/    A1BE : D1                                  pop   de
    6002/    A1BF : 3C                                  inc   a                ; and increment exponent cntr
    6003/    A1C0 : C9                                  ret
    6004/    A1C1 :                     
    6005/    A1C1 :                     ; print string " @ line ", for error/stop output,
    6006/    A1C1 :                     ; print lineno in HL
    6007/    A1C1 :                     print_at_lineno:
    6008/    A1C1 : E5                                  push  hl               ; save HL
    6009/    A1C2 : 21 93 AC                            ld    hl, a_at_line    ; print " @ line "
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 110 - 8/15/2019 11:33:6


    6010/    A1C5 : CD BD 84                            call  print_string
    6011/    A1C8 : E1                                  pop   hl               ; restore it
    6012/    A1C9 :                     
    6013/    A1C9 :                     ; print    u16 number in HL
    6014/    A1C9 : CD 17 8F            print_HL:       call  hl_to_fpaccu     ; put 16 bit number in fpaccu
    6015/    A1CC : 21 AF 0C                            ld    hl, precision    ; save precision
    6016/    A1CF : 7E                                  ld    a, (hl)          ; adjust to maximum precision
    6017/    A1D0 : 36 00                               ld    (hl), 0
    6018/    A1D2 : F5                                  push  af
    6019/    A1D3 : CD DD A1                            call  format_number    ; format number
    6020/    A1D6 : F1                                  pop   af               ; restore precision
    6021/    A1D7 : 32 AF 0C                            ld    (precision), a
    6022/    A1DA : C3 30 91                            jp    loc_1430
    6023/    A1DD :                     
    6024/    A1DD : AF                  format_number:  xor   a                ; fmt unconditionally
    6025/    A1DE :                     
    6026/    A1DE :                     ; format number  with format flags in A
    6027/    A1DE :                     format_number_fmt:
    6028/    A1DE : 32 AA 0C                            ld    (fmt_flags), a
    6029/    A1E1 : 21 6E 0C                            ld    hl, numberbuf    ; scratchpad for formatting number
    6030/    A1E4 : 36 20                               ld    (hl), CHAR_SPACE ; store a leading space
    6031/    A1E6 : E6 08                               and   8                ; check bit 3: put leading '+' sign
    6032/    A1E8 : 28 02                               jr    z, loc_24EC      ; no leading '+'
    6033/    A1EA : 36 2B                               ld    (hl), CHAR_PLUS  ; stor leading +
    6034/    A1EC : CD BF 9F            loc_24EC:       call  fpaccu_sgn       ; get sign of fpaccu
    6035/    A1EF : F2 FA A1                            jp    p, loc_24FA      ; positive?, yes, dont change sign
    6036/    A1F2 :                                                            ; note: if result is 0, Z is 1
    6037/    A1F2 : 36 2D                               ld    (hl), CHAR_MINUS ; store leading '-'
    6038/    A1F4 : E5                                  push  hl               ; save print position
    6039/    A1F5 : CD D2 9F                            call  fpaccu_changesign ; make accu positive
    6040/    A1F8 : E1                                  pop   hl               ; restore print position
    6041/    A1F9 : B4                                  or    h                ; HL is 01xx, this way ensure that Z=0
    6042/    A1FA : 23                  loc_24FA:       inc   hl               ; next print position 
    6043/    A1FB : 36 30                               ld    (hl), CHAR_ZERO  ; store a '0'
    6044/    A1FD : 3A AA 0C                            ld    a, (fmt_flags)   ; get flags
    6045/    A200 : 57                                  ld    d, a             ; into D
    6046/    A201 : 17                                  rla                    ; check bit 7 (shifted into CY)
    6047/    A202 :                                                            ; note: RLC does not affect Z flag, so this
    6048/    A202 :                                                            ; is preserved from checking for accu==zero
    6049/    A202 : DA B2 A2                            jp    c, format_percent ; do percent format? yes, skip
    6050/    A205 : CA AA A2                            jp    z, end_format    ; is accu zero? yes, finished, exit
    6051/    A208 :                                                            ; no is not set, continue
    6052/    A208 : E5                                  push  hl               ; save print position
    6053/    A209 : CD 1F A4                            call  adjust_number_1e10 ; adjust number to be in range
    6054/    A20C :                                                            ; 1E10-1E11 or larger
    6055/    A20C :                                                            ; A contains exponent of adjustment factor
    6056/    A20C :                                                            ; 10 ^ -A.
    6057/    A20C : 21 AF 0C                            ld    hl, precision    ; get precision
    6058/    A20F : 34                                  inc   (hl)             ; check if zero
    6059/    A210 : 35                                  dec   (hl)
    6060/    A211 : 28 51                               jr    z, loc_2564      ; yes, skip
    6061/    A213 :                     ; assume for example here
    6062/    A213 :                     ; Number N=12.3456789, precision=4
    6063/    A213 :                     ; number in fpaccu is now 1234567800
    6064/    A213 : 57                                  ld    d, a             ; D = negative adjustment exponent (-8)
    6065/    A214 : C6 0B                               add   a, 0Bh           ; add 11 (+3)
    6066/    A216 : FA 55 A2                            jp    m, loc_2555      ; still negative? skip: number is less than 0.01
    6067/    A219 : BE                                  cp    (hl)             ; compare with precision (4)
    6068/    A21A : 28 02                               jr    z, loc_251E      ; same? yes continue
    6069/    A21C : 30 37                               jr    nc, loc_2555     ; larger than precision, no rounding
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 111 - 8/15/2019 11:33:6


    6070/    A21E :                                                            ; here: 3-4 -> no skip
    6071/    A21E : 47                  loc_251E:       ld    b, a             ; put adjustment into B (+3)
    6072/    A21F : 7E                                  ld    a, (hl)          ; get precision (4)
    6073/    A220 : 90                                  sub   b                ; subtract adjustment (+1)
    6074/    A221 : 3C                                  inc   a                ; plus 1 (+2)
    6075/    A222 : 4F                                  ld    c, a             ; into C (+2)
    6076/    A223 : 04                                  inc   b                ; adjustment plus 1 (+4)
    6077/    A224 : 7A                                  ld    a, d             ; exponent into A (-8)
    6078/    A225 : 16 0B                               ld    d, 0Bh           ; D = 11
    6079/    A227 : E1                                  pop   hl               ; restore print position
    6080/    A228 : 23                                  inc   hl               ; advance to next position
    6081/    A229 : CD 83 A3                            call  format_numinbuf  ; format the number
    6082/    A22C : E5                                  push  hl               ; save current buf position
    6083/    A22D : AF                                  xor    a               ; clear A
    6084/    A22E : 01 00 00                            ld    bc, 0            ; load maximum cntr
    6085/    A231 : ED B1                               cpir                   ; find zero byte
    6086/    A233 : 2B                                  dec   hl               ; one before
    6087/    A234 : 01 3C A2                            ld    bc, loc_253C     ; inject continuation routine
    6088/    A237 : C5                                  push  bc
    6089/    A238 : AF                                  xor    a               ; clear A, push  on stack
    6090/    A239 : F5                                  push  af               ; exponent to add (0=none)
    6091/    A23A : 18 47                               jr    loc_2583         ; skip: put exponent if any and exit
    6092/    A23C :                     loc_253C:                              ; return here after formatting buf
    6093/    A23C : E1                                  pop   hl               ; restore the buf position
    6094/    A23D : 7E                                  ld    a, (hl)          ; get character from buf
    6095/    A23E : FE 2D                               cp    CHAR_MINUS       ; is negative sign?
    6096/    A240 : C8                                  ret   z                ; yes, exit
    6097/    A241 : FE 20                               cp    CHAR_SPACE       ; is space?
    6098/    A243 : C8                                  ret   z                ; yes, exit
    6099/    A244 : FE 30                               cp    CHAR_ZERO        ; is zero?
    6100/    A246 : 28 0A                               jr    z, loc_2552      ; yes, skip
    6101/    A248 : FE 25                               cp    CHAR_PERCENT     ; is percent?
    6102/    A24A : 20 05                               jr    nz, loc_2551     ; no, skip
    6103/    A24C : 23                                  inc   hl               ; yes, it is
    6104/    A24D :                                         ; advance to next
    6105/    A24D : 7E                                  ld    a, (hl)          ; get next character
    6106/    A24E : FE 2D                               cp    CHAR_MINUS       ; is negative sign?
    6107/    A250 : C8                                  ret   z                ; yes, skip
    6108/    A251 : 2B                  loc_2551:       dec   hl               ; no replace with space
    6109/    A252 : 36 20               loc_2552:       ld    (hl), CHAR_SPACE
    6110/    A254 : C9                                  ret                    ; exit
    6111/    A255 : 4E                  loc_2555:       ld    c, (hl)          ; get precision again
    6112/    A256 : 0D                                  dec   c                ; decrement
    6113/    A257 : 28 01                               jr    z, loc_255A      ; was 1?
    6114/    A259 : 0C                                  inc   c                ; no, add 1 more digit
    6115/    A25A : 06 02               loc_255A:       ld    b, 2             ; load cntr = 2
    6116/    A25C : E1                                  pop   hl               ; restore print position
    6117/    A25D : 23                                  inc   hl               ; advance to next position
    6118/    A25E : 7A                                  ld    a, d             ; load adjustment exponent
    6119/    A25F : 16 00                               ld    d, 0             ; cntr = 0
    6120/    A261 :                     ; A = adjustment exponent
    6121/    A261 :                     ; D = 0
    6122/    A261 : C3 D7 A3                            jp    loc_26D7
    6123/    A264 :                     ; precision is 0
    6124/    A264 :                     ; A is adjustment exponent (positive or negative)
    6125/    A264 : 01 00 03            loc_2564:       ld    bc, 300h         ; B = 3, C = 0
    6126/    A267 : C6 0C                               add   a, 0Ch           ; add 12
    6127/    A269 : FA 74 A2                            jp    m, loc_2574      ; still negative, i.e. less than 0.01
    6128/    A26C : FE 0D                               cp    0Dh              ; is it even less than 0.001?
    6129/    A26E : 30 04                               jr    nc, loc_2574
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 112 - 8/15/2019 11:33:6


    6130/    A270 : 3C                                  inc   a                ; increment
    6131/    A271 : 47                                  ld    b, a             ; set exponent = 2
    6132/    A272 : 3E 02                               ld    a, 2
    6133/    A274 : D6 02               loc_2574:       sub   2
    6134/    A276 : E1                                  pop   hl
    6135/    A277 : F5                                  push  af
    6136/    A278 : CD 5A A4                            call  set_comma
    6137/    A27B : 36 30                               ld    (hl), CHAR_ZERO
    6138/    A27D : 20 01                               jr    nz, loc_2580
    6139/    A27F : 23                                  inc   hl
    6140/    A280 : CD 6D A4            loc_2580:       call  output_num_digits ; put digits of number into buf
    6141/    A283 : 2B                  loc_2583:       dec   hl               ; point to previous buf position
    6142/    A284 : 7E                                  ld    a, (hl)          ; load char
    6143/    A285 : FE 30                               cp    CHAR_ZERO        ; is zero?
    6144/    A287 : 28 FA                               jr    z, loc_2583      ; yes, loop
    6145/    A289 : FE 2E                               cp    CHAR_PERIOD      ; is decimal point?
    6146/    A28B : 28 01                               jr    z, loc_258E      ; yes, skip
    6147/    A28D : 23                                  inc   hl               ; point to last non-zero fractional digit
    6148/    A28E : F1                  loc_258E:       pop   af               ; restore exponent
    6149/    A28F : 28 1A                               jr    z, end_format1   ; terminate if 0 (none)
    6150/    A291 :                     
    6151/    A291 : 36 45               sub_2591:       ld    (hl), CHAR_E     ; put E for exponent in buf
    6152/    A293 : 23                                  inc   hl               ; next position
    6153/    A294 : 36 2B                               ld    (hl), CHAR_PLUS  ; put positive sign
    6154/    A296 : F2 9D A2                            jp    p, loc_259D      ; was exponent positive?
    6155/    A299 : 36 2D                               ld    (hl), CHAR_MINUS ; no, put negative sign
    6156/    A29B : ED 44                               neg                    ; negate exponent
    6157/    A29D : 06 2F               loc_259D:       ld    b, CHAR_ZERO-1   ; preload '0'-1
    6158/    A29F : 04                  loc_259F:       inc   b                ; increment digit count
    6159/    A2A0 : D6 0A                               sub   10               ; subtract 10 from exponent
    6160/    A2A2 : 30 FB                               jr    nc, loc_259F     ; loop until negative
    6161/    A2A4 : C6 3A                               add   a, CHAR_NINE+1   ; add10 again andconvert to digit (+'0')
    6162/    A2A6 : 23                                  inc   hl               ; put tenth digit into buf
    6163/    A2A7 : 70                                  ld    (hl), b
    6164/    A2A8 : 23                                  inc   hl               ; put remainder digit into buf
    6165/    A2A9 : 77                                  ld    (hl), a
    6166/    A2AA : 23                  end_format:     inc   hl               ; advance 
    6167/    A2AB : 36 00               end_format1:    ld    (hl), 0          ; store terminating zero byte
    6168/    A2AD : EB                                  ex    de, hl           ; DE is end of number
    6169/    A2AE : 21 6E 0C                            ld    hl, numberbuf    ; HL is start of number
    6170/    A2B1 : C9                                  ret
    6171/    A2B2 :                     
    6172/    A2B2 : 23                  format_percent: inc   hl               ; advance to next position
    6173/    A2B3 : C5                                  push  bc               ; save format, buf position
    6174/    A2B4 : E5                                  push  hl
    6175/    A2B5 : 7A                                  ld    a, d             ; load format flags
    6176/    A2B6 : 1F                                  rra                    ; bit 0 into CY (digits for exponent)
    6177/    A2B7 : DA CE A3                            jp    c, loc_26CE      ; must do an exponent? yes, skip
    6178/    A2BA : (MACRO)                             FPREG_CONST 0B60Eh, 1BC9h, 0BF04h ; constant 1E16
    6178/    A2BA : 01 0E B6                            ld    bc, 0B60EH
    6178/    A2BD : DD 21 C9 1B                         ld    ix, 1BC9H
    6178/    A2C1 : 11 04 BF                            ld    de, 0BF04H
    6179/    A2C4 : CD 36 A0                            call  fpaccu_compare   ; compare value with 1E16
    6180/    A2C7 : FA D3 A2                            jp    m, loc_25D3      ; larger?
    6181/    A2CA : E1                                  pop   hl               ; restore regs
    6182/    A2CB : C1                                  pop   bc
    6183/    A2CC : CD DD A1                            call  format_number    ; just format number
    6184/    A2CF : 2B                                  dec   hl               ; and add a percent sign afterwards
    6185/    A2D0 : 36 25                               ld    (hl), CHAR_PERCENT
    6186/    A2D2 : C9                                  ret                    ; exit
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 113 - 8/15/2019 11:33:6


    6187/    A2D3 : 16 0B               loc_25D3:       ld    d, 11            ; length of field
    6188/    A2D5 : CD BF 9F                            call  fpaccu_sgn       ; check number zero
    6189/    A2D8 : C4 1F A4                            call  nz, adjust_number_1e10 ; no adjust into range 1E10-1E11
    6190/    A2DB : E1                                  pop   hl               ; restore regs
    6191/    A2DC : C1                                  pop   bc
    6192/    A2DD : FA 83 A3                            jp    m, format_numinbuf ; format number
    6193/    A2E0 : C5                                  push  bc               ; save format to use
    6194/    A2E1 : 5F                                  ld    e, a             ; save precision
    6195/    A2E2 : 78                                  ld    a, b
    6196/    A2E3 : 92                                  sub   d                ; subtract field width
    6197/    A2E4 : 93                                  sub   e                ; subtract precision
    6198/    A2E5 : F4 F9 A4                            call  p, add_zeros     ; addleading zeros
    6199/    A2E8 : CD 01 A5                            call  check_1000s_marker ; calculate position of next comma if any, in C
    6200/    A2EB : CD 6D A4                            call  output_num_digits ; format the digits to emit
    6201/    A2EE : B3                                  or    e                ; more digits before decimal point?
    6202/    A2EF : C4 1B A5                            call  nz, pad_zeros    ; yes, pad with zeros, A=0
    6203/    A2F2 :                     ;                add   a, e             ; put E in A, set flags
    6204/    A2F2 : B3                  		or	e
    6205/    A2F3 : C4 5A A4                            call  nz, set_comma    ; add comma, if neeeded
    6206/    A2F6 : D1                                  pop   de               ; restore format
    6207/    A2F7 : 7B                                  ld    a, e             ; load C (precision)
    6208/    A2F8 : B7                                  or    a                ; is zero?
    6209/    A2F9 : 20 01                               jr    nz, loc_25FC     ; no, skip
    6210/    A2FB : 2B                                  dec   hl               ; preceding position
    6211/    A2FC : 3D                  loc_25FC:       dec   a
    6212/    A2FD : F4 F9 A4                            call  p, add_zeros
    6213/    A300 : E5                  loc_2600:       push  hl               ; save HL
    6214/    A301 : 21 6E 0C                            ld    hl, numberbuf    ; get number buf
    6215/    A304 : 46                                  ld    b, (hl)          ; get first char
    6216/    A305 : 0E 20                               ld    c, CHAR_SPACE    ; preload space
    6217/    A307 : 3A AA 0C                            ld    a, (fmt_flags)   ; get format flags
    6218/    A30A : 5F                                  ld    e, a             ; into E
    6219/    A30B : E6 20                               and   20h              ; test bit 6 (replace leading ' ' with '*')
    6220/    A30D : 28 07                               jr    z, loop2616      ; do not replace
    6221/    A30F : 78                                  ld    a, b             ; put char in A
    6222/    A310 : B9                                  cp    c                ; is space?
    6223/    A311 : 0E 2A                               ld    c, CHAR_STAR     ; preload '*'
    6224/    A313 : 20 01                               jr    nz, loop2616     ; was not space, skip
    6225/    A315 : 41                                  ld    b, c             ; was space, replace with '*'
    6226/    A316 : 71                  loop2616:       ld    (hl), c          ;<+ put space or '*' in buf
    6227/    A317 : CD 47 86                            call  nextchar         ; | get next char from buf
    6228/    A31A : 28 10                               jr    z, loc_262C      ; | end of buf, skip
    6229/    A31C : FE 45                               cp    CHAR_E           ; | is E?
    6230/    A31E : 28 0C                               jr    z, loc_262C      ; | yes, skip
    6231/    A320 : FE 30                               cp    CHAR_ZERO        ; | is '0'?
    6232/    A322 : 28 F2                               jr    z, loop2616      ;>+ yes, advance
    6233/    A324 : FE 2C                               cp    CHAR_COMMA       ; | is comma?
    6234/    A326 : 28 EE                               jr    z, loop2616      ;-+ yes, advance
    6235/    A328 : FE 2E                               cp    CHAR_PERIOD      ; is decimal point?
    6236/    A32A : 20 03                               jr    nz, loc_262F     ; no skip
    6237/    A32C : 2B                  loc_262C:       dec   hl               ; preceding position
    6238/    A32D : 36 30                               ld    (hl), CHAR_ZERO  ; put '0' here
    6239/    A32F : CB 63               loc_262F:       bit    4, e            ; add leading '$'?
    6240/    A331 : 28 03                               jr    z, loc_2636      ; no, skip
    6241/    A333 : 2B                                  dec   hl               ; preceding position
    6242/    A334 : 36 24                               ld    (hl), CHAR_DOLLAR ; put '$' in buf
    6243/    A336 : CB 53               loc_2636:       bit    2, e            ; space for positive sign?
    6244/    A338 : 20 02                               jr    nz, loc_263C     ; yes, skip
    6245/    A33A : 2B                                  dec   hl               ; preceding position
    6246/    A33B : 70                                  ld    (hl), b          ; put space or '*' in position
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 114 - 8/15/2019 11:33:6


    6247/    A33C : E1                  loc_263C:       pop   hl               ; restore end of bufptr
    6248/    A33D : 28 02                               jr    z, loc_2641      ; was not space for positive
    6249/    A33F : 70                                  ld    (hl), b          ; put trailing '*' or space
    6250/    A340 : 23                                  inc   hl               ; next position
    6251/    A341 : 36 00               loc_2641:       ld    (hl), 0          ; put zero byte delimiter
    6252/    A343 : 21 6D 0C                            ld    hl, numberbuf0   ; load one position before buf
    6253/    A346 : 23                  loop2646:       inc   hl               ;<+ advance position
    6254/    A347 : 3A A8 0C            loop2647:       ld    a, (pos_period)  ;<--+ get low address val of position of period
    6255/    A34A : 95                                  sub   l                ; | | subtract buf begin
    6256/    A34B : 92                                  sub   d                ; | | subtract field length
    6257/    A34C : C8                                  ret   z                ; | | correct size?    return
    6258/    A34D : 7E                                  ld    a, (hl)          ; | | load character
    6259/    A34E : FE 20                               cp    CHAR_SPACE       ; | | is space?
    6260/    A350 : 28 F4                               jr    z, loop2646      ;>+ | 
    6261/    A352 : FE 2A                               cp    CHAR_STAR        ; | | or '*'?
    6262/    A354 : 28 F0                               jr    z, loop2646      ;>+ | yes, advance
    6263/    A356 : 2B                                  dec   hl               ;   | preceding position
    6264/    A357 : E5                                  push  hl               ;   | digits start here, save
    6265/    A358 : F5                  loop2658:       push  af               ;<+ | save current character
    6266/    A359 : CD 47 86                            call  nextchar         ; | | next char
    6267/    A35C : FE 2D                               cp    CHAR_MINUS       ; | | is negative sign?
    6268/    A35E : 28 F8                               jr    z, loop2658      ;>+ | save and advance
    6269/    A360 : FE 2B                               cp    CHAR_PLUS        ; | | is positive sign?
    6270/    A362 : 28 F4                               jr    z, loop2658      ;>+ | yes, save and advance
    6271/    A364 : FE 24                               cp    CHAR_DOLLAR      ; | | is '$'?
    6272/    A366 : 28 F0                               jr    z, loop2658      ;>+ | yes save andadvance
    6273/    A368 : FE 30                               cp    CHAR_ZERO        ;   | is leading zero?
    6274/    A36A : 20 10                               jr    nz, loop267C     ;   | no, non-zero digits start here
    6275/    A36C :                     ; discard leading zeroes to fit number into buf
    6276/    A36C : 23                                  inc   hl               ;   | advance to next
    6277/    A36D : CD 47 86                            call  nextchar         ;   | get next char
    6278/    A370 : 30 0A                               jr    nc, loop267C     ;   | not digit, skip
    6279/    A372 : 2B                                  dec   hl               ;   | position to previous
    6280/    A373 : 01                                  db    1                ;   | LD BC, xxxx to skip over next two instrs
    6281/    A374 : 2B                  loop2674:       dec   hl               ;<+ | ** position to previous
    6282/    A375 : 77                                  ld    (hl), a          ; | | ** store character here
    6283/    A376 : F1                                  pop   af               ; | | restore the char before leading zeros
    6284/    A377 : 28 FB                               jr    z, loop2674      ;-+ | not at end? loop
    6285/    A379 : C1                                  pop   bc               ;   | drop saved digit position
    6286/    A37A : 18 CB                               jr    loop2647         ;---+ loop fitting number into field
    6287/    A37C : F1                  loop267C:       pop   af               ;<+ drop characters until end of buf
    6288/    A37D : 28 FD                               jr    z, loop267C      ;-+
    6289/    A37F : E1                                  pop   hl               ; restore buf position
    6290/    A380 : 36 25                               ld    (hl), CHAR_PERCENT ; add a percent sign
    6291/    A382 : C9                                  ret                    ; done
    6292/    A383 :                     
    6293/    A383 :                     ; has number in FPaccu, adjusted to range 1E10-1E11
    6294/    A383 :                     ; again in example:
    6295/    A383 :                     ; Number=12.2345678 precision 4
    6296/    A383 :                     ; fpaccu=1234567800
    6297/    A383 :                     format_numinbuf:
    6298/    A383 : 5F                                  ld    e, a             ; save exponent in E (-8)
    6299/    A384 : 79                                  ld    a, c             ; adjustment in A (+2)
    6300/    A385 : B7                                  or    a                ; does not need correction?
    6301/    A386 : 28 01                               jr    z, loc_2689      ; no, skip
    6302/    A388 : 3D                                  dec   a                ; decrement required adjustment (+1)
    6303/    A389 : 83                  loc_2689:       add   a, e             ; target exponent (-7)
    6304/    A38A : FA 8E A3                            jp    m, loc_268E      ; is negative?, skip
    6305/    A38D : AF                                  xor   a                ; target exponent=0
    6306/    A38E : C5                  loc_268E:       push  bc               ; save BC (B=+4, C=+2)
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 115 - 8/15/2019 11:33:6


    6307/    A38F : F5                                  push  af               ; save target exponent
    6308/    A390 : FC B6 A1            loop2690:       call  m, fpaccu_div10_and_inc ;<+ divide FPaccu/10 andincrement A
    6309/    A393 : 20 FB                               jr    nz, loop2690     ;--------+ target exponent is not yet 0, loop
    6310/    A395 :                                                            ; fpaccu now 123.4567800
    6311/    A395 : C1                                  pop   bc               ; restore exponent in B (-7)
    6312/    A396 : 7B                                  ld    a, e             ; get exponent (-8)
    6313/    A397 : 90                                  sub   b                ; subtract (-1)
    6314/    A398 : C1                                  pop   bc               ; restore BC (+4, +2)
    6315/    A399 : 5F                                  ld    e, a             ; save further exponent correction (-1)
    6316/    A39A : 82                                  add   a, d             ; add field width (10)
    6317/    A39B : 78                                  ld    a, b             ; get B again (+4)
    6318/    A39C : FA AA A3                            jp    m, loc_26AA      ; too large for field?, skip
    6319/    A39F : 92                                  sub   d                ; subtract (-7)
    6320/    A3A0 : 93                                  sub   e                ; subtract (-8)
    6321/    A3A1 : F4 F9 A4                            call  p, add_zeros     ; positive: add leading zeros
    6322/    A3A4 : C5                                  push  bc               ; save BC (+4, +2)
    6323/    A3A5 : CD 01 A5                            call  check_1000s_marker ; get modulo for 1000s comma
    6324/    A3A8 : 18 11                               jr    loc_26BB         ; skip
    6325/    A3AA : CD F9 A4            loc_26AA:       call  add_zeros        ; add leading zeros
    6326/    A3AD : 79                                  ld    a, c             ; save C
    6327/    A3AE : CD 5D A4                            call  set_period       ; store decimal point in buf
    6328/    A3B1 : 4F                                  ld    c, a             ; restore C
    6329/    A3B2 : AF                                  xor   a                ; calculate number of trailing zeros
    6330/    A3B3 : 92                                  sub   d
    6331/    A3B4 : 93                                  sub   e
    6332/    A3B5 : CD F9 A4                            call  add_zeros        ; add trailing zeros
    6333/    A3B8 : C5                                  push  bc               ; save B, C (+4,+2)
    6334/    A3B9 : 47                                  ld    b, a             ; clear B,C
    6335/    A3BA : 4F                                  ld    c, a
    6336/    A3BB : CD 6D A4            loc_26BB:       call  output_num_digits ; (B+C digits)
    6337/    A3BE : C1                                  pop   bc               ; restore BC
    6338/    A3BF : B1                                  or    c                ; A was 0, check if C is also 0
    6339/    A3C0 : 20 03                               jr    nz, loc_26C5     ; no, still digits to add(after decimal  point)
    6340/    A3C2 : 2A A8 0C                            ld    hl, (pos_period) ; get position of period
    6341/    A3C5 : 83                  loc_26C5:       add   a, e             ; calculate remaining field width
    6342/    A3C6 : 3D                                  dec   a                ; add trailing zeros to fill field width
    6343/    A3C7 : F4 F9 A4                            call  p, add_zeros
    6344/    A3CA : 50                                  ld    d, b             ; get number digits after decimal point
    6345/    A3CB : C3 00 A3                            jp    loc_2600         ; jump to final corrections
    6346/    A3CE : CD BF 9F            loc_26CE:       call  fpaccu_sgn
    6347/    A3D1 : 37                                  scf
    6348/    A3D2 : C4 1F A4                            call  nz, adjust_number_1e10
    6349/    A3D5 : E1                                  pop   hl
    6350/    A3D6 : C1                                  pop   bc
    6351/    A3D7 : F5                  loc_26D7:       push  af               ; save adjustment
    6352/    A3D8 : 79                                  ld    a, c             ; get precision
    6353/    A3D9 : B7                                  or	a
    6354/    A3DA : F5                                  push  af               ; save
    6355/    A3DB : 28 01                               jr    z, loc_26DE      ; was zero, skip
    6356/    A3DD : 3D                                  dec   a                ; one less
    6357/    A3DE : 80                  loc_26DE:       add   a, b
    6358/    A3DF : 4F                                  ld    c, a
    6359/    A3E0 : 7A                                  ld    a, d
    6360/    A3E1 : E6 04                               and   4
    6361/    A3E3 : FE 01                               cp    1
    6362/    A3E5 : 9F                                  sbc   a, a
    6363/    A3E6 : 57                                  ld    d, a
    6364/    A3E7 : 81                                  add   a, c
    6365/    A3E8 : 4F                                  ld    c, a
    6366/    A3E9 : D6 0B                               sub   0Bh
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 116 - 8/15/2019 11:33:6


    6367/    A3EB : F5                                  push  af
    6368/    A3EC : C5                                  push  bc
    6369/    A3ED : FC B6 A1            loop26ED:       call  m, fpaccu_div10_and_inc ;<+
    6370/    A3F0 : FA ED A3                            jp    m, loop26ED      ;--------+
    6371/    A3F3 : C1                                  pop   bc
    6372/    A3F4 : F1                                  pop   af
    6373/    A3F5 : C5                                  push  bc
    6374/    A3F6 : F5                                  push  af
    6375/    A3F7 : FA FB A3                            jp    m, loc_26FB
    6376/    A3FA : AF                                  xor    a
    6377/    A3FB : ED 44               loc_26FB:       neg
    6378/    A3FD : 80                                  add   a, b
    6379/    A3FE : 3C                                  inc   a
    6380/    A3FF : 82                                  add   a, d
    6381/    A400 : 47                                  ld    b, a
    6382/    A401 : 0E 00                               ld    c, 0
    6383/    A403 : CD 6D A4                            call  output_num_digits
    6384/    A406 : F1                                  pop   af
    6385/    A407 : F4 15 A5                            call  p, sub_2815
    6386/    A40A : C1                                  pop   bc
    6387/    A40B : F1                                  pop   af
    6388/    A40C : 20 01                               jr    nz, loc_270F
    6389/    A40E : 2B                                  dec   hl
    6390/    A40F : F1                  loc_270F:       pop   af
    6391/    A410 : 38 04                               jr    c, loc_2716
    6392/    A412 : C6 0B                               add   a, 0Bh
    6393/    A414 : 90                                  sub   b
    6394/    A415 : 92                                  sub   d
    6395/    A416 : C5                  loc_2716:       push  bc
    6396/    A417 : CD 91 A2                            call  sub_2591
    6397/    A41A : EB                                  ex    de, hl
    6398/    A41B : D1                                  pop   de
    6399/    A41C : C3 00 A3                            jp    loc_2600
    6400/    A41F :                     
    6401/    A41F :                     ; routine to adjust number so it is between 1E10 and1E11
    6402/    A41F :                     ; return correction exponent in A
    6403/    A41F :                     ; A is negative when number had to be multiplied, i.e. was <1E10
    6404/    A41F :                     ; e.g. number =    1.00 ->    A = -9
    6405/    A41F :                     adjust_number_1e10:
    6406/    A41F : D5                                  push  de               ; save registers
    6407/    A420 : AF                                  xor    a               ; clear adjustment factor
    6408/    A421 : F5                                  push  af               ; save it
    6409/    A422 : CD 48 A4                            call  sub_2748
    6410/    A425 : (MACRO)             loop2725:       FPREG_CONST 0A215h, 2F8h, 0FFFDh ; constant 9 999 999 999.9
    6410/    A425 : 01 15 A2                            ld    bc, 0A215H
    6410/    A428 : DD 21 F8 02                         ld    ix, 2F8H
    6410/    A42C : 11 FD FF                            ld    de, 0FFFDH
    6411/    A42F : CD 36 A0                            call  fpaccu_compare   ; compare accu with constant
    6412/    A432 : F2 45 A4                            jp    p, loc_2745      ; is larger, exit
    6413/    A435 : F1                                  pop   af               ; restore exponent count
    6414/    A436 : CD AF A1                            call  fpaccu_mult10_and_dec1 ; multiply with 10 and decrement exponent
    6415/    A439 : F5                                  push  af
    6416/    A43A : C3 25 A4                            jp    loop2725         ; loop
    6417/    A43D : F1                  loop273D:       pop   af               ;<---+ restore exponent count
    6418/    A43E : CD B6 A1                            call  fpaccu_div10_and_inc ;| divide by 10 and adjust exponent count
    6419/    A441 : F5                                  push  af               ;    | save exponent count again
    6420/    A442 : CD 48 A4                            call  sub_2748         ;    | is still too large?
    6421/    A445 : F1                  loc_2745:       pop   af               ;    | 
    6422/    A446 : D1                                  pop   de               ;    | 
    6423/    A447 : C9                                  ret                    ;    | 
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 117 - 8/15/2019 11:33:6


    6424/    A448 : (MACRO)             sub_2748:       FPREG_CONST 0A53Ah, 43B7h, 3FFCh ; constant 99 999 999 999.5
    6424/    A448 : 01 3A A5                            ld    bc, 0A53AH
    6424/    A44B : DD 21 B7 43                         ld    ix, 43B7H
    6424/    A44F : 11 FC 3F                            ld    de, 3FFCH
    6425/    A452 : CD 36 A0                            call  fpaccu_compare   ;    | compare accu with constant
    6426/    A455 : E1                                  pop   hl               ;    | get return value
    6427/    A456 : F2 3D A4                            jp    p, loop273D      ;----+ if larger, divide by 10
    6428/    A459 : E9                                  jp    (hl)
    6429/    A45A :                     
    6430/    A45A :                     ; set a 1000s marker (comma), if needed
    6431/    A45A :                     ; (still digits to emit before decimal point)
    6432/    A45A :                     ; B is digits before decimal point
    6433/    A45A : 05                  set_comma:      dec   b                ; decrement count of digits before period
    6434/    A45B : 20 08                               jr    nz, loc_2765     ; not yet zero, emit more
    6435/    A45D :                     
    6436/    A45D :                     ; put a decimal point into number buf, clear C if called from set_comma
    6437/    A45D : 36 2E               set_period:     ld    (hl), CHAR_PERIOD ; store a period
    6438/    A45F : 22 A8 0C                            ld    (pos_period), hl ; save period position
    6439/    A462 : 23                                  inc   hl               ; advance to next position
    6440/    A463 : 48                                  ld    c, b             ; clear C, when coming from set_comma
    6441/    A464 : C9                                  ret                    ; exit
    6442/    A465 : 0D                  loc_2765:       dec   c                ; decrement comma cntr
    6443/    A466 : C0                                  ret   nz               ; not yet zero, exit
    6444/    A467 : 36 2C                               ld    (hl), CHAR_COMMA ; put a comma marker into buf
    6445/    A469 : 23                                  inc   hl
    6446/    A46A : 0E 03                               ld    c, 3             ; reload comma cntr
    6447/    A46C : C9                                  ret                    ; exit
    6448/    A46D :                     
    6449/    A46D :                     output_num_digits:
    6450/    A46D : D5                                  push  de               ; save registers
    6451/    A46E : C5                                  push  bc
    6452/    A46F : E5                                  push  hl
    6453/    A470 : CD 80 9C                            call  add_0_5          ; add 0.5 for rounding
    6454/    A473 : 3C                                  inc   a                ; add 1 to FPaccu exponent
    6455/    A474 : CD 75 A0                            call  fpreg_fix        ; clip fractional digits
    6456/    A477 : CD F5 9F                            call  store_fpaccu     ; save result again
    6457/    A47A : E1                                  pop   hl               ; restore HL, BC registers
    6458/    A47B : C1                                  pop   bc
    6459/    A47C : 11 C2 A4                            ld    de, powers10     ; get powers of 10 table
    6460/    A47F : 3E 0B                               ld    a, 0Bh           ; loop count
    6461/    A481 :                     ; B is number of digits before decimal point
    6462/    A481 :                     ; C cntr for comma positions
    6463/    A481 :                     loop2781:                              ;<--+ set a 1000s marker if needed,
    6464/    A481 :                                                            ;   | or a period, unless
    6465/    A481 : CD 5A A4                            call  set_comma        ;   | more digits to emit
    6466/    A484 : C5                                  push  bc               ;   | save regs
    6467/    A485 : F5                                  push  af               ;   | 
    6468/    A486 : E5                                  push  hl               ;   | 
    6469/    A487 : D5                                  push  de               ;   | 
    6470/    A488 : CD 02 A0                            call  fpaccu_to_fpreg  ;   | copy fpaccu to fpreg
    6471/    A48B : E1                                  pop   hl               ;   | HL = powers of 10 table
    6472/    A48C : 06 2F                               ld    b, CHAR_ZERO-1   ;   | preload '0'-1
    6473/    A48E : 04                  loop278E:       inc   b                ;<+ | increment (accumulator of current digit)
    6474/    A48F : 7B                                  ld    a, e             ; | | subtract current power of 10
    6475/    A490 : 96                                  sub   (hl)             ; | | 
    6476/    A491 : 5F                                  ld    e, a             ; | | 
    6477/    A492 : 23                                  inc   hl               ; | | 
    6478/    A493 : 7A                                  ld    a, d             ; | | 
    6479/    A494 : 9E                                  sbc   a, (hl)          ; | | 
    6480/    A495 : 57                                  ld    d, a             ; | | 
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 118 - 8/15/2019 11:33:6


    6481/    A496 : 23                                  inc   hl               ; | | 
    6482/    A497 : DD 7D                               ld    a, ixl            ; | | 
    6483/    A499 : 9E                                  sbc   a, (hl)          ; | | 
    6484/    A49A : DD 6F                               ld    ixl, a            ; | | 
    6485/    A49C : 23                                  inc   hl               ; | | 
    6486/    A49D : DD 7C                               ld    a, ixh            ; | | 
    6487/    A49F : 9E                                  sbc   a, (hl)          ; | | 
    6488/    A4A0 : DD 67                               ld    ixh, a            ; | | 
    6489/    A4A2 : 23                                  inc   hl               ; | | 
    6490/    A4A3 : 79                                  ld    a, c             ; | | 
    6491/    A4A4 : 9E                                  sbc   a, (hl)          ; | | 
    6492/    A4A5 : 4F                                  ld    c, a             ; | | 
    6493/    A4A6 : 2B                                  dec   hl               ; | | point back to current power
    6494/    A4A7 : 2B                                  dec   hl               ; | | 
    6495/    A4A8 : 2B                                  dec   hl               ; | | 
    6496/    A4A9 : 2B                                  dec   hl               ; | | 
    6497/    A4AA : 30 E2                               jr    nc, loop278E     ;-+ | still positive, loop
    6498/    A4AC : CD 5A 9D                            call  add_mantissas    ;   | became negative, addcurrent power again
    6499/    A4AF : 23                                  inc   hl               ;   | advance to next position
    6500/    A4B0 : CD F5 9F                            call  store_fpaccu     ;   | save the current result again
    6501/    A4B3 : EB                                  ex    de, hl           ;   | DE is ptr to powers of 10, now next power
    6502/    A4B4 : E1                                  pop   hl               ;   | restore ptr to number buf
    6503/    A4B5 : 70                                  ld    (hl), b          ;   | save calculated digit
    6504/    A4B6 : 23                                  inc   hl               ;   | advance to next buf position
    6505/    A4B7 : F1                                  pop   af               ;   | restore A
    6506/    A4B8 : C1                                  pop   bc               ;   | restore BC
    6507/    A4B9 : 3D                                  dec   a                ;   | decrement loop
    6508/    A4BA : 20 C5                               jr    nz, loop2781     ;---+ loop for 11 digits
    6509/    A4BC : CD 5A A4                            call  set_comma        ; set comma if needed
    6510/    A4BF : 77                                  ld    (hl), a          ; store terminating zero in buf
    6511/    A4C0 : D1                                  pop   de               ; restore DE
    6512/    A4C1 : C9                                  ret
    6513/    A4C2 :                     
    6514/    A4C2 : 00 E4 0B 54 02      powers10:       db    0, 0E4h, 0Bh, 54h, 2 ; constant 10000000000
    6515/    A4C7 : 00 CA 9A 3B 00                      db    0, 0CAh, 9Ah, 3Bh, 0 ; constant 1000000000
    6516/    A4CC : 00 E1 F5 05 00                      db    0, 0E1h, 0F5h, 5, 0  ; constant 100000000
    6517/    A4D1 : 80 96 98 00 00                      db    80h, 96h, 98h, 0, 0  ; constant 10000000
    6518/    A4D6 : 40 42 0F 00 00                      db    40h, 42h, 0Fh, 0, 0  ; constant 1000000
    6519/    A4DB : A0 86 01 00 00                      db    0A0h, 86h, 1, 0, 0   ; constant 100000
    6520/    A4E0 : 10 27 00 00 00                      db    10h, 27h, 0, 0, 0    ; constant 10000
    6521/    A4E5 : E8 03 00 00 00                      db    0E8h, 3, 0, 0, 0     ; constant 1000
    6522/    A4EA : 64 00 00 00 00                      db    64h, 0, 0, 0, 0      ; constant 100
    6523/    A4EF : 0A 00 00 00 00                      db    0Ah, 0, 0, 0, 0      ; constant 10
    6524/    A4F4 : 01 00 00 00 00                      db    1, 0, 0, 0, 0        ; constant 1
    6525/    A4F9 :                     
    6526/    A4F9 : B7                  add_zeros:      or    a                ; is cntr for zeros = 0?
    6527/    A4FA : C8                                  ret   z                ; yes exit
    6528/    A4FB : 3D                                  dec   a                ; decrement count
    6529/    A4FC : 36 30                               ld    (hl), CHAR_ZERO  ; put '0' in buf
    6530/    A4FE : 23                                  inc   hl               ; advance to next
    6531/    A4FF : 18 F8                               jr    add_zeros        ; loop
    6532/    A501 :                     
    6533/    A501 :                     check_1000s_marker:
    6534/    A501 : 7B                                  ld    a, e             ; get E (-1)
    6535/    A502 : 82                                  add   a, d             ; add field width (10)
    6536/    A503 : 3C                                  inc   a                ; add 1 for period (11)
    6537/    A504 : 47                                  ld    b, a             ; put into B
    6538/    A505 : 3C                                  inc   a                ; add 1 (12)
    6539/    A506 : D6 03               loop2806:       sub   3                ;<+ calculate modulo 3
    6540/    A508 : 30 FC                               jr    nc, loop2806     ;-+
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 119 - 8/15/2019 11:33:6


    6541/    A50A : C6 05                               add   a, 5             ; add 5 to modulo
    6542/    A50C : 4F                                  ld    c, a             ; store into C (+5)
    6543/    A50D : 3A AA 0C                            ld    a, (fmt_flags)   ; get format flags
    6544/    A510 : E6 40                               and   40h              ; check comma flag
    6545/    A512 : C0                                  ret   nz               ; exit with modulus+5 if set
    6546/    A513 : 4F                                  ld    c, a             ; return zero if not set
    6547/    A514 : C9                                  ret
    6548/    A515 :                     
    6549/    A515 : 20 04               sub_2815:       jr    nz, pad_zeros
    6550/    A517 : C8                  loop2817:       ret   z                ;<+
    6551/    A518 : CD 5A A4                            call  set_comma        ; | 
    6552/    A51B : 36 30               pad_zeros:      ld    (hl), CHAR_ZERO  ; | put trailing zero in buf
    6553/    A51D : 23                                  inc   hl               ; | advance
    6554/    A51E : 3D                                  dec   a                ; | decrement cntr
    6555/    A51F : 18 F6                               jr    loop2817         ;-+ loop
    6556/    A521 :                     
    6557/    A521 :                     ; has seen PRINT USING...
    6558/    A521 : CD 47 86            printusing:     call  nextchar         ; get next token
    6559/    A524 : 30 1E                               jr    nc, loc_2844     ; is not a digit, skip
    6560/    A526 : CD 85 86                            call  read_lineno      ; get lineno of USING statement ("!...")
    6561/    A529 : E5                                  push  hl               ; save curlineptr
    6562/    A52A : CD 92 82                            call  find_line        ; search for USING line
    6563/    A52D : D2 E1 87                            jp    nc, undef_stmt_error ; not found, error
    6564/    A530 : (MACRO)                             LDHL_BC                ; get position into HL
    6564/    A530 : 60                                  ld    h, b
    6564/    A531 : 69                                  ld    l, c
    6565/    A532 : 23                                  inc   hl               ; advance to line body, skip lineno
    6566/    A533 : 23                                  inc   hl
    6567/    A534 : 23                                  inc   hl
    6568/    A535 : CD 47 86                            call  nextchar         ; get first char of line
    6569/    A538 : D6 9C                               sub   9Ch              ; must be a ! token
    6570/    A53A : C2 44 87                            jp    nz, illfunc_error ; otherwise error
    6571/    A53D : 47                                  ld    b, a             ; B is 0, store string terminator
    6572/    A53E :                                                            ; USING is only statement in line
    6573/    A53E : CD F0 90                            call  copy_0string     ; copy 0 terminated string in stringaccu
    6574/    A541 : E1                                  pop   hl               ; restore curlineptr of PRINT statement
    6575/    A542 : 18 03                               jr    loc_2847         ; skip
    6576/    A544 : CD 95 8B            loc_2844:       call  string_expression1 ; get a string expression
    6577/    A547 : CD 48 86            loc_2847:       call  skipspace        ; advance to next non-whitespace
    6578/    A54A : 37                                  scf                    ; set CY
    6579/    A54B : 28 0C                               jr    z, loc_2859      ; end of statement? skip
    6580/    A54D : FE 2C                               cp    CHAR_COMMA       ; expect either comma or semicolon
    6581/    A54F : 28 05                               jr    z, loc_2856
    6582/    A551 : FE 3B                               cp    CHAR_SEMI
    6583/    A553 : C2 6D 81                            jp    nz, syntax_error ; otherwise syntax error
    6584/    A556 : CD 47 86            loc_2856:       call  nextchar         ; skip over delimiter
    6585/    A559 : EB                  loc_2859:       ex    de, hl           ; save curlineptr
    6586/    A55A : 2A 66 0C                            ld    hl, (fpaccu_mant32) ; load string descriptor of USING
    6587/    A55D : 01                                  db    1                ; LD BC, xxxx to skip next 2 instructions
    6588/    A55E :                                                            ; is uncritical because BC will be overwritten
    6589/    A55E : D1                  loc_285E:       pop   de               ; **
    6590/    A55F : EB                                  ex    de, hl           ; **
    6591/    A560 : E5                                  push  hl               ; save ptr to USING string
    6592/    A561 : F5                                  push  af               ; save nextchar after expression
    6593/    A562 : D5                                  push  de               ; save DE
    6594/    A563 : 46                                  ld    b, (hl)          ; get string length
    6595/    A564 : B0                                  or    b
    6596/    A565 : CA 44 87                            jp    z, illfunc_error ; empty? error
    6597/    A568 : 23                                  inc   hl               ; point to address of USING format
    6598/    A569 : 23                                  inc   hl
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 120 - 8/15/2019 11:33:6


    6599/    A56A : (MACRO)                             LDHL_M C               ; get USING format into HL
    6599/    A56A : 4E                                  ld    C, (hl)
    6599/    A56B : 23                                  inc   hl
    6599/    A56C : 66                                  ld    h, (hl)
    6599/    A56D : 69                                  ld    l, C
    6600/    A56E : C3 77 A5                            jp    loc_2877         ; skip
    6601/    A571 : CD F9 A6            loc_2871:       call  plus_if_D        ; print leading '+' if requested
    6602/    A574 : CD 72 84                            call  write_char       ; print the char in A
    6603/    A577 :                     loc_2877:
    6604/    A577 : AF                                  xor   a
    6605/    A578 : 5F                                  ld    e, a             ; numeric digits before decimal point
    6606/    A579 :                                                            ; (C will become digits after DP)
    6607/    A579 : 57                                  ld    d, a             ; stores fmt_flag, initially 0
    6608/    A57A : CD F9 A6            loop287A:       call  plus_if_D        ;<+ print leading '+' if D != 0
    6609/    A57D : 57                                  ld    d, a             ; | store fmt_flag
    6610/    A57E : 7E                                  ld    a, (hl)          ; | get char from USING format
    6611/    A57F : 23                                  inc   hl               ; | next position
    6612/    A580 : FE 23                               cp    CHAR_HASH        ; | is it a numeric digit?
    6613/    A582 : CA BE A5                            jp    z, using_numeric ; | 
    6614/    A585 : FE 27                               cp    CHAR_TIC         ; | TIC, is it a string field?
    6615/    A587 : CA 81 A6                            jp    z, using_string  ; | 
    6616/    A58A : 05                                  dec   b                ; | decrement length of format
    6617/    A58B : CA 6D A6                            jp    z, using_end     ; | end of format? yes skip
    6618/    A58E : FE 2B                               cp    CHAR_PLUS        ; | no, is it a '+'?
    6619/    A590 : 3E 08                               ld    a, 8             ; | yes set bit3 in format flag (leading '+')
    6620/    A592 : 28 E6                               jr    z, loop287A      ;-+ loop
    6621/    A594 : 2B                                  dec   hl               ; no wasn't a '+', reget the last format character
    6622/    A595 : 7E                                  ld    a, (hl)
    6623/    A596 : 23                                  inc   hl
    6624/    A597 : FE 2E                               cp    CHAR_PERIOD      ; a leading decimal point?
    6625/    A599 : CA D6 A5                            jp    z, using_dp1     ; yes, count digits after DP
    6626/    A59C : BE                                  cp    (hl)             ; duplicate characters?
    6627/    A59D : 20 D2                               jr    nz, loc_2871     ; print non-format char
    6628/    A59F : FE 24                               cp    CHAR_DOLLAR      ; was the duplicate char a '$'?
    6629/    A5A1 : 28 14                               jr    z, using_dollar  ; yes, skip
    6630/    A5A3 : FE 2A                               cp    CHAR_STAR        ; is '*'?
    6631/    A5A5 : 20 CA                               jr    nz, loc_2871     ; no, print the non-format character
    6632/    A5A7 : 78                                  ld    a, b             ; get format string length
    6633/    A5A8 : FE 02                               cp    2                ; at least more than 2 chars in format?
    6634/    A5AA : 23                                  inc   hl               ; advance to next format pos
    6635/    A5AB : 38 03                               jr    c, loc_28B0      ; no, skip
    6636/    A5AD : 7E                                  ld    a, (hl)          ; get next format char
    6637/    A5AE : FE 24                               cp    CHAR_DOLLAR      ; is it a '$', i.e. sequence '**$'?
    6638/    A5B0 : 3E 20               loc_28B0:       ld    a, 20h           ; set bit 5 of fmt_flag
    6639/    A5B2 : 20 07                               jr    nz, loc_28BB     ; not '**$', skip
    6640/    A5B4 : 05                                  dec   b                ; decrement remaining format length
    6641/    A5B5 : 1C                                  inc   e                ; add one more digit before decimal point
    6642/    A5B6 : FE                                  db    0FEh             ; CP AF to skip next instruction
    6643/    A5B7 : AF                  using_dollar:   xor   a                ; ** clear fmt_flag
    6644/    A5B8 : C6 10                               add   a, 10h           ; set flag 4 of fmt_flag
    6645/    A5BA : 23                                  inc   hl               ; advance to next format character
    6646/    A5BB : 1C                  loc_28BB:       inc   e                ; increment numeric digit count (for '*')
    6647/    A5BC : 82                                  add   a, d             ; set bits into fmt_flag
    6648/    A5BD : 57                                  ld    d, a
    6649/    A5BE : 1C                  using_numeric:  inc   e                ; increment cntr for numeric digits
    6650/    A5BF : 0E 00                               ld    c, 0             ; clear cntr of digits after DP
    6651/    A5C1 : 05                                  dec   b                ; decrement format length
    6652/    A5C2 : 28 46                               jr    z, loc_290A      ; end of format? skip
    6653/    A5C4 : 7E                                  ld    a, (hl)          ; get next char of format
    6654/    A5C5 : 23                                  inc   hl               ; advance format ptr
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 121 - 8/15/2019 11:33:6


    6655/    A5C6 : FE 2E                               cp    CHAR_PERIOD      ; is it a decimal point?
    6656/    A5C8 : 28 17                               jr    z, using_dp      ; yes decimal
    6657/    A5CA : FE 23                               cp    CHAR_HASH        ; is it another numeric digit?
    6658/    A5CC : 28 F0                               jr    z, using_numeric ; yes loop
    6659/    A5CE : FE 2C                               cp    CHAR_COMMA       ; is it a comma?
    6660/    A5D0 : 20 19                               jr    nz, loc_28EB
    6661/    A5D2 : CB F2                               set    6, d            ; set fmt_flag bit 6 (addcommas for 1000's)
    6662/    A5D4 : 18 E8                               jr    using_numeric    ; loop
    6663/    A5D6 :                     using_dp1:                             ; handle leading decimal point
    6664/    A5D6 : 7E                                  ld    a, (hl)          ; get next format char
    6665/    A5D7 : FE 23                               cp    CHAR_HASH        ; is it numeric?
    6666/    A5D9 : 3E 2E                               ld    a, CHAR_PERIOD   ; load decimal point
    6667/    A5DB : C2 71 A5                            jp    nz, loc_2871     ; not numeric, go, print the decimal point
    6668/    A5DE : 0E 01                               ld    c, 1             ; set count of digits after decimal point
    6669/    A5E0 : 23                                  inc   hl               ; advance to next format position
    6670/    A5E1 : 0C                  using_dp:       inc   c                ; increment count of digits after decimal point
    6671/    A5E2 : 05                                  dec   b                ; decrement format ptr
    6672/    A5E3 : 28 25                               jr    z, loc_290A      ; exit if zero
    6673/    A5E5 : 7E                                  ld    a, (hl)          ; get next format character
    6674/    A5E6 : 23                                  inc   hl               ; advance format ptr
    6675/    A5E7 : FE 23                               cp    CHAR_HASH        ; is it '#'?
    6676/    A5E9 : 28 F6                               jr    z, using_dp      ; continue counting digits after DP
    6677/    A5EB :                                                            ; a non-# format char
    6678/    A5EB : D5                  loc_28EB:       push  de               ; save fmt_flag and digit count
    6679/    A5EC : (MACRO)                             LDDE_HL                ; save current format pos into DE
    6679/    A5EC : 54                                  ld    d, h
    6679/    A5ED : 5D                                  ld    e, l
    6680/    A5EE : FE 5E                               cp    CHAR_POWER       ; is it a ^ (exponent marker)
    6681/    A5F0 : 20 16                               jr    nz, loc_2908     ; no, skip
    6682/    A5F2 : BE                                  cp    (hl)             ; check with next pos
    6683/    A5F3 : 20 13                               jr    nz, loc_2908     ; not a second ^, skip
    6684/    A5F5 : 23                                  inc   hl
    6685/    A5F6 : BE                                  cp    (hl)             ; check third pos
    6686/    A5F7 : 20 0F                               jr    nz, loc_2908     ; no, not a third ^
    6687/    A5F9 : 23                                  inc   hl
    6688/    A5FA : BE                                  cp    (hl)             ; check fourth pos
    6689/    A5FB : 20 0B                               jr    nz, loc_2908     ; no, not a fourth ^
    6690/    A5FD : 23                                  inc   hl
    6691/    A5FE : 78                                  ld    a, b             ; subtract 4 from string length
    6692/    A5FF : D6 04                               sub   4
    6693/    A601 : 38 05                               jr    c, loc_2908      ; not enough chars left in format?
    6694/    A603 : D1                                  pop   de               ; restore format flag and digit count
    6695/    A604 : 47                                  ld    b, a             ; save string length back to B
    6696/    A605 : 14                                  inc   d                ; set flag 0 in fmt
    6697/    A606 : 23                                  inc   hl               ; advance to next position
    6698/    A607 : CA                                  db    0CAh             ; JP Z, xxxx to skip next 2 instructions
    6699/    A608 :                                                            ; is uncritical because Z is never set here
    6700/    A608 : EB                  loc_2908:       ex    de, hl           ;** restore old position of format ptr
    6701/    A609 : D1                                  pop   de               ;** restore saved flags
    6702/    A60A : 2B                  loc_290A:       dec   hl               ; skip back to last char of format
    6703/    A60B : 1C                                  inc   e                ; reserve a digit for a potential sign
    6704/    A60C : CB 5A                               bit   3, d             ; check sign flag
    6705/    A60E : 20 13                               jr    nz, loc_2923     ; is sign bit set
    6706/    A610 : 1D                                  dec   e                ; have a reserved sign position
    6707/    A611 :                                                            ; therefore don't reserve another one
    6708/    A611 : 78                                  ld    a, b             ; get remaining format string length
    6709/    A612 : B7                                  or    a
    6710/    A613 : 28 0E                               jr    z, loc_2923      ; now at end? yes, skip
    6711/    A615 : 7E                                  ld    a, (hl)          ; no, is it a '-'?
    6712/    A616 : D6 2D                               sub   CHAR_MINUS
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 122 - 8/15/2019 11:33:6


    6713/    A618 : 28 06                               jr    z, using_minus   ; yes, skip
    6714/    A61A : FE FE               loc_291A:       cp    -2               ; was it a '+'?
    6715/    A61C : 20 05                               jr    nz, loc_2923     ; no, skip
    6716/    A61E : CB DA                               set   3, d             ; yes, it was, set BIT 3
    6717/    A620 : CB D2               using_minus:    set   2, d             ; set bit 2: print minus sign, but space for '+'
    6718/    A622 : 05                                  dec   b                ; decrement format string length
    6719/    A623 : E1                  loc_2923:       pop   hl               ; restore curlineptr
    6720/    A624 : F1                                  pop   af               ; restore nextchar
    6721/    A625 : 28 51                               jr    z, loc_2978      ; is EOLN? yes skip
    6722/    A627 : C5                                  push  bc               ; save format
    6723/    A628 : D5                                  push  de               ; D = fmt_flag
    6724/    A629 :                                                            ; E = digits before DP
    6725/    A629 :                                                            ; C = digits after DP
    6726/    A629 : CD 9A 8B                            call  expression1      ; get expression to print
    6727/    A62C : D1                                  pop   de               ; restore format
    6728/    A62D : C1                                  pop   bc
    6729/    A62E : C5                                  push  bc               ; save BC
    6730/    A62F : E5                                  push  hl               ; save curlineptr
    6731/    A630 : 43                                  ld    b, e             ; get digits before DP into E
    6732/    A631 : 78                                  ld    a, b             ; calculate total length of field
    6733/    A632 : 81                                  add   a, c
    6734/    A633 : FE 19                               cp    25               ; longer than 25? -> accuracy problem,
    6735/    A635 :                                                            ; we don't have that many significant digits
    6736/    A635 : D2 44 87                            jp    nc, illfunc_error ; yes, error
    6737/    A638 : 7A                                  ld    a, d             ; get format flag
    6738/    A639 : F6 80                               or    80h              ; set bit 7
    6739/    A63B : CD DE A1                            call  format_number_fmt ; format number in buf
    6740/    A63E : CD 31 91                            call  straccu_copy_print ; copy to straccu andprint it
    6741/    A641 : E1                  print_mainloop: pop   hl               ; restore curlineptr
    6742/    A642 : CD 48 86                            call  skipspace        ; advance to next non-whitespace
    6743/    A645 : 37                                  scf
    6744/    A646 : 28 0C                               jr    z, loc_2954      ; end of line? yes, exit
    6745/    A648 : FE 3B                               cp    CHAR_SEMI        ; semicolon follwing?
    6746/    A64A : 28 05                               jr    z, loc_2951      ; yes advance
    6747/    A64C : FE 2C                               cp    CHAR_COMMA       ; comma following?
    6748/    A64E : C2 6D 81                            jp    nz, syntax_error ; no, error
    6749/    A651 : CD 47 86            loc_2951:       call  nextchar         ; advance
    6750/    A654 : C1                  loc_2954:       pop   bc               ; restore BC
    6751/    A655 : EB                                  ex    de, hl           ; save curlinepos -> DE
    6752/    A656 : E1                                  pop   hl               ; restore string descriptor to format
    6753/    A657 : E5                                  push  hl               ; save it again
    6754/    A658 : F5                                  push  af
    6755/    A659 : D5                                  push  de               ; save curlineptr
    6756/    A65A : 7E                                  ld    a, (hl)          ; get string length
    6757/    A65B : 90                                  sub   b                ; subtract format length
    6758/    A65C : 23                                  inc   hl               ; advance to string ptr
    6759/    A65D : 23                                  inc   hl
    6760/    A65E : (MACRO)                             LDHL_M C               ; get string address into HL
    6760/    A65E : 4E                                  ld    C, (hl)
    6760/    A65F : 23                                  inc   hl
    6760/    A660 : 66                                  ld    h, (hl)
    6760/    A661 : 69                                  ld    l, C
    6761/    A662 : 16 00                               ld    d, 0
    6762/    A664 : 5F                                  ld    e, a
    6763/    A665 : 19                                  add   hl, de           ; advance to remaining format part
    6764/    A666 : 78                                  ld    a, b             ; still chars in format string?
    6765/    A667 : B7                                  or    a
    6766/    A668 : C2 77 A5                            jp    nz, loc_2877     ; yes, do another formatting
    6767/    A66B : 18 06                               jr    loc_2973         ; otherwise exit
    6768/    A66D : CD F9 A6            using_end:      call  plus_if_D
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 123 - 8/15/2019 11:33:6


    6769/    A670 : CD 72 84                            call  write_char
    6770/    A673 : E1                  loc_2973:       pop   hl               ; restore curlineptr
    6771/    A674 : F1                                  pop   af               ; restore last char seen
    6772/    A675 : C2 5E A5                            jp    nz, loc_285E     ; loop
    6773/    A678 : DC EE 89            loc_2978:       call  c, print_crlf    ; print new line
    6774/    A67B : E3                                  ex    (sp), hl         ; save curlineptr to stack, restore
    6775/    A67C :                                                            ; string stack ptr
    6776/    A67C : CD 66 92                            call  pop_str_stringstk ; discard format/scratchpad from string stack
    6777/    A67F : E1                                  pop   hl               ; restore curlineptr
    6778/    A680 : C9                                  ret                    ; exit
    6779/    A681 :                     
    6780/    A681 :                     ; has seen a tic (') for a string field
    6781/    A681 : 0E 01               using_string:   ld    c, 1             ; initialize field size cntr
    6782/    A683 : 1E 4C                               ld    e, 'L'           ; left justified
    6783/    A685 : 05                                  dec   b                ; nothing left?, exit
    6784/    A686 : 28 1C                               jr    z, loc_29A4
    6785/    A688 : 7E                                  ld    a, (hl)          ; get char after tic
    6786/    A689 : 23                                  inc   hl               ; advance
    6787/    A68A : FE 45                               cp    'E'              ; is it an 'E' (left justify with extension)
    6788/    A68C : 28 0C                               jr    z, loc_299A      ; yes, put into reg E
    6789/    A68E : FE 52                               cp    'R'              ; is it a 'R' (right justified)?
    6790/    A690 : 28 08                               jr    z, loc_299A      ; yes, put into reg E
    6791/    A692 : FE 4C                               cp    'L'              ; is it an 'L' (left justified)?
    6792/    A694 : 28 04                               jr    z, loc_299A      ; yes, put into reg E
    6793/    A696 : FE 43                               cp    'C'              ; is it a 'C' (centered)?
    6794/    A698 : 20 0A                               jr    nz, loc_29A4     ; no, skip, default reg E is 'L')
    6795/    A69A : 5F                  loc_299A:       ld    e, a             ; store the justification key in E
    6796/    A69B : 0C                  loc_299B:       inc   c                ; increment field size cntr
    6797/    A69C : 05                                  dec   b                ; at end of line?
    6798/    A69D : 28 05                               jr    z, loc_29A4      ; yes, exit loop
    6799/    A69F : 7E                                  ld    a, (hl)          ; get next char
    6800/    A6A0 : 23                                  inc   hl               ; advance
    6801/    A6A1 : BB                                  cp    e                ; is it the same as previous one?
    6802/    A6A2 : 28 F7                               jr    z, loc_299B      ; yes, loop
    6803/    A6A4 :                     ; end of USING string
    6804/    A6A4 :                     ;
    6805/    A6A4 :                     ; start here to emit string corresponding to format
    6806/    A6A4 : CD F9 A6            loc_29A4:       call  plus_if_D        ; emit start of field
    6807/    A6A7 : E1                                  pop   hl               ; restore curlineptr
    6808/    A6A8 : F1                                  pop   af               ; and last char seen
    6809/    A6A9 : 28 CD                               jr    z, loc_2978      ; EOLN? yes exit
    6810/    A6AB : C5                                  push  bc
    6811/    A6AC : D5                                  push  de
    6812/    A6AD : CD 95 8B                            call  string_expression1 ; get a string expression
    6813/    A6B0 : D1                                  pop   de
    6814/    A6B1 : C1                                  pop   bc
    6815/    A6B2 : C5                                  push  bc               ; B = remaining format length
    6816/    A6B3 :                                                            ; C = field length
    6817/    A6B3 :                                                            ; E = justification
    6818/    A6B3 : E5                                  push  hl               ; save curlineptr
    6819/    A6B4 : 2A 66 0C                            ld    hl, (fpaccu_mant32) ; get string descriptor in FPaccu
    6820/    A6B7 : 41                                  ld    b, c             ; get field length
    6821/    A6B8 : 0E 00                               ld    c, 0             ; cntr for trailing spaces
    6822/    A6BA : 7B                                  ld    a, e             ; get justification
    6823/    A6BB : FE 45                               cp    'E'              ; left with extension?
    6824/    A6BD : 28 2B                               jr    z, loc_29EA      ; yes, skip
    6825/    A6BF :                                                            ; effectively just print the string as is
    6826/    A6BF : D5                                  push  de               ; save regs
    6827/    A6C0 : C5                                  push  bc
    6828/    A6C1 : CD CD 92                            call  loc_15CD
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 124 - 8/15/2019 11:33:6


    6829/    A6C4 : C1                                  pop   bc
    6830/    A6C5 : D1                                  pop   de
    6831/    A6C6 : 78                                  ld    a, b
    6832/    A6C7 : 96                                  sub   (hl)
    6833/    A6C8 : 47                                  ld    b, a
    6834/    A6C9 : 7B                                  ld    a, e
    6835/    A6CA : FE 4C                               cp    'L'
    6836/    A6CC : 28 0E                               jr    z, loc_29DC
    6837/    A6CE : FE 52                               cp    'R'
    6838/    A6D0 : 28 15                               jr    z, loc_29E7
    6839/    A6D2 : 78                                  ld    a, b
    6840/    A6D3 : CB 38                               srl    b
    6841/    A6D5 : 90                                  sub   b
    6842/    A6D6 :                     
    6843/    A6D6 :                     ; B = cnt for leading spaces
    6844/    A6D6 :                     ; A = cnt for trailing spaces
    6845/    A6D6 :                     print_lead_field_trail:            
    6846/    A6D6 : 08                                  ex    af, af'          ; save count for trailing spaces
    6847/    A6D7 : CD F1 A6                            call  print_b_spaces   ; print spaces, count in B
    6848/    A6DA : 08                                  ex    af, af'          ; restore
    6849/    A6DB :                     print_field_and_trailing:
    6850/    A6DB : 47                                  ld    b, a             ; put cnt for trailing in B
    6851/    A6DC : C5                  loc_29DC:       push  bc
    6852/    A6DD : CD 34 91                            call  straccu_print    ; print the string
    6853/    A6E0 : C1                                  pop   bc
    6854/    A6E1 : CD F1 A6                            call  print_b_spaces   ; print trailing spaces
    6855/    A6E4 : C3 41 A6                            jp    print_mainloop   ; continue with print
    6856/    A6E7 : AF                  loc_29E7:       xor   a                ; cntr for trailing spaces = 0
    6857/    A6E8 : 18 EC                               jr    print_lead_field_trail ; enter printing loop
    6858/    A6EA : 78                  loc_29EA:       ld    a, b             ; get field length
    6859/    A6EB : 96                                  sub   (hl)             ; subtract string length
    6860/    A6EC : 30 ED                               jr    nc, print_field_and_trailing ; if less, store difference
    6861/    A6EE :                                                            ; as cntr for trailing spaces
    6862/    A6EE : AF                                  xor    a               ; otherwise set trailing count = 0
    6863/    A6EF : 18 EA                               jr    print_field_and_trailing ; print the field
    6864/    A6F1 :                     
    6865/    A6F1 : 04                  print_b_spaces: inc   b
    6866/    A6F2 : 05                  loop29F2:       dec   b                ;<+
    6867/    A6F3 : C8                                  ret   z                ; | 
    6868/    A6F4 : CD 64 84                            call  print_space      ; | 
    6869/    A6F7 : 18 F9                               jr    loop29F2         ;-+
    6870/    A6F9 :                     
    6871/    A6F9 :                     ; in USING, print a leading or trailing '+' if D is non-zero
    6872/    A6F9 : F5                  plus_if_D:      push  af               ; save A
    6873/    A6FA : 7A                                  ld    a, d             ; get SIGN flag
    6874/    A6FB : B7                                  or    a
    6875/    A6FC : 3E 2B                               ld    a, CHAR_PLUS     ; if set, print a '+'
    6876/    A6FE : C4 72 84                            call  nz, write_char
    6877/    A701 : F1                                  pop   af               ; restore A
    6878/    A702 : C9                                  ret
    6879/    A703 :                     
    6880/    A703 :                     ; insert a change sign into return stack
    6881/    A703 :                     ; to be called when calling routine returns (for ATN)
    6882/    A703 :                     push_changesign:
    6883/    A703 : 21 D2 9F                            ld    hl, fpaccu_changesign
    6884/    A706 : E3                                  ex    (sp), hl
    6885/    A707 : E9                                  jp    (hl)
    6886/    A708 :                     
    6887/    A708 : 00 00 00 00 00 80   const0_5:       db    0, 0, 0, 0, 0, 80h ; constant 0.5
    6888/    A70E :                     
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 125 - 8/15/2019 11:33:6


    6889/    A70E :                     ; process SQR()
    6890/    A70E : CD DA 9F            math_sqr:       call  push_fpaccu      ; push fpaccu
    6891/    A711 : 21 08 A7                            ld    hl, const0_5     ; get constant
    6892/    A714 : CD EC 9F                            call  mem_to_fpaccu    ; into fpaccu
    6893/    A717 :                     
    6894/    A717 :                     ; pop fpreg off stack and calc power of fpaccu
    6895/    A717 :                     pop_fpreg_and_power:
    6896/    A717 : (MACRO)                             POP_FPREG              ; pop fpreg
    6896/    A717 : C1                                  pop   bc
    6896/    A718 : DD E1                               pop   ix
    6896/    A71A : D1                                  pop   de
    6897/    A71B :                     ; calculate fpreg ^ fpaccu => fpaccu
    6898/    A71B : CD BF 9F            fpaccu_power:   call  fpaccu_sgn       ; get sign of powerexp
    6899/    A71E : 28 44                               jr    z, math_exp      ; is zero, then calculate exp(0) == 1
    6900/    A720 :                                                            ; note: this is inefficient
    6901/    A720 : 78                                  ld    a, b             ; get exponent of base
    6902/    A721 : B7                                  or    a
    6903/    A722 : CA 0F 9D                            jp    z, loc_200F      ; is zero? => result is zero
    6904/    A725 : (MACRO)                             PUSH_FPREG             ; push base again
    6904/    A725 : D5                                  push  de
    6904/    A726 : DD E5                               push  ix
    6904/    A728 : C5                                  push  bc
    6905/    A729 : 79                                  ld    a, c             ; get base
    6906/    A72A : F6 7F                               or    7Fh
    6907/    A72C : CD 02 A0                            call  fpaccu_to_fpreg  ; copy powerexp to fpreg
    6908/    A72F : F2 44 A7                            jp    p, loc_2A44      ; is positive, skip
    6909/    A732 : (MACRO)                             PUSH_FPREG             ; push powerexp
    6909/    A732 : D5                                  push  de
    6909/    A733 : DD E5                               push  ix
    6909/    A735 : C5                                  push  bc
    6910/    A736 : CD AD A0                            call  math_int         ; calculate int(powerexp)
    6911/    A739 : (MACRO)                             POP_FPREG              ; restore powerexp
    6911/    A739 : C1                                  pop   bc
    6911/    A73A : DD E1                               pop   ix
    6911/    A73C : D1                                  pop   de
    6912/    A73D : F5                                  push  af               ; save base sign
    6913/    A73E : CD 36 A0                            call  fpaccu_compare   ; compare INT(powerexp) with powerexp()
    6914/    A741 : E1                                  pop   hl               ; restore base sign
    6915/    A742 : 7C                                  ld    a, h
    6916/    A743 : 1F                                  rra                    ; into CY
    6917/    A744 : E1                  loc_2A44:       pop   hl               ; pop base into fpaccu
    6918/    A745 : 22 6A 0C                            ld    (fpaccu_mant6), hl
    6919/    A748 : E1                                  pop   hl
    6920/    A749 : 22 68 0C                            ld    (fpaccu_mant54), hl
    6921/    A74C : E1                                  pop   hl
    6922/    A74D : 22 66 0C                            ld    (fpaccu_mant32), hl
    6923/    A750 : DC 03 A7                            call  c, push_changesign ; change sign afterwards
    6924/    A753 : CC D2 9F                            call  z, fpaccu_changesign ; change sign now
    6925/    A756 : (MACRO)                             PUSH_FPREG             ; pop powerexp in to fpreg
    6925/    A756 : D5                                  push  de
    6925/    A757 : DD E5                               push  ix
    6925/    A759 : C5                                  push  bc
    6926/    A75A : CD EB 9D                            call  math_log         ; calculate LOG(base)
    6927/    A75D : (MACRO)                             POP_FPREG
    6927/    A75D : C1                                  pop   bc
    6927/    A75E : DD E1                               pop   ix
    6927/    A760 : D1                                  pop   de
    6928/    A761 : CD 3F 9E                            call  multiply_fpreg_fpaccu ; LOG(base)*powerexp
    6929/    A764 :                     
    6930/    A764 :                     ; process EXP()
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 126 - 8/15/2019 11:33:6


    6931/    A764 : (MACRO)             math_exp:       FPREG_CONST 8138h, 0AA3Bh, 295Ch ; get constant 1/LOG(2)
    6931/    A764 : 01 38 81                            ld    bc, 8138H
    6931/    A767 : DD 21 3B AA                         ld    ix, 0AA3BH
    6931/    A76B : 11 5C 29                            ld    de, 295CH
    6932/    A76E : CD 3F 9E                            call  multiply_fpreg_fpaccu ; multiply with fpaccu
    6933/    A771 : 3A 6B 0C                            ld    a, (fpaccu_exp)
    6934/    A774 : FE 88                               cp    88h
    6935/    A776 : D2 80 9F                            jp    nc, loc_2280     ; exponent too large?
    6936/    A779 :                                                            ; if sign is negative, then result
    6937/    A779 :                                                            ; is zero, otherwise overflow error
    6938/    A779 : CD DA 9F                            call  push_fpaccu      ; push arg
    6939/    A77C : CD AD A0                            call  math_int         ; do INT(arg)
    6940/    A77F : (MACRO)                             POP_FPREG              ; pop fpreg
    6940/    A77F : C1                                  pop   bc
    6940/    A780 : DD E1                               pop   ix
    6940/    A782 : D1                                  pop   de
    6941/    A783 : F5                                  push  af               ; save sign
    6942/    A784 : CD 91 9C                            call  subtr_fpreg_fpaccu ; calculate arg - INT(arg)
    6943/    A787 : 21 9E A7                            ld    hl, EXP_poly_tbl ; load coefficient table
    6944/    A78A : CD EA A7                            call  fpaccu_polyeval  ; do polynomial eval
    6945/    A78D : 21 6B 0C                            ld    hl, fpaccu_exp   ; get exponent
    6946/    A790 : F1                                  pop   af               ; restore
    6947/    A791 : B7                                  or    a                ; check for exponent value
    6948/    A792 : FA 97 A7                            jp    m, loc_2A97      ; negative, potential overflow
    6949/    A795 : 86                                  add   a, (hl)          ; add exponent
    6950/    A796 : 01                                  db 1                   ; LD BC, xxxx to skip next 2 instructions
    6951/    A797 :                                                            ; is uncritical because BC will be overwritten
    6952/    A797 : 86                  loc_2A97:       add   a, (hl)          ;** 
    6953/    A798 : 3F                                  ccf                    ;** 
    6954/    A799 : 77                                  ld    (hl), a          ; store resulting exponent
    6955/    A79A : D0                                  ret   nc               ; return result if not overflow
    6956/    A79B : C3 80 9F                            jp    loc_2280         ; overflow
    6957/    A79E :                     
    6958/    A79E : 0A                  EXP_poly_tbl:   db    0Ah
    6959/    A79F : CC D5 45 56 15 6A                   db    0CCh, 0D5h, 45h, 56h, 15h, 6Ah   ; 0.00000014
    6960/    A7A5 : CF 37 A0 92 27 6D                   db    0CFh, 37h, 0A0h, 92h, 27h, 6Dh   ; 0.00000125
    6961/    A7AB : F5 95 EE 93 00 71                   db    0F5h, 95h, 0EEh, 93h, 0, 71h     ; 0.00001533
    6962/    A7B1 : D0 FC A7 78 21 74                   db    0D0h, 0FCh, 0A7h, 78h, 21h, 74h  ; 0.00015399
    6963/    A7B7 : B1 21 82 C4 2E 77                   db    0B1h, 21h, 82h, 0C4h, 2Eh, 77h   ; 0.00133337
    6964/    A7BD : 82 58 58 95 1D 7A                   db    82h, 58h, 58h, 95h, 1Dh, 7Ah     ; 0.00961813
    6965/    A7C3 : 6D CB 46 58 63 7C                   db    6Dh, 0CBh, 46h, 58h, 63h, 7Ch    ; 0.05550411
    6966/    A7C9 : E9 FB EF FD 75 7E                   db    0E9h, 0FBh, 0EFh, 0FDh, 75h, 7Eh ; 0.24022651
    6967/    A7CF : D2 F7 17 72 31 80                   db    0D2h, 0F7h, 17h, 72h, 31h, 80h   ; 0.69314718
    6968/    A7D5 : 00 00 00 00 00 81                   db    0, 0, 0, 0, 0, 81h               ; 1.0
    6969/    A7DB :                     
    6970/    A7DB :                     ; calculate X^2 first and then evaluate
    6971/    A7DB :                     ; polynomial a0*X + a1*X^2 + a2*x^3 + a3*x^4 ...
    6972/    A7DB :                     fpaccu_polyeval_sqr:
    6973/    A7DB : CD DA 9F                            call  push_fpaccu      ; push fpaccu
    6974/    A7DE : 11 3B 9E                            ld    de, pop_fpreg_and_mult ; push routine to multiply at the end
    6975/    A7E1 : D5                                  push  de
    6976/    A7E2 : E5                                  push  hl               ; save HL
    6977/    A7E3 : CD 02 A0                            call  fpaccu_to_fpreg  ; copy to fpreg
    6978/    A7E6 : CD 3F 9E                            call  multiply_fpreg_fpaccu ; calculate square(fpaccu)
    6979/    A7E9 : E1                                  pop   hl               ; restore hl
    6980/    A7EA :                     ; calculate polynomial evaluation
    6981/    A7EA :                     ; a0 + a1*X + a2*X^2 + a3*X^3 ...
    6982/    A7EA :                     ; by Horner's evaluation:
    6983/    A7EA :                     ; ((..a3)*X + a2)*X + a1) * X) + a0
    6984/    A7EA :                     fpaccu_polyeval:            
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 127 - 8/15/2019 11:33:6


    6985/    A7EA : CD DA 9F                            call  push_fpaccu      ; push accu1 again
    6986/    A7ED : 7E                                  ld    a, (hl)          ; get number of coefficients in table
    6987/    A7EE : 23                                  inc   hl               ; point to innermost coefficient
    6988/    A7EF : CD EC 9F                            call  mem_to_fpaccu    ; load into fpaccu
    6989/    A7F2 : FE                                  db    0FEh             ; CP xx to skip next instruction
    6990/    A7F3 :                                                            ; uncritical because flags are never checked
    6991/    A7F3 :                                                            ; restore number of factors
    6992/    A7F3 : F1                  loop2AF3:       pop   af               ;<+ ** only popped on second and following calls
    6993/    A7F4 : (MACRO)                             POP_FPREG              ; | pop fpreg
    6993/    A7F4 : C1                                  pop   bc
    6993/    A7F5 : DD E1                               pop   ix
    6993/    A7F7 : D1                                  pop   de
    6994/    A7F8 : 3D                                  dec   a                ; | complete factors done?
    6995/    A7F9 : C8                                  ret   z                ; | yes, exit
    6996/    A7FA : (MACRO)                             PUSH_FPREG             ; | push X again
    6996/    A7FA : D5                                  push  de
    6996/    A7FB : DD E5                               push  ix
    6996/    A7FD : C5                                  push  bc
    6997/    A7FE : F5                                  push  af               ; | 
    6998/    A7FF : E5                                  push  hl               ; | save HL
    6999/    A800 : CD 3F 9E                            call  multiply_fpreg_fpaccu ; multiply partial product
    7000/    A803 :                                                            ; | ((.(an*X+an-1)*X + an-k) with X
    7001/    A803 : E1                                  pop   hl               ; | restore HL
    7002/    A804 : CD 05 A0                            call  load_fpreg       ; | get next factor an-k-1
    7003/    A807 : E5                                  push  hl               ; | save HL
    7004/    A808 : CD 94 9C                            call  add_fpreg_fpaccu ; | add coefficient
    7005/    A80B : E1                                  pop   hl               ; | restore HL
    7006/    A80C : 18 E5                               jr    loop2AF3         ;-+ loop over all coefficients
    7007/    A80E :                     
    7008/    A80E : CD BF 9F            math_rnd:       call  fpaccu_sgn       ; get sign of argument
    7009/    A811 : FA 35 A8                            jp    m, loc_2B35      ; negative, dont calc 
    7010/    A814 :                                                            ; RND*11879546+0.000392... first
    7011/    A814 : 21 87 0C                            ld    hl, rnd_mant23   ; get current random number into fpaccu
    7012/    A817 : CD EC 9F                            call  mem_to_fpaccu
    7013/    A81A : C8                                  ret   z                ; if argument is 0, return last random number
    7014/    A81B : (MACRO)                             FPREG_CONST 9835h, 447Ah, 0 ; constant 11879546
    7014/    A81B : 01 35 98                            ld    bc, 9835H
    7014/    A81E : DD 21 7A 44                         ld    ix, 447AH
    7014/    A822 : 11 00 00                            ld    de, 0
    7015/    A825 : CD 3F 9E                            call  multiply_fpreg_fpaccu ; multiply with random number
    7016/    A828 : (MACRO)                             FPREG_CONST 6828h, 0B146h, 0 ; constant 3.92767774E-4
    7016/    A828 : 01 28 68                            ld    bc, 6828H
    7016/    A82B : DD 21 46 B1                         ld    ix, 0B146H
    7016/    A82F : 11 00 00                            ld    de, 0
    7017/    A832 : CD 94 9C                            call  add_fpreg_fpaccu ; add to number
    7018/    A835 : CD 02 A0            loc_2B35:       call  fpaccu_to_fpreg  ; copy to fpreg
    7019/    A838 : 7B                                  ld    a, e             ; rotate digits
    7020/    A839 : 59                                  ld    e, c
    7021/    A83A : 4F                                  ld    c, a
    7022/    A83B : 36 80                               ld    (hl), 80h        ; HL points to exponent
    7023/    A83D :                                                            ; set exponent to range 0...1
    7024/    A83D : 2B                                  dec   hl
    7025/    A83E : 46                                  ld    b, (hl)          ; get highest bit of mantissa
    7026/    A83F : 36 80                               ld    (hl), 80h        ; ensure high bit
    7027/    A841 : CD F3 9C                            call  loc_1FF3         ; normalize mantissa
    7028/    A844 : 21 87 0C                            ld    hl, rnd_mant23   ; load address of last random
    7029/    A847 : C3 16 A0                            jp    fpaccu_to_mem    ; copy current random number
    7030/    A84A :                     
    7031/    A84A :                     ; process COS()
    7032/    A84A : 21 9C A8            math_cos:       ld    hl, const_pi_div_2 ; load constant PI/2
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 128 - 8/15/2019 11:33:6


    7033/    A84D : CD 83 9C                            call  load_and_add_fpaccu ; addto argument
    7034/    A850 :                     
    7035/    A850 :                     ; process SIN(X)
    7036/    A850 : CD DA 9F            math_sin:       call  push_fpaccu      ; push fpaccu (X)
    7037/    A853 : (MACRO)                             FPREG_CONST 8349h, 0FDAh, 0A221h ; constant 2*PI
    7037/    A853 : 01 49 83                            ld    bc, 8349H
    7037/    A856 : DD 21 DA 0F                         ld    ix, 0FDAH
    7037/    A85A : 11 21 A2                            ld    de, 0A221H
    7038/    A85D : CD F5 9F                            call  store_fpaccu     ; store in fpaccu
    7039/    A860 : (MACRO)                             POP_FPREG              ; restore X
    7039/    A860 : C1                                  pop   bc
    7039/    A861 : DD E1                               pop   ix
    7039/    A863 : D1                                  pop   de
    7040/    A864 : CD C3 9E                            call  div_fpreg_fpaccu ; divide X / (2*PI)
    7041/    A867 : CD DA 9F                            call  push_fpaccu      ; push X/2PI
    7042/    A86A : CD AD A0                            call  math_int         ; calculate INT part
    7043/    A86D : (MACRO)                             POP_FPREG              ; restore X/2PI
    7043/    A86D : C1                                  pop   bc
    7043/    A86E : DD E1                               pop   ix
    7043/    A870 : D1                                  pop   de
    7044/    A871 : CD 91 9C                            call  subtr_fpreg_fpaccu ; calculate fractional part
    7045/    A874 :                                                            ; (X/2PI) - INT(X/2PI) = XREST
    7046/    A874 : 21 A2 A8                            ld    hl, const_0_25
    7047/    A877 : CD 88 9C                            call  load_fpreg_and_subtr ; calculate 0.25 - XREST
    7048/    A87A : CD BF 9F                            call  fpaccu_sgn       ; check sign
    7049/    A87D : 37                                  scf
    7050/    A87E : F2 88 A8                            jp    p, loc_2B88      ; is smaller than 0.25
    7051/    A881 : CD 80 9C                            call  add_0_5          ; no, add 0.5
    7052/    A884 : CD BF 9F                            call  fpaccu_sgn       ; check sign
    7053/    A887 : B7                                  or    a                ; set sign flag
    7054/    A888 : F5                  loc_2B88:       push  af               ; save it
    7055/    A889 : F4 D2 9F                            call  p, fpaccu_changesign ; was positive? change sign
    7056/    A88C : 21 A2 A8                            ld    hl, const_0_25   ; add constant 0.25
    7057/    A88F : CD 83 9C                            call  load_and_add_fpaccu
    7058/    A892 : F1                                  pop   af               ; restore flag
    7059/    A893 : D4 D2 9F                            call  nc, fpaccu_changesign ; correct sign again
    7060/    A896 : 21 A8 A8                            ld    hl, SIN_poly_tbl ; load SIN coefficient table
    7061/    A899 : C3 DB A7                            jp    fpaccu_polyeval_sqr ; do polynomial eval
    7062/    A89C :                     
    7063/    A89C : 21 A2 DA 0F 49 81   const_pi_div_2: db    21h, 0A2h, 0DAh, 0Fh, 49h, 81h ; constant PI/2
    7064/    A8A2 : 00 00 00 00 00 7F   const_0_25:     db    0, 0, 0, 0, 0, 7Fh    ; constant 0.25
    7065/    A8A8 : 07                  SIN_poly_tbl:   db    7
    7066/    A8A9 : 90 BA 34 76 6A 82                   db    90h, 0BAh, 34h, 76h, 6Ah, 82h    ; 3.66346472
    7067/    A8AF : E4 E9 E7 4B F1 84                   db    0E4h, 0E9h, 0E7h, 4Bh, 0F1h, 84h ; -15.08103172
    7068/    A8B5 : B1 4F 7F 3B 28 86                   db    0B1h, 4Fh, 7Fh, 3Bh, 28h, 86h    ; 42.05517315
    7069/    A8BB : 31 B6 64 69 99 87                   db    31h, 0B6h, 64h, 69h, 99h, 87h     ; -76.70584506
    7070/    A8C1 : E4 36 E3 35 23 87                   db    0E4h, 36h, 0E3h, 35h, 23h, 87h   ; 81.60524913
    7071/    A8C7 : 24 31 E7 5D A5 86                   db    24h, 31h, 0E7h, 5Dh, 0A5h, 86h   ; -41.34170224
    7072/    A8CD : 21 A2 DA 0F 49 83                   db    21h, 0A2h, 0DAh, 0Fh, 49h, 83h   ; 2*PI
    7073/    A8D3 :                     
    7074/    A8D3 :                     ; process TAN(X)
    7075/    A8D3 : CD DA 9F            math_tan:       call  push_fpaccu      ; push fpaccu (X)
    7076/    A8D6 : CD 50 A8                            call  math_sin         ; calculate SIN(X)
    7077/    A8D9 : (MACRO)                             POP_FPREG              ; restore argument again
    7077/    A8D9 : C1                                  pop   bc
    7077/    A8DA : DD E1                               pop   ix
    7077/    A8DC : D1                                  pop   de
    7078/    A8DD : CD DB 9F                            call  push_fpaccu_ex   ; push SIN(X)
    7079/    A8E0 : EB                                  ex    de, hl           ; undo exchange
    7080/    A8E1 : CD F5 9F                            call  store_fpaccu     ; store X
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 129 - 8/15/2019 11:33:6


    7081/    A8E4 : CD 4A A8                            call  math_cos         ; calculate COS(X)
    7082/    A8E7 : C3 BF 9E                            jp    pop_fpreg_and_div ; pop SIN(X) and calc SIN(X)/COS(X)
    7083/    A8EA :                     
    7084/    A8EA :                     ; process ATN()
    7085/    A8EA : CD BF 9F            math_atn:       call  fpaccu_sgn       ; get sign of argument
    7086/    A8ED : FC 03 A7                            call  m, push_changesign ; change sign on return
    7087/    A8F0 : FC D2 9F                            call  m, fpaccu_changesign ; make now positive sign
    7088/    A8F3 : 3A 6B 0C                            ld    a, (fpaccu_exp)  ; is value > 1?
    7089/    A8F6 : FE 81                               cp    81h
    7090/    A8F8 : 38 10                               jr    c, loc_2C0A      ; yes, skip
    7091/    A8FA : 01 00 81                            ld    bc, 8100h        ; load constant 1.0 in fpreg
    7092/    A8FD : DD 21 00 00                         ld    ix, 0
    7093/    A901 : 51                                  ld    d, c
    7094/    A902 : 59                                  ld    e, c
    7095/    A903 : CD C3 9E                            call  div_fpreg_fpaccu ; divide by fpaccu (1/X)
    7096/    A906 : 21 88 9C                            ld    hl, load_fpreg_and_subtr ; push routine to subtract
    7097/    A909 :                                                            ; fpaccu from constant at end
    7098/    A909 : E5                                  push  hl
    7099/    A90A : 21 14 A9            loc_2C0A:       ld    hl, ATN_poly_tbl ; load polynomial table for ATN
    7100/    A90D : CD DB A7                            call  fpaccu_polyeval_sqr
    7101/    A910 : 21 9C A8                            ld    hl, const_pi_div_2 ; constant to subtract from
    7102/    A913 : C9                                  ret
    7103/    A914 :                     
    7104/    A914 : 0D                  ATN_poly_tbl:   db    0Dh              ; count of polynomial parameters
    7105/    A915 : 14 07 BA FE 62 75                   db    14h, 7, 0BAh, 0FEh, 62h, 75h     ; 0.00043296
    7106/    A91B : 51 16 CE D8 D6 78                   db    51h, 16h, 0CEh, 0D8h, 0D6h, 78h  ; -0.00327830
    7107/    A921 : 4C BD 7D D1 3E 7A                   db    4Ch, 0BDh, 7Dh, 0D1h, 3Eh, 7Ah   ; 0.01164663
    7108/    A927 : 01 CB 23 C4 D7 7B                   db    1, 0CBh, 23h, 0C4h, 0D7h, 7Bh    ; -0.02633864
    7109/    A92D : DC 3A 0A 17 34 7C                   db    0DCh, 3Ah, 0Ah, 17h,    34h, 7Ch ; 0.04396729
    7110/    A933 : 36 C1 A3 81 F7 7C                   db    36h, 0C1h, 0A3h, 81h, 0F7h, 7Ch  ; -0.06042637
    7111/    A939 : EB 16 61 AE 19 7D                   db    0EBh, 16h, 61h, 0AEh, 19h, 7Dh   ; 0.07503963
    7112/    A93F : 5D 78 8F 60 B9 7D                   db    5Dh, 78h, 8Fh, 60h, 0B9h, 7Dh    ; -0.09051621
    7113/    A945 : A2 44 12 72 63 7D                   db    0A2h, 44h, 12h, 72h, 63h, 7Dh    ; 0.11105742
    7114/    A94B : 16 62 FB 47 92 7E                   db    16h, 62h, 0FBh, 47h, 92h, 7Eh    ; -0.14285271
    7115/    A951 : C0 F0 BF CC 4C 7E                   db    0C0h, 0F0h, 0BFh, 0CCh, 4Ch, 7Eh ; 0.19999981
    7116/    A957 : 7E 8E AA AA AA 7F                   db    7Eh, 8Eh, 0AAh, 0AAh, 0AAh, 7Fh  ; -0.33333333
    7117/    A95D : F6 FF FF FF 7F 80                   db    0F6h, 0FFh, 0FFh, 0FFh, 7Fh, 80h ; 1.0
    7118/    A963 :                     				
    7119/    A963 :                     				
    7120/    A963 :                     				
    7121/    A963 : 45 4E C4            token_tbl:      db    'E', 'N', 'D'+80h                ; token 0x80
    7122/    A966 : 46 4F D2                            db    'F', 'O', 'R'+80h                ; token 0x81
    7123/    A969 : 4E 45 58 D4                         db    'N', 'E', 'X', 'T'+80h           ; token 0x82
    7124/    A96D : 44 41 54 C1                         db    'D', 'A', 'T', 'A'+80h           ; token 0x83
    7125/    A971 : 49 4E 50 55 D4                      db    'I', 'N', 'P', 'U', 'T'+80h      ; token 0x84
    7126/    A976 : 44 49 CD                            db    'D', 'I', 'M'+80h                ; token 0x85
    7127/    A979 : 52 45 41 C4                         db    'R', 'E', 'A', 'D'+80h           ; token 0x86
    7128/    A97D : 4C 45 D4                            db    'L', 'E', 'T'+80h                ; token 0x87
    7129/    A980 : 47 4F 20 54 CF                      db    'G', 'O', ' ', 'T', 'O'+80h      ; token 0x88
    7130/    A985 : 46 4E 45 4E C4                      db    'F', 'N', 'E', 'N', 'D'+80h      ; token 0x89
    7131/    A98A : 49 C6                               db    'I', 'F'+80h                     ; token 0x8a
    7132/    A98C : 52 45 53 54 4F 52                   db    'R', 'E', 'S', 'T', 'O', 'R', 'E'+80h ; token 0x8b
                    C5 
    7133/    A993 : 47 4F 20 53 55 C2                   db    'G', 'O', ' ', 'S', 'U', 'B'+80h ; token 0x8c
    7134/    A999 : 52 45 54 55 52 CE                   db    'R', 'E', 'T', 'U', 'R', 'N'+80h ; token 0x8d
    7135/    A99F : 52 45 CD                            db    'R', 'E', 'M'+80h                ; token 0x8e
    7136/    A9A2 : 53 54 4F D0                         db    'S', 'T', 'O', 'P'+80h           ; token 0x8f
    7137/    A9A6 : 4F 55 D4                            db    'O', 'U', 'T'+80h                ; token 0x90
    7138/    A9A9 : 4F CE                               db    'O', 'N'+80h                     ; token 0x91
    7139/    A9AB : 4E 55 4C CC                         db    'N', 'U', 'L', 'L'+80h           ; token 0x92
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 130 - 8/15/2019 11:33:6


    7140/    A9AF : 57 41 49 D4                         db    'W', 'A', 'I', 'T'+80h           ; token 0x93
    7141/    A9B3 : 44 45 C6                            db    'D', 'E', 'F'+80h                ; token 0x94
    7142/    A9B6 : 50 4F 4B C5                         db    'P', 'O', 'K', 'E'+80h           ; token 0x95
    7143/    A9BA : 50 52 49 4E D4                      db    'P', 'R', 'I', 'N', 'T'+80h      ; token 0x96
    7144/    A9BF : BF                                  db    '?'+80h                          ; token 0x97
    7145/    A9C0 : 4C 49 53 54 45 CE                   db    'L', 'I', 'S', 'T', 'E', 'N'+80h ; token 0x98
    7146/    A9C6 : 43 4C 45 41 D2                      db    'C', 'L', 'E', 'A', 'R'+80h      ; token 0x99
    7147/    A9CB : 46 4E 52 45 54 55                   db    'F', 'N', 'R', 'E', 'T', 'U', 'R', 'N'+80h ; token 0x9a
                    52 CE 
    7148/    A9D3 : 53 41 56 C5                         db    'S', 'A', 'V', 'E'+80h           ; token 0x9b
    7149/    A9D7 : A1                                  db    '!'+80h                          ; token 0x9c
    7150/    A9D8 : 55 53 49 4E C7                      db    'U', 'S', 'I', 'N', 'G'+80h      ; token 0x9d
    7151/    A9DD : 54 41 42 A8                         db    'T', 'A', 'B', '('+80h           ; token 0x0e
    7152/    A9E1 : 54 CF                               db    'T', 'O'+80h                     ; token 0x9f
    7153/    A9E3 : 46 CE                               db    'F', 'N'+80h                     ; token 0xa0
    7154/    A9E5 : 53 50 43 A8                         db    'S', 'P', 'C', '('+80h           ; token 0xa1
    7155/    A9E9 : 54 48 45 CE                         db    'T', 'H', 'E', 'N'+80h           ; token 0xa2
    7156/    A9ED : 4E 4F D4                            db    'N', 'O', 'T'+80h                ; token 0xa3
    7157/    A9F0 : 53 54 45 D0                         db    'S', 'T', 'E', 'P'+80h           ; token 0xa4
    7158/    A9F4 : AB                                  db    '+'+80h                          ; token 0xa5
    7159/    A9F5 : AD                                  db    '-'+80h                          ; token 0xa6
    7160/    A9F6 : AA                                  db    '*'+80h                          ; token 0xa7
    7161/    A9F7 : AF                                  db    '/'+80h                          ; token 0xa8
    7162/    A9F8 : DE                                  db    '^'+80h                          ; token 0xa9
    7163/    A9F9 : 41 4E C4                            db    'A', 'N', 'D'+80h                ; token 0xaa
    7164/    A9FC : 4F D2                               db    'O', 'R'+80h                     ; token 0xab
    7165/    A9FE : BE                                  db    '>'+80h                          ; token 0xac
    7166/    A9FF : BD                                  db    '='+80h                          ; token 0xad
    7167/    AA00 : BC                                  db    '<'+80h                          ; token 0xae
    7168/    AA01 : 53 47 CE                            db    'S', 'G', 'N'+80h                ; token 0xaf
    7169/    AA04 : 49 4E D4                            db    'I', 'N', 'T'+80h                ; token 0xb0
    7170/    AA07 : 41 42 D3                            db    'A', 'B', 'S'+80h                ; token 0xb1
    7171/    AA0A : 55 53 D2                            db    'U', 'S', 'R'+80h                ; token 0xb2
    7172/    AA0D : 46 52 C5                            db    'F', 'R', 'E'+80h                ; token 0xb3
    7173/    AA10 : 49 4E D0                            db    'I', 'N', 'P'+80h                ; token 0xb4
    7174/    AA13 : 50 4F D3                            db    'P', 'O', 'S'+80h                ; token 0xb5
    7175/    AA16 : 53 51 D2                            db    'S', 'Q', 'R'+80h                ; token 0xb6
    7176/    AA19 : 52 4E C4                            db    'R', 'N', 'D'+80h                ; token 0xb7
    7177/    AA1C : 4C 4F C7                            db    'L', 'O', 'G'+80h                ; token 0xb8
    7178/    AA1F : 45 58 D0                            db    'E', 'X', 'P'+80h                ; token 0xb9
    7179/    AA22 : 43 4F D3                            db    'C', 'O', 'S'+80h                ; token 0xba
    7180/    AA25 : 53 49 CE                            db    'S', 'I', 'N'+80h                ; token 0xbb
    7181/    AA28 : 54 41 CE                            db    'T', 'A', 'N'+80h                ; token 0xbc
    7182/    AA2B : 41 54 CE                            db    'A', 'T', 'N'+80h                ; token 0xbd
    7183/    AA2E : 50 45 45 CB                         db    'P', 'E', 'E', 'K'+80h           ; token 0xbe
    7184/    AA32 : 4C 45 CE                            db    'L', 'E', 'N'+80h                ; token 0xbf
    7185/    AA35 : 53 54 52 A4                         db    'S', 'T', 'R', '$'+80h           ; token 0xc0
    7186/    AA39 : 56 41 CC                            db    'V', 'A', 'L'+80h                ; token 0xc1
    7187/    AA3C : 41 53 C3                            db    'A', 'S', 'C'+80h                ; token 0xc2
    7188/    AA3F : 43 48 52 A4                         db    'C', 'H', 'R', '$'+80h           ; token 0xc3
    7189/    AA43 : 4C 45 46 54 A4                      db    'L', 'E', 'F', 'T', '$'+80h      ; token 0xc4
    7190/    AA48 : 52 49 47 48 54 A4                   db    'R', 'I', 'G', 'H', 'T', '$'+80h ; token 0xc5
    7191/    AA4E : 4D 49 44 A4                         db    'M', 'I', 'D', '$'+80h           ; token 0xc6
    7192/    AA52 : 4C 50 4F D3                         db    'L', 'P', 'O', 'S'+80h           ; token 0xc7
    7193/    AA56 : 49 4E 53 54 D2                      db    'I', 'N', 'S', 'T', 'R'+80h      ; token 0xc8
    7194/    AA5B : 45 4C 53 C5                         db    'E', 'L', 'S', 'E'+80h           ; token 0xc9
    7195/    AA5F : 4C 50 52 49 4E D4                   db    'L', 'P', 'R', 'I', 'N', 'T'+80h ; token 0xca
    7196/    AA65 : 54 52 41 43 C5                      db    'T', 'R', 'A', 'C', 'E'+80h      ; token 0xcb
    7197/    AA6A : 4C 54 52 41 43 C5                   db    'L', 'T', 'R', 'A', 'C', 'E'+80h ; token 0xcc
    7198/    AA70 : 52 41 4E 44 4F 4D                   db    'R', 'A', 'N', 'D', 'O', 'M', 'I', 'Z', 'E'+80h ; token 0xcd
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 131 - 8/15/2019 11:33:6


                    49 5A C5 
    7199/    AA79 : 53 57 49 54 43 C8                   db    'S', 'W', 'I', 'T', 'C', 'H'+80h ; token 0xce
    7200/    AA7F : 4C 57 49 44 54 C8                   db    'L', 'W', 'I', 'D', 'T', 'H'+80h ; token 0xcf
    7201/    AA85 : 4C 4E 55 4C CC                      db    'L', 'N', 'U', 'L', 'L'+80h      ; token 0xd0
    7202/    AA8A : 57 49 44 54 C8                      db    'W', 'I', 'D', 'T', 'H'+80h      ; token 0xd1
    7203/    AA8F : 4C 56 41 D2                         db    'L', 'V', 'A', 'R'+80h           ; token 0xd2
    7204/    AA93 : 4C 4C 56 41 D2                      db    'L', 'L', 'V', 'A', 'R'+80h      ; token 0xd3
    7205/    AA98 : 53 50 45 41 CB                      db    'S', 'P', 'E', 'A', 'K'+80h      ; token 0xd4
    7206/    AA9D : A7                                  db    27h+80h                          ; "tic" token 0xd5
    7207/    AA9E : 50 52 45 43 49 53                   db    'P', 'R', 'E', 'C', 'I', 'S', 'I', 'O', 'N'+80h ; token 0xd6
                    49 4F CE 
    7208/    AAA7 : 43 41 4C CC                         db    'C', 'A', 'L', 'L'+80h           ; token 0xd7
    7209/    AAAB : 4B 49 4C CC                         db    'K', 'I', 'L', 'L'+80h           ; token 0xd8
    7210/    AAAF : 45 58 43 48 41 4E                   db    'E', 'X', 'C', 'H', 'A', 'N', 'G', 'E'+80h ; token 0xd9
                    47 C5 
    7211/    AAB7 : 4C 49 4E C5                         db    'L', 'I', 'N', 'E'+80h           ; token 0xda
    7212/    AABB : 4C 4F 41 44 47 CF                   db    'L', 'O', 'A', 'D', 'G', 'O'+80h ; token 0xdb
    7213/    AAC1 : 52 55 CE                            db    'R', 'U', 'N'+80h                ; token 0xdc
    7214/    AAC4 : 4C 4F 41 C4                         db    'L', 'O', 'A', 'D'+80h           ; token 0xdd
    7215/    AAC8 : 4E 45 D7                            db    'N', 'E', 'W'+80h                ; token 0xde
    7216/    AACB : 41 55 54 CF                         db    'A', 'U', 'T', 'O'+80h           ; token 0xdf
    7217/    AACF : 43 4F 50 D9                         db    'C', 'O', 'P', 'Y'+80h           ; token 0xe0
    7218/    AAD3 : 41 4C 4F 41 44 C3                   db    'A', 'L', 'O', 'A', 'D', 'C'+80h ; token 0xe1
    7219/    AAD9 : 41 4D 45 52 47 45                   db    'A', 'M', 'E', 'R', 'G', 'E', 'C'+80h ; token 0xe2
                    C3 
    7220/    AAE0 : 41 4C 4F 41 C4                      db    'A', 'L', 'O', 'A', 'D'+80h      ; token 0xe3
    7221/    AAE5 : 41 4D 45 52 47 C5                   db    'A', 'M', 'E', 'R', 'G', 'E'+80h ; token 0xe4
    7222/    AAEB : 41 53 41 56 C5                      db    'A', 'S', 'A', 'V', 'E'+80h      ; token 0xe5
    7223/    AAF0 : 4C 49 53 D4                         db    'L', 'I', 'S', 'T'+80h           ; token 0xe6
    7224/    AAF4 : 4C 4C 49 53 D4                      db    'L', 'L', 'I', 'S', 'T'+80h      ; token 0xe7
    7225/    AAF9 : 52 45 4E 55 4D 42                   db    'R', 'E', 'N', 'U', 'M', 'B', 'E', 'R'+80h ; token 0xe8
                    45 D2 
    7226/    AB01 : 44 45 4C 45 54 C5                   db    'D', 'E', 'L', 'E', 'T', 'E'+80h ; token 0xe9
    7227/    AB07 : 45 44 49 D4                         db    'E', 'D', 'I', 'T'+80h           ; token 0xea
    7228/    AB0B : 43 4F 4E D4                         db    'C', 'O', 'N', 'T'+80h           ; token 0xeb
    7229/    AB0F : 00                                  db    0
    7230/    AB10 :                     serial:         ;dw    1234h            ; serial number
    7231/    AB10 : 7C 53               		dw	21372
    7232/    AB12 : 4E 45 58 54 20 57   e_next_wo_for:  db    'N', 'E', 'X', 'T', ' ', 'W', '/', 'O', ' ', 'F', 'O', 'R'+80h
                    2F 4F 20 46 4F D2 
    7233/    AB1E : 53 59 4E 54 41 58   e_syntax_error: db    'S', 'Y', 'N', 'T', 'A', 'X', ' ', 'E', 'R', 'R', 'O', 'R'+80h
                    20 45 52 52 4F D2 
    7234/    AB2A : 52 45 54 55 52 4E   ret_wo_gosub:   db    'R', 'E', 'T', 'U', 'R', 'N', ' ', 'W', '/', 'O', ' '
                    20 57 2F 4F 20 
    7235/    AB35 : 47 4F 53 55 C2                      db    'G', 'O', 'S', 'U', 'B'+80h
    7236/    AB3A : 4F 55 54 20 4F 46   e_out_of_data:  db    'O', 'U', 'T', ' ', 'O', 'F', ' ', 'D', 'A', 'T', 'A'+80h
                    20 44 41 54 C1 
    7237/    AB45 : 49 4C 4C 45 47 41   e_ill_func:     db    'I', 'L', 'L', 'E', 'G', 'A', 'L', ' ', 'F', 'U', 'N'
                    4C 20 46 55 4E 
    7238/    AB50 : 43 54 49 4F CE                      db    'C', 'T', 'I', 'O', 'N'+80h
    7239/    AB55 : 41 52 49 54 48 4D   e_arith_ov:     db    'A', 'R', 'I', 'T', 'H', 'M', 'E', 'T', 'I', 'C', ' '
                    45 54 49 43 20 
    7240/    AB60 : 4F 56 45 52 46 4C                   db    'O', 'V', 'E', 'R', 'F', 'L', 'O', 'W'+80h
                    4F D7 
    7241/    AB68 : 4F 55 54 20 4F 46   e_out_of_mem:   db    'O', 'U', 'T', ' ', 'O', 'F', ' ', 'M', 'E', 'M', 'O', 'R', 'Y'+80h
                    20 4D 45 4D 4F 52 
                    D9 
    7242/    AB75 : 55 4E 44 45 46 49   e_undef_stmt:   db    'U', 'N', 'D', 'E', 'F', 'I', 'N', 'E', 'D', ' ', 'S'
                    4E 45 44 20 53 
    7243/    AB80 : 54 41 54 45 4D 45                   db    'T', 'A', 'T', 'E', 'M', 'E', 'N', 'T', 20h+80h
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 132 - 8/15/2019 11:33:6


                    4E 54 A0 
    7244/    AB89 : 53 55 42 53 43 52   e_subscr_range: db    'S', 'U', 'B', 'S', 'C', 'R', 'I', 'P', 'T', ' ', 'O'
                    49 50 54 20 4F 
    7245/    AB94 : 55 54 20 4F 46 20                   db    'U', 'T', ' ', 'O', 'F', ' ', 'R', 'A', 'N', 'G', 'E'+80h
                    52 41 4E 47 C5 
    7246/    AB9F : 52 45 2D 44 49 4D   e_redim_array:  db    'R', 'E', '-', 'D', 'I', 'M', 'E', 'N', 'S', 'I', 'O'
                    45 4E 53 49 4F 
    7247/    ABAA : 4E 45 44 20 41 52                   db    'N', 'E', 'D', ' ', 'A', 'R', 'R', 'A', 'Y'+80h
                    52 41 D9 
    7248/    ABB3 : 43 41 4E 27 54 20   e_div0:         db    'C', 'A', 'N', 27h, 'T', ' ', '/', '0'+80h
                    2F B0 
    7249/    ABBB : 49 4C 4C 45 47 41   e_ill_direct:   db    'I', 'L', 'L', 'E', 'G', 'A', 'L', ' ', 'D', 'I', 'R'
                    4C 20 44 49 52 
    7250/    ABC6 : 45 43 D4                            db    'E', 'C', 'T'+80h
    7251/    ABC9 : 54 59 50 45 20 4D   e_type_mis:     db    'T', 'Y', 'P', 'E', ' ', 'M', 'I', 'S', '-', 'M', 'A'
                    49 53 2D 4D 41 
    7252/    ABD4 : 54 43 C8                            db    'T', 'C', 'H'+80h
    7253/    ABD7 : 4E 4F 20 53 54 52   e_no_string:    db    'N', 'O', ' ', 'S', 'T', 'R', 'I', 'N', 'G', ' ', 'S'
                    49 4E 47 20 53 
    7254/    ABE2 : 50 41 43 C5                         db    'P', 'A', 'C', 'E'+80h
    7255/    ABE6 : 53 54 52 49 4E 47   e_stringlong:   db    'S', 'T', 'R', 'I', 'N', 'G', ' ', 'T', 'O', 'O', ' '
                    20 54 4F 4F 20 
    7256/    ABF1 : 4C 4F 4E C7                         db    'L', 'O', 'N', 'G'+80h
    7257/    ABF5 : 54 4F 4F 20 43 4F   e_complex:      db    'T', 'O', 'O', ' ', 'C', 'O', 'M', 'P', 'L', 'E', 'X'+80h
                    4D 50 4C 45 D8 
    7258/    AC00 : 43 41 4E 27 54 20   e_cant_cont:    db    'C', 'A', 'N', 27h, 'T', ' ', 'C', 'O', 'N', 'T', 'I'
                    43 4F 4E 54 49 
    7259/    AC0B : 4E 55 C5                            db    'N', 'U', 'E'+80h
    7260/    AC0E : 55 4E 44 45 46 49   e_usercall:     db    'U', 'N', 'D', 'E', 'F', 'I', 'N', 'E', 'D', ' ', 'U'
                    4E 45 44 20 55 
    7261/    AC19 : 53 45 52 20 43 41                   db    'S', 'E', 'R', ' ', 'C', 'A', 'L', 'L'+80h
                    4C CC 
    7262/    AC21 : 46 49 4C 45 20 4E   e_file_n_found: db    'F', 'I', 'L', 'E', ' ', 'N', 'O', 'T', ' ', 'F', 'O'
                    4F 54 20 46 4F 
    7263/    AC2C : 55 4E C4                            db    'U', 'N', 'D'+80h
    7264/    AC2F : 49 4C 4C 45 47 41   e_ill_eof:      db    'I', 'L', 'L', 'E', 'G', 'A', 'L', ' ', 'E', 'O', 'F'+80h
                    4C 20 45 4F C6 
    7265/    AC3A : 46 49 4C 45 53 20   e_files_differ: db    'F', 'I', 'L', 'E', 'S', ' ', 'D', 'I', 'F', 'F', 'E'
                    44 49 46 46 45 
    7266/    AC45 : 52 45 4E D4                         db    'R', 'E', 'N', 'T'+80h
    7267/    AC49 : 52 45 43 4F 56 45   e_recover:      db    'R', 'E', 'C', 'O', 'V', 'E', 'R', 'E', 'D'+80h
                    52 45 C4 
    7268/    AC52 : 46 4E 52 45 54 55   e_fnreturn:     db    'F', 'N', 'R', 'E', 'T', 'U', 'R', 'N', ' ', 'W', '/'
                    52 4E 20 57 2F 
    7269/    AC5D : 4F 20 46 55 4E 43                   db    'O', ' ', 'F', 'U', 'N', 'C', 'T', 'I', 'O', 'N', ' '
                    54 49 4F 4E 20 
    7270/    AC68 : 43 41 4C CC                         db    'C', 'A', 'L', 'L'+80h
    7271/    AC6C : 4D 49 53 53 49 4E   e_miss_stmt:    db    'M', 'I', 'S', 'S', 'I', 'N', 'G', ' ', 'S', 'T', 'A'
                    47 20 53 54 41 
    7272/    AC77 : 54 45 4D 45 4E 54                   db    'T', 'E', 'M', 'E', 'N', 'T', ' ', 'N', 'U', 'M', 'B', 'E', 'R'+80h
                    20 4E 55 4D 42 45 
                    D2 
    7273/    AC84 : 2A 49 4E 56 41 4C   a_invalid_input:db    '*', 'I', 'N', 'V', 'A', 'L', 'I', 'D', ' ', 'I', 'N'
                    49 44 20 49 4E 
    7274/    AC8F : 50 55 54 8A                         db    'P', 'U', 'T', CHAR_LF+80h
    7275/    AC93 : 20 40 20 4C 49 4E   a_at_line:      db    ' ', '@', ' ', 'L', 'I', 'N', 'E', 20h+80h
                    45 A0 
    7276/    AC9B : 0A 52 45 41 44 59   a_ready:        db    CHAR_LF, 'R', 'E', 'A', 'D', 'Y', ':', CHAR_LF+80h
                    3A 8A 
    7277/    ACA3 : 2A 45 58 54 52 41   a_extralost:    db    '*', 'E', 'X', 'T', 'R', 'A', ' ', 'L', 'O', 'S', 'T', CHAR_LF+80h
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 133 - 8/15/2019 11:33:6


                    20 4C 4F 53 54 8A 
    7278/    ACAF : 0A 2A 42 52 45 41   a_break:        db    CHAR_LF, '*', 'B', 'R', 'E', 'A', 'K'+80h
                    CB 
    7279/    ACB6 : 00                                  db    0
    7280/    ACB7 :                     ;
    7281/    ACB7 :                     ; Start of disposable part of BASIC
    7282/    ACB7 :                     ;
    7283/    ACB7 :                     ; COLD START ENTRY POINT, initialize everything
    7284/    ACB7 : AF                  coldstart:      xor    a               ; clear A, and CY
    7285/    ACB8 : 21 00 0C                            ld    hl, iosuppress   ; start of program variables
    7286/    ACBB : 3F                  loc_2FCD:       ccf                    ; set CY
    7287/    ACBC : 77                  loc_2FCE:       ld    (hl), a          ; clear cell
    7288/    ACBD : 2C                                  inc   l                ; next cell
    7289/    ACBE : 20 FC                               jr    nz, loc_2FCE     ; no CY?, loop
    7290/    ACC0 : 24                                  inc   h                ; increment H
    7291/    ACC1 : 38 F8                               jr    c, loc_2FCD      ; was CY set, yes clear, and loop again
    7292/    ACC3 :                                                            ; effectively: clear memory range from 0100-02ff
    7293/    ACC3 : 2B                                  dec   hl               ; HL is 0300, decrement
    7294/    ACC4 : F9                                  ld    sp, hl           ; initialize stack
    7295/    ACC5 : 22 5A 0C                            ld    (string_base), hl ; save stacktop
    7296/    ACC8 : 21 FF FF                            ld    hl, 0FFFFh       ; set lineno to invalid
    7297/    ACCB : 22 54 0C                            ld    (lineno), hl
    7298/    ACCE : 3E 2C                               ld    a, CHAR_COMMA    ; comma
    7299/    ACD0 : 32 B0 0C                            ld    (inputbuf-1), a  ; store
    7300/    ACD3 : 3E C3                               ld    a, 0C3h          ; JP instruction
    7301/    ACD5 : 32 8D 0C                            ld    (outputvector), a ; store in output vector
    7302/    ACD8 : 32 A4 0C                            ld    (coldvector), a
    7303/    ACDB : 21 B7 AC                            ld    hl, coldstart    ; address of coldstart
    7304/    ACDE : 22 A5 0C                            ld    (cold_addr), hl  ; store it
    7305/    ACE1 : FD 21 90 0C                         ld    iy, conparam     ; point to console parameter structure
    7306/    ACE5 : 21 0F 80                            ld    hl, CONSOLEOUT
    7307/    ACE8 : 22 8E 0C                            ld    (output_addr), hl ; set output vector to console
    7308/    ACEB : 3E 3F                               ld    a, 63            ; set line length to 72
    7309/    ACED : 32 91 0C                            ld    (conparam+ioparams_linelength), a ; store in console parameter set
    7310/    ACF0 : 32 96 0C                            ld    (prtparam+ioparams_linelength), a ; store in printer parameter set
    7311/    ACF3 : 3E 38                               ld    a, 56            ; position of last complete print field
    7312/    ACF5 :                                                            ; print length is 14
    7313/    ACF5 :                                                            ; i.e. positions are 0,14,28,42,56
    7314/    ACF5 : 32 92 0C                            ld    (conparam+ioparams_last_field), a ; store in console parameter set
    7315/    ACF8 : 32 97 0C                            ld    (prtparam+ioparams_last_field), a ; store in printer parameter set
    7316/    ACFB : 21 08 0C                            ld    hl, stringstk    ; HL is addr of exprstack
    7317/    ACFE : 22 06 0C                            ld    (stringstkptr), hl ; store ptr
    7318/    AD01 : 21 00 80                            ld    hl, 8000h            ; clear HL
    7319/    AD04 : 22 87 0C                            ld    (rnd_mant23), hl
    7320/    AD07 : 22 89 0C                            ld    (rnd_mant45), hl
    7321/    AD0A : 22 8B 0C                            ld    (rndmant6_exp), hl
    7322/    AD0D : 21 92 AD                            ld    hl, highmem_msg  ; print "highest memory" message
    7323/    AD10 : CD BD 84                            call  print_string
    7324/    AD13 : CD E2 83                            call  get_input        ; get an input line
    7325/    AD16 : CD 47 86                            call  nextchar         ; advance to find a number
    7326/    AD19 : 20 05                               jr    nz, loc_3048     ; no, continue processing
    7327/    AD1B :                     ; use memsize function get get max memory
    7328/    AD1B : CD 21 80                            call  MEMSIZE          ; get the available memory size in B,A (high,low)
    7329/    AD1E : 18 14                               jr    has_memsize      ; continue initializing
    7330/    AD20 : 21 B1 0C            loc_3048:       ld    hl, inputbuf     ; point to inputbuf
    7331/    AD23 : CD 48 86                            call  skipspace        ; skip space
    7332/    AD26 : CD DE A0                            call  parse_number_fpaccu ; pack number in fpaccu
    7333/    AD29 : 7E                                  ld    a, (hl)          ; get next char
    7334/    AD2A : B7                                  or    a                ; not end of buf?
    7335/    AD2B : C2 6D 81                            jp    nz, syntax_error ; oops, don't accept this
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 134 - 8/15/2019 11:33:6


    7336/    AD2E : CD 27 87                            call  fpaccu_to_u16    ; convert to u16 number in DE
    7337/    AD31 : EB                                  ex    de, hl           ; move to HL
    7338/    AD32 : 2B                                  dec   hl               ; subtract 2 (end of memory)
    7339/    AD33 : 2B                                  dec   hl
    7340/    AD34 : 22 04 0C            has_memsize:    ld    (memory_top), hl ; memory size in HL
    7341/    AD37 : 22 48 0C                            ld    (string_top), hl
    7342/    AD3A : E5                                  push  hl               ; save size
    7343/    AD3B : 11 00 03                            ld    de, 300h         ; load base of memory
    7344/    AD3E : B7                                  or    a                ; clear CY
    7345/    AD3F : ED 52                               sbc   hl, de           ; less than 0x300?
    7346/    AD41 : E1                                  pop   hl
    7347/    AD42 : DA 4D 81            loc_306A:       jp    c, out_of_memory_error ; too few memory
    7348/    AD45 : 11 9C FF                            ld    de, -100         ; subtract 100
    7349/    AD48 : 19                                  add   hl, de
    7350/    AD49 : 11 00 03                            ld    de, 300h         ; subtract 0x300
    7351/    AD4C : (MACRO)                             CPHL_DE   
    7351/    AD4C : 7C                                  ld    a, h
    7351/    AD4D : 92                                  sub   d
    7351/    AD4E : 20 02                               jr    nz, m1
    7351/    AD50 : 7D                                  ld    a, l
    7351/    AD51 : 93                                  sub   e
    7351/    AD52 :                     m1:
    7352/    AD52 : 11 01 10                            ld    de, 1001h ; start of disposable coldstart area
    7353/    AD55 : 30 03                               jr    nc, loc_3082     ; larger than 0x300?
    7354/    AD57 : 11 00 03                            ld    de, 300h         ; reserve space for stack
    7355/    AD5A : (MACRO)             loc_3082:       CPHL_DE                ; at least enough memory for BASIC itself?
    7355/    AD5A : 7C                                  ld    a, h
    7355/    AD5B : 92                                  sub   d
    7355/    AD5C : 20 02                               jr    nz, m1
    7355/    AD5E : 7D                                  ld    a, l
    7355/    AD5F : 93                                  sub   e
    7355/    AD60 :                     m1:
    7356/    AD60 : 38 E0                               jr    c, loc_306A      ; out of memory
    7357/    AD62 : F9                                  ld    sp, hl           ; put stack below top of memory
    7358/    AD63 : 22 5A 0C                            ld    (string_base), hl
    7359/    AD66 : EB                                  ex    de, hl           ; top - 0x300
    7360/    AD67 : 22 5C 0C                            ld    (start_memory), hl ; lowest memory usable
    7361/    AD6A : CD 3E 81                            call  check_memfree    ; verify still enough stack space
    7362/    AD6D : B7                                  or    a
    7363/    AD6E : EB                                  ex    de, hl
    7364/    AD6F : ED 52                               sbc   hl, de           ; calculate difference
    7365/    AD71 : 01 F0 FF                            ld    bc, -16          ; reserve 16 more bytes
    7366/    AD74 : 09                                  add   hl, bc
    7367/    AD75 : CD EE 89                            call  print_crlf       ; do CRLF
    7368/    AD78 : CD C9 A1                            call  print_HL         ; print number in HL
    7369/    AD7B : 21 A1 AD                            ld    hl, bytes_free_msg ; print bytes free message
    7370/    AD7E : CD BD 84                            call  print_string
    7371/    AD81 : 21 BD 84                            ld    hl, print_string
    7372/    AD84 : 22 A5 0C                            ld    (cold_addr), hl  ; put into cold addr (coldstart is now disposed)
    7373/    AD87 : 3E 00                               ld	a,0
    7374/    AD89 : 32 00 10                            ld	(1000h),a
    7375/    AD8C : CD B4 82                            call  new_memory       ; enter interpreter loop
    7376/    AD8F : C3 A0 81                            jp    print_prompt     ; main loop
    7377/    AD92 :                     				
    7378/    AD92 : 0A 48 49 47 48 45   highmem_msg:    db    CHAR_LF, 'H', 'I', 'G', 'H', 'E', 'S', 'T', ' ', 'M', 'E', 'M'
                    53 54 20 4D 45 4D 
    7379/    AD9E : 4F 52 D9                            DB    'O', 'R', 'Y'+80H
    7380/    ADA1 : 20 42 59 54 45 53   bytes_free_msg: DB    ' ', 'B', 'Y', 'T', 'E', 'S', ' ', 'F', 'R', 'E', 'E', CHAR_LF
                    20 46 52 45 45 0A 
    7381/    ADAD : 0A 8A               		db	CHAR_LF,CHAR_LF+80h
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 135 - 8/15/2019 11:33:6


    7382/    ADAF : 20 20 20 20 20 20   		db "                                                            "
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
                    20 20 20 20 20 20 
    7383/    ADEB : 20 20 20 20 20 20                   db "        ",8Ah
                    20 20 8A 
    7384/    ADF4 : 00                                  db    0
    7385/    ADF5 : 00                                  db    0
    7386/    ADF6 : 00                                  db    0
    7387/    ADF7 : 00                                  db    0
    7388/    ADF8 :                     
    7389/    ADF8 :                     ;patch
    7390/    ADF8 : 4F                  loc_ADF8:	ld      c, a
    7391/    ADF9 : AF                  		xor     a
    7392/    ADFA : BE                  		cp      (hl)
    7393/    ADFB : 79                  		ld      a, c
    7394/    ADFC : C1                  		pop     bc
    7395/    ADFD : C3 61 98            		jp      loc_9861
    7396/    AE00 :                     
    7397/    AE00 :                     ;get highest memory
    7398/    AE00 : 21 00 10            sub_AE00:       ld      hl, 1000h
    7399/    AE03 : 3E 80               loc_AE03:       ld      a, 80h
    7400/    AE05 : BC                                  cp      h
    7401/    AE06 : 28 09                               jr      z, loc_AE11
    7402/    AE08 : 23                                  inc     hl
    7403/    AE09 : 7E                                  ld      a, (hl)
    7404/    AE0A : 2F                                  cpl
    7405/    AE0B : 77                                  ld      (hl), a
    7406/    AE0C : BE                                  cp      (hl)
    7407/    AE0D : 2F                                  cpl
    7408/    AE0E : 77                                  ld      (hl), a
    7409/    AE0F : 28 F2                               jr      z, loc_AE03
    7410/    AE11 : 2B                  loc_AE11:       dec     hl
    7411/    AE12 : 7D                                  ld      a, l
    7412/    AE13 : 44                                  ld      b, h
    7413/    AE14 : C9                                  ret
    7414/    AE15 :                     
    7415/    AE15 :                                     end
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 136 - 8/15/2019 11:33:6


  symbol table (* = unused):
  ------------------------

 AB_TO_FPACCU :                8F1E C |  AC_TO_FPACCU :                8F1D C |
 ADD_0_5 :                     9C80 C |  ADD_EXPDIGIT :                A166 C |
 ADD_FPREG_FPACCU :            9C94 C |  ADD_MANTISSAS :               9D5A C |
 ADD_ZEROS :                   A4F9 C |  ADJUST_NUMBER_1E10 :          A41F C |
 ADVANCE_TO_EOLN :             880D C |  AMERGE_ENTER_LINE :           9A58 C |
*ARCHITECTURE :  i386-unknown-win32 - |  ARRAYVALPTR :                  C4A C |
 ARRAY_DECLARE :               8E70 C |  ASSERT_NUMERIC :              8B88 C |
 ASSERT_RUN_PROGRAM :          909C C |  ASSERT_STRING :               8B89 C |
 ATN_POLY_TBL :                A914 C |  AUTO :                        81C3 C |
 AUTO_INCREMENT :               C9C C |  A_AT_LINE :                   AC93 C |
 A_BREAK :                     ACAF C |  A_EXTRALOST :                 ACA3 C |
 A_INVALID_INPUT :             AC84 C |  A_READY :                     AC9B C |
*BIGENDIAN :                      0 - |  BOOLOR :                      8CDD C |
*BRANCHEXT :                      0 - |  BREAK_ENTRY :                 86C7 C |
 BYTES_FREE_MSG :              ADA1 C |  BYTE_103 :                     C03 C |
*BYTE_1B0 :                     CB0 C | *CALL2 :                       9C4B C |
 CALL2B :                      9C4C C | *CASESENSITIVE :                  0 - |
 CHAR_A :                        41 - |  CHAR_AMP :                      26 - |
 CHAR_BSLASH :                   5C - |  CHAR_COLON :                    3A - |
 CHAR_COMMA :                    2C - |  CHAR_CR :                        D - |
 CHAR_CTRLC :                     3 - |  CHAR_CTRLO :                     F - |
 CHAR_CTRLQ :                    11 - |  CHAR_CTRLR :                    12 - |
 CHAR_CTRLS :                    13 - |  CHAR_CTRLT :                    14 - |
 CHAR_CTRLU :                    15 - |  CHAR_CTRLX :                    18 - |
 CHAR_CTRLZ :                    1A - |  CHAR_DOLLAR :                   24 - |
 CHAR_E :                        45 - |  CHAR_ESC :                      1B - |
 CHAR_EXCL :                     21 - |  CHAR_HASH :                     23 - |
 CHAR_LF :                        A - |  CHAR_LPAREN :                   28 - |
 CHAR_MINUS :                    2D - |  CHAR_NINE :                     39 - |
 CHAR_PERCENT :                  25 - |  CHAR_PERIOD :                   2E - |
 CHAR_PLUS :                     2B - |  CHAR_POWER :                    5E - |
 CHAR_QUEST :                    3F - |  CHAR_QUOTE :                    22 - |
 CHAR_RPAREN :                   29 - |  CHAR_RUBOUT :                   7F - |
 CHAR_SEMI :                     3B - |  CHAR_SPACE :                    20 - |
 CHAR_STAR :                     2A - |  CHAR_TAB :                       9 - |
 CHAR_TIC :                      27 - |  CHAR_Z :                        5A - |
 CHAR_ZERO :                     30 - |  CHECK_1000S_MARKER :          A501 C |
 CHECK_ALPHA :                 8714 C |  CHECK_BREAK :                 8693 C |
 CHECK_MEMFREE :               813E C |  COLDSTART :                   ACB7 C |
*COLDSTART0 :                  8000 C |  COLDVECTOR :                   CA4 C |
 COLD_ADDR :                    CA5 C |  COMMAND_DONE :                85CC C |
 COMPARE_HANDLER :             8CF6 C |  COMPARE_TBL :                 8CF4 C |
 CONPARAM :                     C90 C | *CONPARAM_CURPOS :              C90 C |
*CONPARAM_LAST_FIELD :          C92 C | *CONPARAM_LINELENGTH :          C91 C |
*CONPARAM_PADCHAR :             C94 C | *CONPARAM_PADCOUNT :            C93 C |
 CONSOLEIN :                   8009 C |  CONSOLEOUT :                  800F C |
 CONSOLESTAT :                 8018 C |  CONST0_5 :                    A708 C |
 CONST1 :                      9DC0 C | *CONSTPI :        3.141592653589793 - |
 CONST_0_25 :                  A8A2 C |  CONST_PI_DIV_2 :              A89C C |
 CONTLINENO :                   C56 C |  CONTLINEPTR :                  C58 C |
 CON_EMIT_CTRL_CHAR :          83F3 C |  CON_GET_CHAR :                8698 C |
 COPY_0STRING :                90F0 C |  COPY_STRCONST :               90EE C |
 COPY_STRING :                 9259 C |  COPY_STRING1 :                90F1 C |
 CTRLU :                       8401 C |  CTRL_7F :                     83B6 C |
 CURLINENO :                    C9A C |  CURLINEPTR :                   C50 C |
 CURRENTLINENO :                C4C C |  DATA_HANDLER :                8AF8 C |
 DATA_PTR :                     C64 C | *DATE :                   8/15/2019 - |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 137 - 8/15/2019 11:33:6


 DEL_CHAR_FROM_BUF :           9975 C |  DETOKENIZE :                  8537 C |
 DE_PUSH_STRINGSTK :           9110 C |  DIM_FLAG :                     C01 C |
 DIM_LOOP :                    8D5C C |  DISCARD_OPEN_FORLOOPS :       80F6 C |
 DIV_BY_ZERO_ERROR :           8170 C |  DIV_FPREG_FPACCU :            9EC3 C |
 DIV_OVF :                      CAE C |  DO_ASSIGNMENT :               882B C |
 DO_ASSIGNMENT1 :              8833 C |  DO_EXPONENT :                 A118 C |
 DO_LH_MIDS :                  888B C |  DO_MANTISSAPART :             A150 C |
 DO_PERIOD :                   A124 C |  EDIT_APPEND :                 9911 C |
 EDIT_DELEOLN :                990E C |  EDIT_DELETE :                 98E6 C |
 EDIT_END :                    9965 C |  EDIT_FIND :                   98B5 C |
 EDIT_INSERT :                 9916 C |  EDIT_KILL :                   98AF C |
 EDIT_LEFT :                   9959 C |  EDIT_LIST :                   98DC C |
 EDIT_LOOP :                   982D C |  EDIT_RELOAD :                 989C C |
 EDIT_REPLACE :                98FF C |  EDIT_RIGHT :                  98A4 C |
 EDIT_SAVE :                   9968 C |  EDIT_TBL :                    9871 C |
 EMIT_CTRL_CHAR :              83F6 C |  ENABLE_OUTPUT :               82F8 C |
 END_ARRAYS :                   C62 C |  END_FORMAT :                  A2AA C |
 END_FORMAT1 :                 A2AB C |  END_OF_VARS :                  C60 C |
 END_PROGRAM :                 86C8 C |  ERROR_ILLFUNC :               9305 C |
 EXECUTE_COMMAND :             8614 C |  EXECUTE_TOKEN :               861C C |
 EXEC_ALOAD :                  99F2 C |  EXEC_ALOADC :                 9A6B C |
 EXEC_AMERGE :                 99F5 C |  EXEC_AMERGEC :                9A6E C |
 EXEC_ASAVE :                  9541 C |  EXEC_AUTO :                   8A24 C |
 EXEC_CALL :                   9C26 C |  EXEC_CLEAR :                  8772 C |
 EXEC_CONT :                   86E7 C |  EXEC_COPY :                   9AF2 C |
 EXEC_DATA :                   880B C |  EXEC_DEF :                    8F36 C |
 EXEC_DELETE :                 97A3 C |  EXEC_DIM :                    8D65 C |
 EXEC_EDIT :                   97FE C |  EXEC_END :                    86C3 C |
 EXEC_EXCHANGE :               9BB6 C |  EXEC_FNEND :                  901D C |
 EXEC_FOR :                    856A C |  EXEC_GOSUB :                  87A8 C |
 EXEC_GOTO :                   87C5 C |  EXEC_IF :                     8923 C |
 EXEC_INPUT :                  8A55 C |  EXEC_KILL :                   9BF9 C |
 EXEC_LET :                    8827 C |  EXEC_LINEINPUT :              8A4F C |
 EXEC_LIST :                   84EF C |  EXEC_LLIST :                  84EC C |
 EXEC_LLVAR :                  999B C |  EXEC_LNULL :                  86F9 C |
 EXEC_LOAD :                   94FE C |  EXEC_LOADGO :                 9AB0 C |
 EXEC_LPRINT :                 8959 C |  EXEC_LTRACE :                 97D8 C |
 EXEC_LVAR :                   999E C |  EXEC_LWIDTH :                 9462 C |
 EXEC_NEW :                    82B3 C |  EXEC_NEXT :                   8B3B C |
 EXEC_NULL :                   86FC C |  EXEC_ON :                     8906 C |
 EXEC_OUT :                    93DD C |  EXEC_POKE :                   9C71 C |
 EXEC_PRECISION :              9C59 C |  EXEC_PRINT :                  895C C |
 EXEC_RANDOMIZE :              9984 C |  EXEC_READ :                   8AA6 C |
 EXEC_RENUMBER :               95B3 C |  EXEC_RESTORE :                866A C |
 EXEC_RETURN :                 87E6 C |  EXEC_RUN :                    879D C |
 EXEC_SAVE :                   94C5 C |  EXEC_STOP :                   86C1 C |
 EXEC_SWITCH :                 9446 C |  EXEC_TRACE :                  97DB C |
 EXEC_WAIT :                   93E3 C |  EXEC_WIDTH :                  9465 C |
 EXIT_COMPARE :                8D3B C |  EXPECT_CHAR :                 8151 C |
 EXPR :                        8C14 C |  EXPRESSION :                  8B85 C |
 EXPRESSION1 :                 8B9A C |  EXPRESSION_2U8 :              940A C |
 EXPRESSION_U16 :              8724 C |  EXPRESSION_U8_AE :            941B C |
 EXPRESSSION2 :                8B9D C |  EXPR_ALPHA :                  8C67 C |
 EXPR_COMPARE :                8CE2 C |  EXPR_FN :                     8F6C C |
 EXPR_FUNCTION :               8C78 C |  EXPR_HEX :                    A171 C |
 EXPR_MINUS :                  8C56 C |  EXPR_NOT :                    8D45 C |
 EXPR_NUMERIC :                A0E3 C |  EXPR_PAREN :                  8C48 C |
 EXPR_TYPE :                    C02 C |  EXP_POLY_TBL :                A79E C |
*E_ARITH_OV :                  AB55 C | *E_CANT_CONT :                 AC00 C |
*E_COMPLEX :                   ABF5 C | *E_DIV0 :                      ABB3 C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 138 - 8/15/2019 11:33:6


*E_FILES_DIFFER :              AC3A C | *E_FILE_N_FOUND :              AC21 C |
*E_FNRETURN :                  AC52 C | *E_ILL_DIRECT :                ABBB C |
*E_ILL_EOF :                   AC2F C | *E_ILL_FUNC :                  AB45 C |
*E_MISS_STMT :                 AC6C C |  E_NEXT_WO_FOR :               AB12 C |
*E_NO_STRING :                 ABD7 C | *E_OUT_OF_DATA :               AB3A C |
*E_OUT_OF_MEM :                AB68 C |  E_OVERFLOW :                  9D55 C |
 E_OVERFLOW1 :                 9F8B C | *E_RECOVER :                   AC49 C |
*E_REDIM_ARRAY :               AB9F C | *E_STRINGLONG :                ABE6 C |
 E_SUBSCR_RANGE :              AB89 C | *E_SYNTAX_ERROR :              AB1E C |
*E_TYPE_MIS :                  ABC9 C |  E_UNDEF_STMT :                AB75 C |
*E_USERCALL :                  AC0E C | *FALSE :                          0 - |
 FIND_ARRAYVAR :               8ECC C |  FIND_LINE :                   8292 C |
 FIND_LINE_FROM_CURRENT :      8295 C |  FIND_NEXT_DATA :              8B1B C |
 FIND_VAR :                    8D6A C |  FIND_VAR1 :                   8DB4 C |
 FMT_FLAGS :                    CAA C | *FNRETURN_ERROR :              903C C |
 FN_PROGRAM :                  8F4E C |  FORMAT_NUMBER :               A1DD C |
 FORMAT_NUMBER_FMT :           A1DE C |  FORMAT_NUMINBUF :             A383 C |
 FORMAT_PERCENT :              A2B2 C |  FPACCU_ADD_U8 :               A1A1 C |
 FPACCU_CHANGESIGN :           9FD2 C |  FPACCU_CLEAR :                8E09 C |
 FPACCU_COMPARE :              A036 C |  FPACCU_DIV10 :                9EAF C |
 FPACCU_DIV10_AND_INC :        A1B6 C |  FPACCU_EXP :                   C6B C |
 FPACCU_GETSTR :               9263 C |  FPACCU_GET_STRING :           929D C |
 FPACCU_MANT32 :                C66 C |  FPACCU_MANT54 :                C68 C |
 FPACCU_MANT6 :                 C6A C |  FPACCU_MANTSIGN :              C6C C |
 FPACCU_MULT10 :               9F8E C |  FPACCU_MULT10_AND_DEC1 :      A1AF C |
 FPACCU_POLYEVAL :             A7EA C |  FPACCU_POLYEVAL_SQR :         A7DB C |
*FPACCU_POWER :                A71B C |  FPACCU_RESTORESIGN :          A021 C |
 FPACCU_SGN :                  9FBF C |  FPACCU_TO_16 :                872D C |
 FPACCU_TO_FPREG :             A002 C |  FPACCU_TO_MEM :               A016 C |
 FPACCU_TO_U16 :               8727 C |  FPACCU_U8 :                   941E C |
 FPACCU_ZERO :                 9D0E C |  FPREG_COMPLEMENT :            9D72 C |
 FPREG_FIX :                   A075 C |  FPREG_NORMALIZE :             9CF0 C |
 FPREG_SHIFTMANT :             9D8F C |  FP_COMPARE1 :                 A050 C |
*FULLPMMU :                       1 - |  FUNC_TBL :                    802D C |
 GC :                          9173 C |  GC_INNER_ARRAY :              91C4 C |
 GC_INNER_FIND_XSTRING :       91D1 C |  GC_INNER_FIND_XSTRING1 :      91D2 C |
 GC_INNER_SCALAR :             9183 C |  GC_OUTER_WHILE :              9176 C |
 GETNEXT_EXPRESSION_U16 :      8721 C |  GET_INPUT :                   83E2 C |
 GET_INPUTLINE :               8407 C |  GET_LINENO_RANGE :            8273 C |
 GET_MOREINPUT :               83DD C |  GET_NEXT_DATAITEM :           8ACD C |
 GET_NUMARG_STACK :            93FF C |  GET_NUMERIC_DATA :            8AED C |
 GET_RDR :                     9A64 C | *HAS64 :                          1 - |
*HASDSP :                         0 - | *HASFPU :                         0 - |
*HASPMMU :                        0 - |  HAS_BREAK :                   8690 C |
 HAS_FNRETURN :                902B C |  HAS_MEMSIZE :                 AD34 C |
 HIGHMEM_MSG :                 AD92 C |  HLRESTORE :                   9C57 C |
 HL_TO_FPACCU :                8F17 C |  ILLFUNC_ERROR :               8744 C |
 ILL_DIRECT_ERROR :            90A5 C | *INEXTMODE :                      0 - |
 INIT_FROM_CURRENT :           82C6 C |  INIT_FROM_START :             82C2 C |
*INLWORDMODE :                    0 - | *INMAXMODE :                      0 - |
 INPUTBUF :                     CB1 C |  INPUTBUF_CNT :                 CA7 C |
 INPUT_CTRLC :                 868E C |  INPUT_CTRLC1 :                868F C |
 INPUT_READ_FLAG :              C4F C | *INSRCMODE :                      0 - |
*INSUPMODE :                      0 - |  INVALID_INPUT :               8157 C |
 IOCHECK :                     801B C |  IOPARAMS_CURPOS :                0 - |
 IOPARAMS_LAST_FIELD :            2 - | *IOPARAMS_LEN :                   5 - |
 IOPARAMS_LINELENGTH :            1 - |  IOPARAMS_PADCHAR :               4 - |
 IOPARAMS_PADCOUNT :              3 - |  IOSET :                       801E C |
 IOSUPPRESS :                   C00 C |  KILL_ARRAY :                  9C01 C |
 KILL_MATRIX :                 8E3C C |  KWD_FOUND :                   855A C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 139 - 8/15/2019 11:33:6


 LINENO :                       C54 C |  LINEPTRSAVE :                  C52 C |
 LIST1 :                       84F4 C | *LISTON :                         1 - |
 LISTOUT :                     8015 C |  LOAD_AND_ADD_FPACCU :         9C83 C |
 LOAD_FPREG :                  A005 C |  LOAD_FPREG_AND_SUBTR :        9C88 C |
 LOCATE_FN_INFO :              90AA C |  LOC_106F :                    8D6F C |
 LOC_1084 :                    8D84 C |  LOC_108F :                    8D8F C |
 LOC_109C :                    8D9C C |  LOC_10C3 :                    8DC3 C |
 LOC_1156 :                    8E56 C |  LOC_1192 :                    8E92 C |
 LOC_11F2 :                    8EF2 C | *LOC_120E :                    8F0E C |
 LOC_1211 :                    8F11 C |  LOC_1227 :                    8F27 C |
 LOC_1292 :                    8F92 C |  LOC_12B7 :                    8FB7 C |
 LOC_12BF :                    8FBF C |  LOC_12EC :                    8FEC C |
 LOC_12F6 :                    8FF6 C |  LOC_130C :                    900C C |
 LOC_1334 :                    9034 C |  LOC_1346 :                    9046 C |
 LOC_1366 :                    9066 C |  LOC_1370 :                    9070 C |
 LOC_137D :                    907D C |  LOC_138C :                    908C C |
 LOC_1430 :                    9130 C |  LOC_1468 :                    9168 C |
 LOC_14AB :                    91AB C |  LOC_14F8 :                    91F8 C |
 LOC_1553 :                    9253 C |  LOC_1581 :                    9281 C |
 LOC_15C2 :                    92C2 C |  LOC_15CA :                    92CA C |
 LOC_15CD :                    92CD C |  LOC_15CE :                    92CE C |
 LOC_15D5 :                    92D5 C |  LOC_1617 :                    9317 C |
 LOC_1666 :                    9366 C |  LOC_1686 :                    9386 C |
 LOC_16A6 :                    93A6 C |  LOC_16BC :                    93BC C |
 LOC_16BE :                    93BE C |  LOC_16C3 :                    93C3 C |
 LOC_16C7 :                    93C7 C |  LOC_16CC :                    93CC C |
 LOC_16D0 :                    93D0 C |  LOC_16D1 :                    93D1 C |
 LOC_16F7 :                    93F7 C |  LOC_174D :                    944D C |
 LOC_1751 :                    9451 C |  LOC_17A2 :                    94A2 C |
 LOC_17A7 :                    94A7 C |  LOC_17BA :                    94BA C |
 LOC_17BC :                    94BC C |  LOC_17BF :                    94BF C |
 LOC_1807 :                    9507 C |  LOC_180F :                    950F C |
 LOC_183C :                    953C C |  LOC_186E :                    956E C |
 LOC_1885 :                    9585 C |  LOC_18DF :                    95DF C |
 LOC_18FF :                    95FF C |  LOC_194A :                    964A C |
 LOC_1954 :                    9654 C |  LOC_1957 :                    9657 C |
*LOC_1996 :                    9696 C |  LOC_19A7 :                    96A7 C |
 LOC_19B8 :                    96B8 C |  LOC_19ED :                    96ED C |
 LOC_19F0 :                    96F0 C |  LOC_1A07 :                    9707 C |
 LOC_1A2B :                    972B C |  LOC_1A49 :                    9749 C |
 LOC_1A56 :                    9756 C |  LOC_1AFA :                    97FA C |
 LOC_1B03 :                    9803 C |  LOC_1B15 :                    9815 C |
 LOC_1B46 :                    9846 C |  LOC_1B50 :                    9850 C |
 LOC_1B6B :                    986B C |  LOC_1BCF :                    98CF C |
 LOC_1BD1 :                    98D1 C |  LOC_1BDA :                    98DA C |
 LOC_1C33 :                    9933 C |  LOC_1C3A :                    993A C |
 LOC_1C41 :                    9941 C |  LOC_1C82 :                    9982 C |
 LOC_1CE4 :                    99E4 C |  LOC_1CE8 :                    99E8 C |
 LOC_1CF0 :                    99F0 C |  LOC_1CFE :                    99FE C |
 LOC_1D21 :                    9A21 C |  LOC_1D25 :                    9A25 C |
 LOC_1D2D :                    9A2D C |  LOC_1D5F :                    9A5F C |
 LOC_1D8A :                    9A8A C |  LOC_1D93 :                    9A93 C |
 LOC_1DAA :                    9AAA C |  LOC_1DC9 :                    9AC9 C |
 LOC_1E0A :                    9B0A C |  LOC_1E5D :                    9B5D C |
 LOC_1E74 :                    9B74 C |  LOC_1EB0 :                    9BB0 C |
 LOC_1F15 :                    9C15 C |  LOC_1F19 :                    9C19 C |
 LOC_1FB2 :                    9CB2 C |  LOC_1FF3 :                    9CF3 C |
 LOC_200F :                    9D0F C |  LOC_201F :                    9D1F C |
 LOC_2022 :                    9D22 C |  LOC_2034 :                    9D34 C |
 LOC_20A5 :                    9DA5 C | *LOC_20B3 :                    9DB3 C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 140 - 8/15/2019 11:33:6


 LOC_2168 :                    9E68 C |  LOC_217B :                    9E7B C |
 LOC_2196 :                    9E96 C |  LOC_21AD :                    9EAD C |
 LOC_221E :                    9F1E C |  LOC_2222 :                    9F22 C |
 LOC_2235 :                    9F35 C |  LOC_2241 :                    9F41 C |
 LOC_225E :                    9F5E C |  LOC_2280 :                    9F80 C |
 LOC_2286 :                    9F86 C |  LOC_2287 :                    9F87 C |
 LOC_22C8 :                    9FC8 C |  LOC_22CA :                    9FCA C |
 LOC_239B :                    A09B C |  LOC_23DB :                    A0DB C |
 LOC_23ED :                    A0ED C |  LOC_2439 :                    A139 C |
 LOC_2449 :                    A149 C |  LOC_2487 :                    A187 C |
 LOC_2489 :                    A189 C |  LOC_249B :                    A19B C |
 LOC_24EC :                    A1EC C |  LOC_24FA :                    A1FA C |
 LOC_251E :                    A21E C |  LOC_253C :                    A23C C |
 LOC_2551 :                    A251 C |  LOC_2552 :                    A252 C |
 LOC_2555 :                    A255 C |  LOC_255A :                    A25A C |
 LOC_2564 :                    A264 C |  LOC_2574 :                    A274 C |
 LOC_2580 :                    A280 C |  LOC_2583 :                    A283 C |
 LOC_258E :                    A28E C |  LOC_259D :                    A29D C |
 LOC_259F :                    A29F C |  LOC_25D3 :                    A2D3 C |
 LOC_25FC :                    A2FC C |  LOC_2600 :                    A300 C |
 LOC_262C :                    A32C C |  LOC_262F :                    A32F C |
 LOC_2636 :                    A336 C |  LOC_263C :                    A33C C |
 LOC_2641 :                    A341 C |  LOC_2689 :                    A389 C |
 LOC_268E :                    A38E C |  LOC_26AA :                    A3AA C |
 LOC_26BB :                    A3BB C |  LOC_26C5 :                    A3C5 C |
 LOC_26CE :                    A3CE C |  LOC_26D7 :                    A3D7 C |
 LOC_26DE :                    A3DE C |  LOC_26FB :                    A3FB C |
 LOC_270F :                    A40F C |  LOC_2716 :                    A416 C |
 LOC_2745 :                    A445 C |  LOC_2765 :                    A465 C |
 LOC_2844 :                    A544 C |  LOC_2847 :                    A547 C |
 LOC_2856 :                    A556 C |  LOC_2859 :                    A559 C |
 LOC_285E :                    A55E C |  LOC_2871 :                    A571 C |
 LOC_2877 :                    A577 C |  LOC_28B0 :                    A5B0 C |
 LOC_28BB :                    A5BB C |  LOC_28EB :                    A5EB C |
 LOC_2908 :                    A608 C |  LOC_290A :                    A60A C |
*LOC_291A :                    A61A C |  LOC_2923 :                    A623 C |
 LOC_2951 :                    A651 C |  LOC_2954 :                    A654 C |
 LOC_2973 :                    A673 C |  LOC_2978 :                    A678 C |
 LOC_299A :                    A69A C |  LOC_299B :                    A69B C |
 LOC_29A4 :                    A6A4 C |  LOC_29DC :                    A6DC C |
 LOC_29E7 :                    A6E7 C |  LOC_29EA :                    A6EA C |
 LOC_2A44 :                    A744 C |  LOC_2A97 :                    A797 C |
 LOC_2B35 :                    A835 C |  LOC_2B88 :                    A888 C |
 LOC_2C0A :                    A90A C |  LOC_2FCD :                    ACBB C |
 LOC_2FCE :                    ACBC C |  LOC_3048 :                    AD20 C |
 LOC_306A :                    AD42 C |  LOC_3082 :                    AD5A C |
 LOC_413 :                     8113 C |  LOC_41F :                     811F C |
 LOC_467 :                     8167 C |  LOC_494 :                     8194 C |
 LOC_4DA :                     81DA C |  LOC_4E4 :                     81E4 C |
 LOC_4F1 :                     81F1 C |  LOC_4F9 :                     81F9 C |
 LOC_516 :                     8216 C |  LOC_531 :                     8231 C |
 LOC_585 :                     8285 C |  LOC_58E :                     828E C |
 LOC_5F4 :                     82F4 C |  LOC_630 :                     8330 C |
 LOC_64A :                     834A C |  LOC_652 :                     8352 C |
 LOC_662 :                     8362 C |  LOC_66A :                     836A C |
 LOC_66B :                     836B C |  LOC_674 :                     8374 C |
 LOC_687 :                     8387 C |  LOC_68A :                     838A C |
 LOC_693 :                     8393 C |  LOC_694 :                     8394 C |
 LOC_69B :                     839B C |  LOC_6A1 :                     83A1 C |
 LOC_6AD :                     83AD C |  LOC_6CA :                     83CA C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 141 - 8/15/2019 11:33:6


 LOC_704 :                     8404 C |  LOC_713 :                     8413 C |
 LOC_741 :                     8441 C |  LOC_74F :                     844F C |
 LOC_753 :                     8453 C |  LOC_75F :                     845F C |
*LOC_78D :                     848D C |  LOC_79D :                     849D C |
 LOC_7A1 :                     84A1 C |  LOC_7A6 :                     84A6 C |
 LOC_7B6 :                     84B6 C |  LOC_7B9 :                     84B9 C |
 LOC_7E1 :                     84E1 C |  LOC_834 :                     8534 C |
 LOC_84A :                     854A C |  LOC_867 :                     8567 C |
 LOC_87B :                     857B C | *LOC_88B :                     858B C |
 LOC_8BD :                     85BD C |  LOC_8C8 :                     85C8 C |
 LOC_8F4 :                     85F4 C |  LOC_91B :                     861B C |
 LOC_939 :                     8639 C |  LOC_93C :                     863C C |
 LOC_94D :                     864D C |  LOC_955 :                     8655 C |
 LOC_9861 :                    9861 C |  LOC_9AB :                     86AB C |
 LOC_9BA :                     86BA C |  LOC_9DA :                     86DA C |
*LOC_A42 :                     8742 C |  LOC_A46 :                     8746 C |
 LOC_A9A :                     879A C |  LOC_AC1 :                     87C1 C |
 LOC_ADA :                     87DA C |  LOC_ADF8 :                    ADF8 C |
 LOC_AE03 :                    AE03 C |  LOC_AE11 :                    AE11 C |
 LOC_AE3 :                     87E3 C |  LOC_B07 :                     8807 C |
 LOC_B7A :                     887A C |  LOC_B82 :                     8882 C |
 LOC_BB6 :                     88B6 C |  LOC_BD0 :                     88D0 C |
 LOC_BED :                     88ED C |  LOC_C01 :                     8901 C |
 LOC_C36 :                     8936 C |  LOC_C46 :                     8946 C |
 LOC_C48 :                     8948 C |  LOC_C9A :                     899A C |
 LOC_CCA :                     89CA C |  LOC_CCD :                     89CD C |
 LOC_CE1 :                     89E1 C |  LOC_CE9 :                     89E9 C |
 LOC_D39 :                     8A39 C |  LOC_D6E :                     8A6E C |
 LOC_D93 :                     8A93 C |  LOC_DB2 :                     8AB2 C |
 LOC_DB7 :                     8AB7 C |  LOC_DE1 :                     8AE1 C |
 LOC_E02 :                     8B02 C |  LOC_E31 :                     8B31 C |
 LOC_E75 :                     8B75 C |  LOC_E92 :                     8B92 C |
 LOC_EA9 :                     8BA9 C |  LOC_EAC :                     8BAC C |
 LOC_ECF :                     8BCF C |  LOC_EF7 :                     8BF7 C |
 LOC_F62 :                     8C62 C |  LOC_F6A :                     8C6A C |
 LOC_FA8 :                     8CA8 C |  LOC_FAB :                     8CAB C |
 LOC_FB3 :                     8CB3 C |  LOG_POLY_TBL :                9DC6 C |
 LOOP1024 :                    8D24 C |  LOOP1085 :                    8D85 C |
 LOOP10F6 :                    8DF6 C |  LOOP111A :                    8E1A C |
 LOOP1142 :                    8E42 C |  LOOP118B :                    8E8B C |
 LOOP11AE :                    8EAE C |  LOOP11D1 :                    8ED1 C |
 LOOP1242 :                    8F42 C |  LOOP124B :                    8F4B C |
 LOOP1260 :                    8F60 C |  LOOP128D :                    8F8D C |
 LOOP12D3 :                    8FD3 C |  LOOP134F :                    904F C |
 LOOP1350 :                    9050 C |  LOOP13F4 :                    90F4 C |
 LOOP143B :                    913B C |  LOOP1495 :                    9195 C |
 LOOP14AA :                    91AA C |  LOOP16B6 :                    93B6 C |
 LOOP16F8 :                    93F8 C |  LOOP1771 :                    9471 C |
 LOOP1785 :                    9485 C |  LOOP1787 :                    9487 C |
 LOOP1791 :                    9491 C |  LOOP17AD :                    94AD C |
 LOOP17D7 :                    94D7 C |  LOOP17E7 :                    94E7 C |
 LOOP17F7 :                    94F7 C |  LOOP1818 :                    9518 C |
 LOOP181A :                    951A C |  LOOP1846 :                    9546 C |
 LOOP184E :                    954E C |  LOOP188D :                    958D C |
 LOOP1988 :                    9688 C |  LOOP19A0 :                    96A0 C |
 LOOP19FF :                    96FF C |  LOOP1A4D :                    974D C |
 LOOP1A82 :                    9782 C |  LOOP1A86 :                    9786 C |
 LOOP1AC7 :                    97C7 C |  LOOP1B23 :                    9823 C |
 LOOP1B2F :                    982F C |  LOOP1B51 :                    9851 C |
 LOOP1B54 :                    9854 C |  LOOP1BC3 :                    98C3 C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 142 - 8/15/2019 11:33:6


 LOOP1BEE :                    98EE C |  LOOP1C77 :                    9977 C |
 LOOP1CA3 :                    99A3 C |  LOOP1CF9 :                    99F9 C |
 LOOP1D3C :                    9A3C C |  LOOP1D41 :                    9A41 C |
 LOOP1D73 :                    9A73 C |  LOOP1E91 :                    9B91 C |
 LOOP1E96 :                    9B96 C |  LOOP1F35 :                    9C35 C |
 LOOP1FF6 :                    9CF6 C |  LOOP2013 :                    9D13 C |
 LOOP217F :                    9E7F C |  LOOP21F3 :                    9EF3 C |
 LOOP23CE :                    A0CE C |  LOOP23F5 :                    A0F5 C |
 LOOP243A :                    A13A C |  LOOP2474 :                    A174 C |
 LOOP2616 :                    A316 C |  LOOP2646 :                    A346 C |
 LOOP2647 :                    A347 C |  LOOP2658 :                    A358 C |
 LOOP2674 :                    A374 C |  LOOP267C :                    A37C C |
 LOOP2690 :                    A390 C |  LOOP26ED :                    A3ED C |
 LOOP2725 :                    A425 C |  LOOP273D :                    A43D C |
 LOOP2781 :                    A481 C |  LOOP278E :                    A48E C |
 LOOP2806 :                    A506 C |  LOOP2817 :                    A517 C |
 LOOP287A :                    A57A C |  LOOP29F2 :                    A6F2 C |
 LOOP2AF3 :                    A7F3 C |  LOOP3FD :                     80FD C |
 LOOP48A :                     818A C |  LOOP48D :                     818D C |
 LOOP4A9 :                     81A9 C |  LOOP505 :                     8205 C |
 LOOP521 :                     8221 C |  LOOP54F :                     824F C |
 LOOP569 :                     8269 C |  LOOP612 :                     8312 C |
 LOOP637 :                     8337 C |  LOOP639 :                     8339 C |
 LOOP642 :                     8342 C |  LOOP6A5 :                     83A5 C |
 LOOP6C0 :                     83C0 C |  LOOP710 :                     8410 C |
 LOOP737 :                     8437 C |  LOOP795 :                     8495 C |
 LOOP83B :                     853B C |  LOOP83C :                     853C C |
 LOOP852 :                     8552 C |  LOOP9AF :                     86AF C |
 LOOPA4D :                     874D C |  LOOPB11 :                     8811 C |
 LOOPB14 :                     8814 C |  LOOPBFB :                     88FB C |
 LOOPC16 :                     8916 C |  LOOPC3D :                     893D C |
 LOOPCAE :                     89AE C |  LOOPCCF :                     89CF C |
 LOOPCFF :                     89FF C |  LOOPD7C :                     8A7C C |
 LOOPEB6 :                     8BB6 C | *MACEXP :                         7 - |
 MAKE_SPACE :                  8119 C |  MANT_INC_R :                  9D45 C |
 MANT_SHIFT1 :                 9DA8 C |  MANT_SHIFT8 :                 9D91 C |
 MANT_SHIFTRIGHT1 :            9DAC C |  MASK_7BIT :                     7F - |
 MATH_ABS :                    9FCE C |  MATH_ASC :                    92A8 C |
 MATH_ATN :                    A8EA C |  MATH_CHRS :                   92B6 C |
 MATH_COS :                    A84A C |  MATH_EXP :                    A764 C |
 MATH_FRE :                    8EF6 C |  MATH_INP :                    93D4 C |
 MATH_INSTR :                  932E C |  MATH_INT :                    A0AD C |
 MATH_LEFTS :                  92C6 C |  MATH_LEN :                    9299 C |
 MATH_LOG :                    9DEB C |  MATH_LPOS :                   8F2A C |
 MATH_MIDS :                   92FF C |  MATH_PEEK :                   9C6A C |
 MATH_POS :                    8F2F C |  MATH_RIGHTS :                 92F6 C |
 MATH_RND :                    A80E C |  MATH_SGN :                    9FA3 C |
 MATH_SIN :                    A850 C |  MATH_SQR :                    A70E C |
 MATH_STRS :                   90BA C |  MATH_TAN :                    A8D3 C |
 MATH_USR :                    8006 C |  MATH_VAL :                    942B C |
 MEMEND :                       DFF - |  MEMORY_TOP :                   C04 C |
 MEMSIZE :                     8021 C |  MEM_TO_FPACCU :               9FEC C |
*MOMCPU :                      80DC - | *MOMCPUNAME :              Z80UNDOC - |
 MOVE_TO_VAR :                 A019 C |  MULT10_AND_DEC :              A1AE C |
 MULTIPLY_FPREG_FPACCU :       9E3F C |  MULT_DIV_CALCEXPONENT :       9F63 C |
*NESTMAX :                      100 - |  NEW_MEMORY :                  82B4 C |
 NEXTCHAR :                    8647 C |  NEXT_FPACCU_U8 :              9418 C |
 NEXT_WO_FOR_ERROR :           817C C |  NULL :                           0 - |
 NUMBERBUF :                    C6E C |  NUMBERBUF0 :                   C6D C |
 NUMBER_DONE :                 A127 C |  OPER_TBL :                    8061 C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 143 - 8/15/2019 11:33:6


 OUTPUTVECTOR :                 C8D C |  OUTPUT_ADDR :                  C8E C |
 OUTPUT_NUM_DIGITS :           A46D C |  OUT_OF_MEMORY_ERROR :         814D C |
*PACKING :                        0 - | *PADDING :                        1 - |
 PAD_ZEROS :                   A51B C |  PARSE_LINENO :                8749 C |
 PARSE_NUMBER_FPACCU :         A0DE C |  PEEKPOP_STR_STRINGSTK :       9283 C |
 PEEK_STR_STRINGSTK :          9267 C |  PLUS_IF_D :                   A6F9 C |
 POP_FPREG_AND_ADD :           A1A7 C |  POP_FPREG_AND_BOOLAND :       8CBD C |
 POP_FPREG_AND_BOOLOR :        8CBC C |  POP_FPREG_AND_DIV :           9EBF C |
 POP_FPREG_AND_MULT :          9E3B C |  POP_FPREG_AND_POWER :         A717 C |
 POP_FPREG_AND_SUB :           9C8D C |  POP_STR_STRINGSTK :           9266 C |
 POS_PERIOD :                   CA8 C |  POWERS10 :                    A4C2 C |
 PRECISION :                    CAF C |  PREC_ADDSUB :                   79 - |
 PREC_AND :                      50 - |  PREC_MINUS :                    7D - |
 PREC_MULDIV :                   7C - |  PREC_NOT :                      5A - |
 PREC_OR :                       46 - |  PREC_POWER :                    7F - |
 PREC_RELOP :                    78 - |  PREC_STRCMP :                   64 - |
 PRE_GOTO :                    87C4 C |  PRINTCOMMA :                  89A3 C |
 PRINTSEMI :                   89D4 C |  PRINTSPC :                    89B5 C |
 PRINTTAB :                    89B6 C |  PRINTUSING :                  A521 C |
 PRINT_AT_LINENO :             A1C1 C |  PRINT_BACKSLASH :             8470 C |
 PRINT_BACKSLASH1 :            98FA C |  PRINT_B_SPACES :              A6F1 C |
 PRINT_CHAR :                  8466 C |  PRINT_CRLF :                  89EE C |
 PRINT_ERROR :                 817E C |  PRINT_ERROR1 :                912D C |
 PRINT_FIELD_AND_TRAILING :    A6DB C |  PRINT_HL :                    A1C9 C |
 PRINT_LEAD_FIELD_TRAIL :      A6D6 C |  PRINT_MAINLOOP :              A641 C |
 PRINT_NUL_DELAY :             89FB C |  PRINT_PROMPT :                81A0 C |
 PRINT_READY_PROMPT :          89DB C |  PRINT_SPACE :                 8464 C |
 PRINT_STRING :                84BD C |  PROCESS_ON :                  8915 C |
 PROG_END :                     C5E C |  PROMPT_EDIT_LINENO :          8A0E C |
 PROMPT_FLAG :                  CAB C |  PRTPARAM :                     C95 C |
*PRTPARAM_CURPOS :              C95 C | *PRTPARAM_LAST_FIELD :          C97 C |
*PRTPARAM_LINELENGTH :          C96 C | *PRTPARAM_PADCHAR :             C99 C |
*PRTPARAM_PADCOUNT :            C98 C |  PUNCHOUT :                    8012 C |
 PUNCH_ASCIZ :                 9595 C |  PUSH_CHANGESIGN :             A703 C |
 PUSH_FPACCU :                 9FDA C |  PUSH_FPACCU_EX :              9FDB C |
 READERIN :                    800C C |  READ_CONCHAR :                84C9 C |
 READ_INPUT :                  8AAB C |  READ_LINENO :                 8685 C |
 READ_LINENO_HERE :            8686 C |  READ_READER :                 94B6 C |
 READ_READER_ZERO :            94AB C |  REBUILD_NEXTCHAIN :           8256 C |
 REBUILD_NEXTCHAIN1 :          825F C |  RECOVERED_MSG :               8173 C |
 REDIM_ARRAY_ERROR :           8176 C | *RELAXED :                        0 - |
 RENUM_DOLINE :                9637 C |  RENUM_EOLN :                  9768 C |
 RENUM_INCR :                   C9F C |  RENUM_NEW :                    CA1 C |
 RENUM_SEARCH :                965B C |  RENUM_SEARCH1 :               965E C |
 RENUM_SIZE :                   C9E C |  RENUM_START :                  CAC C |
 RENUM_TARGET :                967A C |  RESERVE_STRSPACE :            9149 C |
 RESERVE_STRSPACE1 :           914B C | *RESETVECTOR :                    0 C |
*RESET_ADDR :                     1 C |  RESET_DATAPTR :               867B C |
 RESET_STACK_WARM :            82DB C |  RESTORE_DE_BC :               A06C C |
*RET_WO_GOSUB :                AB2A C |  RNDMANT6_EXP :                 C8B C |
 RND_MANT23 :                   C87 C |  RND_MANT45 :                   C89 C |
 ROUND_STORE_FPREG :           9D33 C |  S24_TO_FP :                   9FAB C |
 S8_TO_FP :                    9FA6 C |  SELECT_CONSOLE :              82FC C |
 SELECT_PRINTER :              95A6 C | *SERIAL :                      AB10 C |
 SET_COMMA :                   A45A C |  SET_DATAPTR :                 867F C |
 SET_DATAPTR1 :                8680 C |  SET_PERIOD :                  A45D C |
 SIN_POLY_TBL :                A8A8 C |  SKIPSPACE :                   8648 C |
 START_MEMORY :                 C5C C |  STORE_FPACCU :                9FF5 C |
 STORE_STRING :                884D C |  STRACCU :                      C44 C |
 STRACCU_ADDR :                 C46 C |  STRACCU_COPY :                90ED C |
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 144 - 8/15/2019 11:33:6


 STRACCU_COPY_PRINT :          9131 C |  STRACCU_LENGTH :               C44 C |
 STRACCU_PRINT :               9134 C |  STRACCU_PUSH_EXPRSTACK :      910C C |
 STRACCU_RESERVE_STRSPACE :    90DE C |  STRACCU_STORE :               90E1 C |
*STRACCU_UNUSED :               C45 C |  STRINGSTK :                    C08 C |
 STRINGSTKPTR :                 C06 C |  STRING_ADD :                  9212 C |
 STRING_BASE :                  C5A C | *STRING_DESC_ADDR :               2 - |
*STRING_DESC_LEN :                4 - | *STRING_DESC_LENGTH :             0 - |
*STRING_DESC_UNUSED :             1 - |  STRING_DUP :                  90CA C |
 STRING_END :                  9100 C |  STRING_EXPRESSION :           9260 C |
 STRING_EXPRESSION1 :          8B95 C |  STRING_TOP :                   C48 C |
 SUBSCRIPT_FLAG :               C4E C |  SUBSCRIPT_RANGE_ERROR :       8E6B C |
 SUBTR_FPREG_FPACCU :          9C91 C |  SUBTR_MANTISSA :              9CD6 C |
 SUB_1549 :                    9249 C |  SUB_177E :                    947E C |
 SUB_1DD5 :                    9AD5 C |  SUB_2591 :                    A291 C |
 SUB_2748 :                    A448 C |  SUB_2815 :                    A515 C |
 SUB_82A :                     852A C |  SUB_833 :                     8533 C |
 SUB_A1C :                     871C C |  SUB_AE00 :                    AE00 C |
 SUB_E3E :                     8B3E C |  SYNTAX_ERROR :                816D C |
 TEMPORARY_SELECT_PRINTER :    959F C | *TIME :                     11:33:6 - |
 TOKEN1_DISPATCH :             80B0 C |  TOKEN2_DISPATCH :             8076 C |
 TOKENIZE_LINE :               8309 C |  TOKEN_CHRS :                    C3 - |
 TOKEN_CONT :                    EB - |  TOKEN_DATA :                    83 - |
 TOKEN_ELSE :                    C9 - | *TOKEN_END :                     80 - |
 TOKEN_EQUAL :                   AD - |  TOKEN_EXCL :                    9C - |
 TOKEN_FN :                      A0 - |  TOKEN_FNEND :                   89 - |
 TOKEN_FOR :                     81 - |  TOKEN_GOSUB :                   8C - |
 TOKEN_GOTO :                    88 - |  TOKEN_GREATER :                 AC - |
 TOKEN_IF :                      8A - |  TOKEN_INPUT :                   84 - |
 TOKEN_INSTR :                   C8 - | *TOKEN_LESS :                    AE - |
 TOKEN_LPOS :                    C7 - |  TOKEN_MIDS :                    C6 - |
 TOKEN_MINUS :                   A6 - |  TOKEN_NOT :                     A3 - |
 TOKEN_PLUS :                    A5 - |  TOKEN_QUEST :                   97 - |
 TOKEN_REM :                     8E - |  TOKEN_RESTORE :                 8B - |
 TOKEN_SGN :                     AF - |  TOKEN_SPC :                     A1 - |
 TOKEN_STEP :                    A4 - |  TOKEN_TAB :                     9E - |
 TOKEN_TBL :                   A963 C |  TOKEN_THEN :                    A2 - |
 TOKEN_TIC :                     D5 - |  TOKEN_TO :                      9F - |
 TOKEN_USING :                   9D - |  TRACE_CURLINENO :             979A C |
 TRACE_LINENO :                979D C |  TRACE_MODE :                   CA3 C |
 TRAP :                        8024 C | *TRUE :                           1 - |
 TYPE_MISMATCH_ERROR :         8B90 C |  UA_TO_FPACCU :                8F32 C |
 UDE_TO_FPACCU :               8F18 C |  UMULTIPLY16 :                 A0C6 C |
 UNDEF_STMT_ERROR :            87E1 C |  USERCALL_ERROR :              8179 C |
 USING_DOLLAR :                A5B7 C |  USING_DP :                    A5E1 C |
 USING_DP1 :                   A5D6 C |  USING_END :                   A66D C |
 USING_MINUS :                 A620 C |  USING_NUMERIC :               A5BE C |
 USING_STRING :                A681 C |  VAR_FOUND :                   8E06 C |
 VAR_NOT_FOUND :               8DCE C |  VAR_SUBSCRIPT :               8E14 C |
 VERIFY_EXPRTYPE :             8B8A C |  VERIFY_SPACE :                8131 C |
*VERSION :                     142F - | *WARMSTART0 :                  8003 C |
 WRITE_CHAR :                  8472 C |

   1055 symbols
     83 unused symbols

 AS V1.42 Beta [Bld 139] - source file basic.asm - page 145 - 8/15/2019 11:33:6


  defined macros:
  ---------------

CPHL_DE                               | EXPECT                               
FPREG_CONST                           | LDBC_HL                              
LDBC_M                                | LDDE_HL                              
LDDE_M                                | LDHL_BC                              
LDHL_DE                               | LDHL_M                               
LDM_BC                                | LDM_DE                               
POP_FPREG                             | PUSH_FPREG                           
PUSH_FPREG1                           | TEST_0                               
TEST_FFFF                             |

     17 macros

 AS V1.42 Beta [Bld 139] - source file basic.asm - page 146 - 8/15/2019 11:33:6


  defined structures/unions:
  --------------------------

IOPARAMS
  0      (0) CURPOS
  1      (0) LINELENGTH
  2      (0) LAST_FIELD
  3      (0) PADCOUNT
  4      (0) PADCHAR

STRING_DESC
  0      (0) LENGTH
  1      (0) UNUSED
  2      (1) ADDR
 AS V1.42 Beta [Bld 139] - source file basic.asm - page 147 - 8/15/2019 11:33:6


  codepages:
  ----------

STANDARD (0 changed characters)


0.11 seconds assembly time

   7416 lines source file
   8028 lines incl. macro expansions
      2 passes
      0 errors
      0 warnings
